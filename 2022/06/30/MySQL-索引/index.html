<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="索引概念：索引是为了加快数据查询的一种数据结构 索引类型   类型分类     存储结构维度划分 B + Tree索引、B-Tree索引、Hash索引   应用层次维度划分 主键索引，普通索引、唯一索引、全文索引、空间索引   索引键值类型维度划分 主键索引、辅助索引（二级索引）   数据存储和索引键值逻辑关系维度划分 聚集索引（聚簇索引）、非聚集索引（非聚簇索引）   索引组成维度划分 组合索引">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-索引">
<meta property="og:url" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:description" content="索引概念：索引是为了加快数据查询的一种数据结构 索引类型   类型分类     存储结构维度划分 B + Tree索引、B-Tree索引、Hash索引   应用层次维度划分 主键索引，普通索引、唯一索引、全文索引、空间索引   索引键值类型维度划分 主键索引、辅助索引（二级索引）   数据存储和索引键值逻辑关系维度划分 聚集索引（聚簇索引）、非聚集索引（非聚簇索引）   索引组成维度划分 组合索引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/Structure.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/1629472050.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/cluster.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/09d41fad701d3fe1911f1e3cc07f0cbfaf0667210b13381a81e666fe4e15e5f5.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/de316df6d2b621efef0de6fd923b6415e50e3c9f2674036dc1805ec9ae1914ff.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/Secondary_Index.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/LN2NLF.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/MyISAM.png">
<meta property="og:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/MyISAM_Secondary_Key.png">
<meta property="article:published_time" content="2022-06-30T15:09:03.000Z">
<meta property="article:modified_time" content="2023-03-21T18:13:24.409Z">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/Structure.png">

<link rel="canonical" href="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL-索引 | swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL-索引
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 23:09:03" itemprop="dateCreated datePublished" datetime="2022-06-30T23:09:03+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-22 02:13:24" itemprop="dateModified" datetime="2023-03-22T02:13:24+08:00">2023-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>概念：索引是为了加快数据查询的一种数据结构</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><table>
<thead>
<tr>
<th>类型分类</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储结构维度划分</strong></td>
<td>B + Tree索引、B-Tree索引、Hash索引</td>
</tr>
<tr>
<td><strong>应用层次维度划分</strong></td>
<td>主键索引，普通索引、唯一索引、全文索引、空间索引</td>
</tr>
<tr>
<td><strong>索引键值类型维度划分</strong></td>
<td>主键索引、辅助索引（二级索引）</td>
</tr>
<tr>
<td><strong>数据存储和索引键值逻辑关系维度划分</strong></td>
<td>聚集索引（聚簇索引）、非聚集索引（非聚簇索引）</td>
</tr>
<tr>
<td><strong>索引组成维度划分</strong></td>
<td>组合索引（复合索引）、单一索引</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="Mysql为什么使用B-树"><a href="#Mysql为什么使用B-树" class="headerlink" title="Mysql为什么使用B+树"></a>Mysql为什么使用B+树</h2><ul>
<li>在一棵B+树中,每个节点都是一个页,每次新建节点的时候,就会新建一个页。</li>
<li>B+数的同一层节点中,通过页的结构构成一个双向链表</li>
<li>非叶子节点,包括了多个索引行,每个索引行里面存储了索引键和指向下一页面的指针</li>
<li>叶子节点存储了关键字和行记录,在节点内部(也就是页结构的内部)记录的是一个单向链表</li>
</ul>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/Structure.png"></p>
<h3 id="关键点：高度低、叶子节点是链表、查询稳定"><a href="#关键点：高度低、叶子节点是链表、查询稳定" class="headerlink" title="关键点：高度低、叶子节点是链表、查询稳定"></a>关键点：高度低、叶子节点是链表、查询稳定</h3><ul>
<li><p>和二叉树比，比如平衡二叉树，B+树是多叉树（MySql默认是5叉），同样的数据，高度比二叉树低</p>
</li>
<li><p>和B树比，B+树采用双向链表串联所有的叶子节点，形成一个链表，这意味着当我们执行范围查询时，Mysql可以利用这个特性，沿着叶子节点前进,但是B树要通过中序遍历才能完成范围查询。而之所以Nosql数据库会使用B树索引，是因为他不需要像关系型数据库那样大量查询都是范围查询</p>
</li>
<li><p>B+树叶子节点存放数据，因此和B树比起来查询时间更稳定可预测</p>
<p>非叶子节点:索引+指针、叶子节点:索引+数据【地址】</p>
</li>
<li><p>B+树查询数据的磁盘IO更少。B+树内存节点并没有指向具体的数据,因此其内部节点相比B树更小,通常B+树更矮更胖,高度小查询磁盘的IO更少</p>
</li>
</ul>
<h3 id="其他结构问题："><a href="#其他结构问题：" class="headerlink" title="其他结构问题："></a>其他结构问题：</h3><ul>
<li><p>二叉搜索树</p>
<ul>
<li>不平衡：左边的子节点比父节点小，右边的子节点比父节点大，查询效率低</li>
</ul>
</li>
<li><p>平衡二叉树(AVL树)</p>
<ul>
<li>旋转耗时(左旋、右旋)</li>
</ul>
</li>
<li><p>红黑树</p>
<ul>
<li><p>树太高</p>
<p>在数据再内存中的情况，红黑树的表现是非常好的。但是对于数据在磁盘等辅助存储的设备情况中，红黑树并不适用,因为红黑树相对很高。当数据在磁盘中时,磁盘IO会成为性能瓶颈,设计的目标应该是降低IO次数,而树的高度越高,增删改查所需要的IO次数也会越多,会严重影响性能。</p>
</li>
</ul>
</li>
<li><p>跳表</p>
<ul>
<li><p>写入的效率</p>
<blockquote>
<p>跳表是独立插入，且根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好。</p>
</blockquote>
</li>
<li><ul>
<li>都是最底层存放数据，上层存索引。</li>
<li>写入数据时，都有可能会更新索引层，甚至增大层高。</li>
</ul>
</li>
<li><p>查询的效率</p>
</li>
<li><ul>
<li>跳表是链表结构，并且通过二分查找的方式去查找数据，索引分散在不同的数据页中，查找数据磁盘IO次数多</li>
</ul>
</li>
<li><p>结论</p>
</li>
<li><ul>
<li>跳表写入效率比B+Tree高。而读取效率主要受限于磁盘IO的效率，因此Redis的有序集合Zset就是基于链表实现的，因为Redis 是纯内存数据库,压根就不需要操作磁盘，B+Tree的低层级、仅3次IO的优势就体现不出来了</li>
</ul>
</li>
</ul>
</li>
<li><p>BTree:多路平衡搜索树</p>
<ul>
<li>InnoDB页默认大小16K，存储数据会造成树矮胖，查询更多更慢</li>
<li>B-Tree数据分散在每个节点，进行范围、顺序查找困难</li>
</ul>
</li>
<li><p>Hash</p>
<ul>
<li><p>通过散列算法，不支持范围查询</p>
</li>
<li><p>哈希索引没有办法利用索引完成排序</p>
</li>
<li><p>不能进行多字段查询</p>
</li>
<li><p>在有大量重复键值的情况下,哈希索引的效率也是很低的(哈希碰撞问题)</p>
</li>
</ul>
</li>
</ul>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/1629472050.png" alt="image"></p>
<h3 id="数据存储的形式"><a href="#数据存储的形式" class="headerlink" title="数据存储的形式"></a>数据存储的形式</h3><p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/cluster.png"></p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><h5 id="聚簇索引树"><a href="#聚簇索引树" class="headerlink" title="聚簇索引树"></a>聚簇索引树</h5><p><strong>又称主键索引树，除此之外，其他的索引树都是二级索引树</strong></p>
<ul>
<li>表中数据按索引的顺序来存储，叶子节点即存储了真实的数据行，就是聚簇索引，一张表只能有一个聚簇索引。</li>
<li>B+Tree的非叶节点存储键的值和指向子节点的指针。</li>
</ul>
<p><strong>叶子节点存储数据自身</strong></p>
<ul>
<li><p>数据页（根据页目录和最小最大记录通过二分查找数据）</p>
<p>所有Page直接存在双向链表</p>
<p>MySQL以【数据页】为单位进行读写，读取数据时会将一整页数据进行读取， 默认页大小是【16KB】</p>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/09d41fad701d3fe1911f1e3cc07f0cbfaf0667210b13381a81e666fe4e15e5f5.png" alt="image"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>文件头 <code>File Header</code></td>
<td>表示页的信息， 包含两个指针，分别指向上一页和下一页</td>
</tr>
<tr>
<td>页头 <code>Page Header</code></td>
<td>表示页的状态信息</td>
</tr>
<tr>
<td>最小和最大记录 <code>Infimum + supremum</code></td>
<td>两个虚拟的伪记录，分别表示页中的最小记录和最大记录</td>
</tr>
<tr>
<td>用户记录 <code>User Records</code></td>
<td>存储的记录内容</td>
</tr>
<tr>
<td>空闲空间 <code>Free Space</code></td>
<td>页中还没被使用的空间</td>
</tr>
<tr>
<td>页目录 <code>Page Directory</code></td>
<td>存储用户记录的相对位置，对记录起到索引作用</td>
</tr>
<tr>
<td>文件尾 <code>File Tailer</code></td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<p><strong>页目录</strong></p>
<p>创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/de316df6d2b621efef0de6fd923b6415e50e3c9f2674036dc1805ec9ae1914ff.png" alt="image"></p>
</li>
</ul>
<h5 id="二级索引树-辅助索引"><a href="#二级索引树-辅助索引" class="headerlink" title="二级索引树(辅助索引)"></a>二级索引树(辅助索引)</h5><ul>
<li>辅助索引相对较慢<ul>
<li>辅助索引上的<code>叶子节点</code>内容只存放**<code>主键ID和索引值</code>**，不是实际数据，需要再次通过主键索引查询真实数据（即需要有一次回表查询），因此可以通过覆盖索引来优化回表查询</li>
</ul>
</li>
<li>二级索引MVCC的 Read View的数据可见性通过Page Header 进行判断的<ul>
<li>如果当前语句关联的read_view的 up_limit_id &gt; MAX_TRX_ID，说明在创建read_view时最后一次更新二级索引的事务已经结束，也就是说二级索引里的所有记录对于当前查询都是可见的，此时可以直接根据二级索引的deleted flag来确定记录是否应该被返回。</li>
<li>二级索引的MVCC可见性判断在MAX_TRX_ID失效的情况下需要依赖聚簇索引才能完成。</li>
</ul>
</li>
<li>应尽量减少辅助索引<ul>
<li>所有索引问题在辅助索引上会出现，如中间数据插入时的分裂，大量删除时的合并，但主键索引可以通过顺序插入与逻辑删除避免，辅助索引无法避免此类问题，且当建立多个辅助索引时，会生成多个二级索引树，此时会导致同时分裂&#x2F;合并</li>
<li>非必要数据（如商品名称查询、统计区间查询）使用全文索引或数据仓库</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/Secondary_Index.png" alt="Secondary_Index"></p>
<h5 id="聚簇索引与辅助索引对比"><a href="#聚簇索引与辅助索引对比" class="headerlink" title="聚簇索引与辅助索引对比"></a>聚簇索引与辅助索引对比</h5><ul>
<li><p>一个表只能有一个聚簇索引,但可以存在多个二级索引</p>
</li>
<li><p>聚簇索引存在两种节点</p>
<ul>
<li><p>叶子节点</p>
<p>存储完整数据，用于覆盖索引查询。如果使用主键索引查询，它仍然会指向数据层再返回数据。其他二级索引查询到Primary Key后，会使用聚簇索引叶子节点查询Page Data 指针，去Data Block 查询Row Data</p>
</li>
<li><p>非叶子节点</p>
<p>存储主键值和数据页指针，一般用于类似于范围查询，由于指针结构所以查询效率高。</p>
</li>
</ul>
</li>
<li><p>辅助索引存在两种节点</p>
<ul>
<li><p>叶子节点</p>
<p>存储<code>索引列</code>和对应<code>主键</code>，如果只需要主键，可以直接返回数据，如果需要额外数据，则将主键作为主键索引的查询值，进入Index Block的Clustered Index中的Clustered Leaf Node查询获取数据页指针，再向Data Block 查询数据</p>
</li>
<li><p>非叶子节点</p>
<p>存储<code>索引列</code>和<code>数据页指针</code>。这个指针可能指向下一个非叶子节点，也可能指向叶子节点，但需要递归直到查询到叶子节点，获取主键值，再根据需求进行下一次查询</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/LN2NLF.png" alt="LN2NLF"></p>
<h4 id="MyIASM"><a href="#MyIASM" class="headerlink" title="MyIASM"></a>MyIASM</h4><h5 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h5><p><strong>存储的是数据的物理地址</strong></p>
<p>特点:不支持事务、不支持外键约束</p>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/MyISAM.png"></p>
<h5 id="二级索引树"><a href="#二级索引树" class="headerlink" title="二级索引树"></a>二级索引树</h5><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复</p>
<p><img src="/2022/06/30/MySQL-%E7%B4%A2%E5%BC%95/MyISAM_Secondary_Key.png"></p>
<h2 id="索引顺序"><a href="#索引顺序" class="headerlink" title="索引顺序"></a>索引顺序</h2><h3 id="根据Primary-Key查询"><a href="#根据Primary-Key查询" class="headerlink" title="根据Primary Key查询"></a>根据Primary Key查询</h3><ul>
<li>进入Index Block Clustered Index部分，找到 Leaf Node，其中包含Primary Key和对应的Data Page Pointer。</li>
<li>向下查询到Data Block，根据Data Page Pointer找到数据页，再根据Primary Key Locate完整数据</li>
<li>如果Data Block查询不到，回到Index Block，查询Clustered Index的Leaf Node的数据并返回</li>
</ul>
<h3 id="根据Cover-Index查询"><a href="#根据Cover-Index查询" class="headerlink" title="根据Cover Index查询"></a>根据Cover Index查询</h3><ul>
<li>进入Index Block Clustered Index部分，找到 Leaf Node，它包含了主键和完整数据，直接返回</li>
</ul>
<h3 id="根据索引值查询"><a href="#根据索引值查询" class="headerlink" title="根据索引值查询"></a>根据索引值查询</h3><ul>
<li>进入Index Block non-Clustered Index部分，找到Leaf Node， 它包含了索引值对应的内容</li>
<li>如果是只需要内容，则直接返回</li>
<li>如果需要其他数据，根据数据再在Index Block部分查找Clustered Index的Leaf Node，再次向Data Block查询</li>
</ul>
<h2 id="B-Tree索引数据写入"><a href="#B-Tree索引数据写入" class="headerlink" title="B+Tree索引数据写入"></a>B+Tree索引数据写入</h2><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><ul>
<li>优先写入Buffer Pool</li>
</ul>
<h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><ul>
<li>写入Buffer Pool同时，写入Redo Log，防止宕机导致数据丢失</li>
</ul>
<h3 id="Data-Block"><a href="#Data-Block" class="headerlink" title="Data Block"></a>Data Block</h3><ul>
<li>写入Redo Log 后，将数据写入Data Block，此时会生成主键和数据页指针</li>
</ul>
<h3 id="Clustered-Index-Leaf-Nodes"><a href="#Clustered-Index-Leaf-Nodes" class="headerlink" title="Clustered Index Leaf Nodes"></a>Clustered Index Leaf Nodes</h3><h4 id="Leaf-Node"><a href="#Leaf-Node" class="headerlink" title="Leaf Node"></a>Leaf Node</h4><ul>
<li>根据生成的主键、数据页指针和完整Row Data，生成聚簇索引的叶子节点，包含主键，完整数据，数据页指针。</li>
<li>除了覆盖索引会直接使用叶子节点完整数据直接返回，剩下的非范围索引都会通过该叶子节点向Data Block查找Full Row Data进行数据返回</li>
</ul>
<h4 id="non-Leaf-Node"><a href="#non-Leaf-Node" class="headerlink" title="non-Leaf Node"></a>non-Leaf Node</h4><ul>
<li>根据生成的主键和数据页指针，生成聚簇索引非叶子节点，用于Range Query</li>
</ul>
<h3 id="non-Clustered-Index"><a href="#non-Clustered-Index" class="headerlink" title="non-Clustered Index"></a>non-Clustered Index</h3><h4 id="Leaf-Nodes"><a href="#Leaf-Nodes" class="headerlink" title="Leaf Nodes"></a>Leaf Nodes</h4><ul>
<li>如果此时配置了数据库的Secondary Index，将索引列和主键生成到非聚簇索引的叶子节点</li>
</ul>
<h4 id="non-Leaf-Nodes"><a href="#non-Leaf-Nodes" class="headerlink" title="non-Leaf Nodes"></a>non-Leaf Nodes</h4><ul>
<li>存储的也是二级索引信息，但是是索引值和下一个节点指针，用于在Index Block中查找对应的Leaf Node，获取Primary Key后在聚簇索引叶子节点获取对应数据页指针，向Data Block 查找数据</li>
</ul>
<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><ul>
<li>写入Data Block之后，可能在成功写入Index Block之前，出现高并发查询，此时查询的是Redo Log的数据。它们通过MVCC等方式保证一致性</li>
</ul>
<h2 id="索引分析-EXPLAIN"><a href="#索引分析-EXPLAIN" class="headerlink" title="索引分析-EXPLAIN"></a>索引分析-EXPLAIN</h2><ul>
<li><p>id</p>
<p>「选择标识符」：在一个查询语句中每个【SELECT】关键字都对应一个唯一的 id。两种例外的情况：</p>
<ul>
<li><p><strong>「id相同」</strong>优化器对子查询做了<strong>「半连接（semi-jion）优化」</strong>时，两个查询的 id 是一样的</p>
</li>
<li><p><strong>「id为null」</strong></p>
<p>因为<strong>「union会对结果去重，内部创建了一个 &lt;union1,2&gt; 名字的临时表，把查询 1 和查询 2 的结果集都合并到这个临时表中，利用唯一键进行去重，这种情况下查询 id 就为 NULL」</strong>。</p>
</li>
</ul>
</li>
<li><p>select_type</p>
<table>
<thead>
<tr>
<th align="left">查询的类型</th>
<th align="left">类型含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIMPLE</td>
<td align="left">简单的select查询，不包含子查询或union查询，是最常见的。</td>
</tr>
<tr>
<td align="left">PRIMARY</td>
<td align="left">若查询中包含有子查询，最外层查询会别标记为PRIMARY</td>
</tr>
<tr>
<td align="left">UNION</td>
<td align="left">若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
<tr>
<td align="left">SUBQUERY</td>
<td align="left">在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td align="left">DERIVED</td>
<td align="left">在FROM列表中包含的子查询被标记为DERIVED(衍生);MySQL会递归执行这些子查询, 把结果放在临时表里。</td>
</tr>
<tr>
<td align="left">UNION RESULT</td>
<td align="left">从UNION表获取结果的SELECT</td>
</tr>
<tr>
<td align="left">DEPENDENT SUBQUERY</td>
<td align="left">在SELECT或WHERE列表中包含了子查询,子查询基于外层</td>
</tr>
<tr>
<td align="left">UNCACHEABLE SUBQUREY</td>
<td align="left">无法被缓存的子查询</td>
</tr>
</tbody></table>
</li>
<li><p>type</p>
<ul>
<li>All &lt; Index &lt; range &lt; ref &lt; ref_eq &lt; const &lt; system<ul>
<li>ALL：表示全表扫描，性能最差。</li>
<li>index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。</li>
<li>range：表示使用索引范围查询。使用&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、in等等。</li>
<li>ref：表示使用非唯一索引进行单值查询。</li>
<li>eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一 行结果。</li>
<li>const：表示使用主键或唯一索引做等值查询，常量查询。</li>
<li>system：表示不用访问表，速度最快。</li>
</ul>
</li>
</ul>
</li>
<li><p>possible_keys</p>
<p>表示在某个查询语句中，对某个表执行单表查询时<strong>「可能用到的索引列表」</strong></p>
</li>
<li><p>key</p>
<ul>
<li>使用到的索引</li>
</ul>
</li>
<li><p>key_len</p>
<p>  表示查询使用索引的字节数量。可以判断是否全部使用了组合索引</p>
<ul>
<li><p>索引的长度，越小越好</p>
</li>
<li><p>字符长度*字节数+类型+是否允许为空<br> 如：varchar(50) &#x3D; 3 * 50 + 2 + 1<br> int(255) 不允许为空，长度为 4 + 0 不与编码、长度相关</p>
<ul>
<li>int 类型4字节，char和varchar的长度是值字符数，一个字符gbk编码为2字节，utf-8编码为3字节 ​</li>
<li>int + 0, char + 0, varchar + 2</li>
<li>允许为空 1字节，不为空0字节</li>
</ul>
</li>
</ul>
</li>
<li><p>ref</p>
<p>当使用索引列等值匹配的条件去执行查询时，ref 列展示<strong>「与索引列作等值匹配的对象」</strong>。</p>
</li>
<li><p>rows</p>
<p>预估扫描的行数</p>
<ul>
<li>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，rows 列就代表预计需要扫描的行数；</li>
<li>如果使用索引来执行查询时，rows 列就代表预计扫描的索引记录行数。</li>
</ul>
</li>
<li><p>filtered</p>
<p>按表条件过滤的行百分比</p>
<ul>
<li>如果是全表扫描，filtered 值代表满足 where 条件的行数占表总行数的百分比</li>
<li>如果是使用索引来执行查询，filtered 值代表从索引上取得数据后，满足其他过滤条件的数据行数的占比。</li>
</ul>
</li>
<li><p>Extra</p>
<ul>
<li><p>Using where</p>
<p>表示查询需要通过索引回表查询数据。</p>
</li>
<li><p>Using index覆盖索引</p>
<p>表示查询需要通过索引，索引就可以满足所需数据。</p>
</li>
<li><p>Using Index Condition 索引下推</p>
</li>
<li><p>Using filesort</p>
<p>表示查询出来的结果需要额外排序，</p>
</li>
<li><p>Using temprorary</p>
<p>查询使用到了临时表，一般出现于去重、分组等操作</p>
</li>
</ul>
</li>
</ul>
<h2 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h2><ul>
<li><p>mysql联合索引为什么遵循最左匹配原则</p>
<p>mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段进行排序。第一个字段是有序的，第二个字段没法保证有序。</p>
</li>
<li><p>数据库表创建（a,b,c）的联合索引，则必须保证where条件里最左边是a字段才能生效</p>
<ul>
<li>索引生效 (索引下推,索引截断)，如：<br>where a &#x3D; 0<br>where a &#x3D; 0 and  b &#x3D; 0<br>where a &#x3D; 0 and c &#x3D; 0<br>where a &#x3D; 0 and c &#x3D; 0 and b &#x3D; 0</li>
<li>但 select * from t where b &#x3D; 0 或 where c &#x3D; 0 也会走索引 (覆盖索引)<ul>
<li>因为表中没有非索引字段，所以 select * 相当于 select id,a,b,c，然后这个查询的内容和条件 都在联合索引树里，因为联合索引树的叶子节点包含「索引列+主键」，所以查联合索引树就能查到全部结果了，这个就是覆盖索引。</li>
<li>如果加了一个非索引字段后，则会进行全表扫描，因为不符合最左匹配，且在索引树上找不到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul>
<li><p>要查询的字段值都能出现在二级索引树上</p>
<p>使用索引列覆盖要查询的字段，如果查询条件使用的是普通索引(或是联合索引的最左原则字段)，查询结果是索引的列或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据</p>
</li>
</ul>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><ul>
<li>用的比较少了一般用ES</li>
</ul>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><ul>
<li>仅提高查询效率</li>
</ul>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><ul>
<li>多个字段组成索引</li>
</ul>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><ul>
<li>唯一约束+提高查询效率</li>
</ul>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><ul>
<li>主键约束+提高查询效率</li>
</ul>
<h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><ul>
<li>当Page被MySQL Load进入内存后，会立即产生Hash索引，内容为[主键，地址]，因此当查询结果已经在内存中存在时，可以立即查询到Row数据</li>
<li>在内存中的数据一定在Hash索引中，不在内存中的数据一定不在Hash索引中</li>
<li>根据key-value 效率非常高</li>
</ul>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><ul>
<li>利用数据前几个字符的索引</li>
</ul>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><ul>
<li>遍历索引时，会先对索引包含的字段进行判断，直接过滤掉不满足条件的记录，减少回表。<br>如：where a &#x3D; 0 and c &#x3D; 0，首先会索引截断，然后截断的字段c会被下推到存储引擎层进行条件判断，因为 c字段值是在联合索引 (a,b,c)中，然后过滤出符合条件的数据返回Server层</li>
</ul>
<h2 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h2><ul>
<li>like子句<ul>
<li>%xxx 或 %xxx% 【可能】会导致索引失效</li>
<li>xxx% 不会导致索引失效<br>​索引树存放的数据是有顺序的，知道前面的，可以在索引树上扫描进行比较。 如果前缀不知道，如 % xxx，前缀不知道，要查的数据可能是Axxx，Bxxx, 就不知道从索引树的哪个节点开始进行扫描，只能全表扫描</li>
</ul>
</li>
<li>调用内置函数<br>​索引存储的为数据原始值而非通过函数计算后的数据，因此不会走索引​</li>
<li>不满足最左匹配</li>
<li>索引隐式转换<br>​MySQL遇到数字和字符串比较时，会自动将【字符串转换为数字】， 如假设字段a为varchar类型，执行 select * from t where a &#x3D; 1000时， MySQL会进行类型转换，实际相当于执行 select * from t where CAST(a as signed int) &#x3D; 1000, 相当于对索引字段使用了函数。<br>但是反过来，假设a是数字类型， 执行slect * from t where a &#x3D; “10000”,也会进行类型转换 是可以【走索引】的，相当于执行 select * from t where a &#x3D; CAST(“10000” as signed int)<br>因此这也可以作为一种优化手段</li>
<li>not in , !&#x3D;</li>
<li>OR<ul>
<li>wher中包含不是索引的列就会导致索引失效</li>
</ul>
</li>
</ul>
<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><ul>
<li><p>性能排序(InnoDB)：</p>
<p>count(*) &#x3D; count(1) &gt; count(主键字段) &gt; count (字段)</p>
<ul>
<li>MySQL会将count(*)转换为count(0) </li>
<li>MySQL针对count(*)和count(1)会有一个优化，会优先选择key_len最小的二级索引进行扫描</li>
</ul>
</li>
<li><p>通过count函数统计有多少个记录时，MySQL的server层会维护一个名叫count的变量。<br>server层会循环向InnoDB读取一条记录，如果count函数指定的参数不为NULL，那么就会将变量的count加1，直至符合条件的记录全部被读取完。最后将count变量值发送给客户端<br>​如果表里只有主键索引，没有二级索引时，那么InnoDB循环遍历聚簇索引，将读取到的记录返回sever层，然后读取记录中的id值，就会判断id是否为NULL，不为NULL，就将count变量加1。<br>如果有二级索引则会遍历二级索引树，因为二级索引存储的是主键以及索引字段，数据比聚簇索引少，遍历二级索引的成本比遍历聚簇索引小</p>
</li>
<li><p>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据</p>
</li>
</ul>
<h2 id="索引与排序"><a href="#索引与排序" class="headerlink" title="索引与排序"></a>索引与排序</h2><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h3><p>MySQL查询支持filesort和index两种方式的排序，</p>
<ul>
<li>filesort是先把结果查出，然后在缓存或磁盘进行排序 操作，效率较低。</li>
<li>index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>filesort有两种排序算法：双路排序和单路排序。</p>
<ul>
<li>双路排序：需要两次磁盘扫描读取，得到最终数据。第一次将排序字段读取出来，然后排序；第二 次去读取其他字段数据。</li>
<li>单路排序：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。</li>
<li>如果查询数据超出缓存 sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。</li>
<li>解决方案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。</li>
</ul>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a target="_blank" rel="noopener" href="https://rumenz.com/rumenbiji/mysql-index.html">https://rumenz.com/rumenbiji/mysql-index.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/394608">https://www.modb.pro/db/394608</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/400446">https://www.modb.pro/db/400446</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1541265">https://cloud.tencent.com/developer/article/1541265</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html">https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041290817">https://segmentfault.com/a/1190000041290817</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kerrycode/p/9909093.html">https://www.cnblogs.com/kerrycode/p/9909093.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/402451">https://www.modb.pro/db/402451</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/411170">https://www.modb.pro/db/411170</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1He4y177fa">https://www.bilibili.com/video/BV1He4y177fa</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/stevenczp/p/8018986.html">https://www.cnblogs.com/stevenczp/p/8018986.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46558851/article/details/115690558">https://blog.csdn.net/weixin_46558851/article/details/115690558</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@genchilu/a-brief-introduction-to-cluster-index-and-secondary-index-in-innodb-9b8874d4da6a">https://medium.com/@genchilu/a-brief-introduction-to-cluster-index-and-secondary-index-in-innodb-9b8874d4da6a</a></p>
<p><a target="_blank" rel="noopener" href="https://kyle.ai/blog/6439.html">https://kyle.ai/blog/6439.html</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/317532">https://bbs.huaweicloud.com/blogs/317532</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/30/Redis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="Redis-常见面试题">
      <i class="fa fa-chevron-left"></i> Redis-常见面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/30/MySQL-MVCC/" rel="next" title="MySQL-MVCC">
      MySQL-MVCC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">1.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91"><span class="nav-number">1.2.</span> <span class="nav-text">Mysql为什么使用B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%BD%8E%E3%80%81%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%98%AF%E9%93%BE%E8%A1%A8%E3%80%81%E6%9F%A5%E8%AF%A2%E7%A8%B3%E5%AE%9A"><span class="nav-number">1.2.1.</span> <span class="nav-text">关键点：高度低、叶子节点是链表、查询稳定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">1.2.2.</span> <span class="nav-text">其他结构问题：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree"><span class="nav-number">1.3.</span> <span class="nav-text">B+ Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据存储的形式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">InnoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%A0%91"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">聚簇索引树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%A0%91-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.1.1.2.</span> <span class="nav-text">二级索引树(辅助索引)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94"><span class="nav-number">1.3.1.1.3.</span> <span class="nav-text">聚簇索引与辅助索引对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyIASM"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">MyIASM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">非聚集索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%A0%91"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">二级索引树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.4.</span> <span class="nav-text">索引顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AEPrimary-Key%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.4.1.</span> <span class="nav-text">根据Primary Key查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AECover-Index%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">根据Cover Index查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.4.3.</span> <span class="nav-text">根据索引值查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5"><span class="nav-number">1.5.</span> <span class="nav-text">B+Tree索引数据写入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-Pool"><span class="nav-number">1.5.1.</span> <span class="nav-text">Buffer Pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redo-Log"><span class="nav-number">1.5.2.</span> <span class="nav-text">Redo Log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Block"><span class="nav-number">1.5.3.</span> <span class="nav-text">Data Block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clustered-Index-Leaf-Nodes"><span class="nav-number">1.5.4.</span> <span class="nav-text">Clustered Index Leaf Nodes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leaf-Node"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">Leaf Node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#non-Leaf-Node"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">non-Leaf Node</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#non-Clustered-Index"><span class="nav-number">1.5.5.</span> <span class="nav-text">non-Clustered Index</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leaf-Nodes"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">Leaf Nodes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#non-Leaf-Nodes"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">non-Leaf Nodes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.6.</span> <span class="nav-text">可能出现的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90-EXPLAIN"><span class="nav-number">1.6.</span> <span class="nav-text">索引分析-EXPLAIN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">1.7.</span> <span class="nav-text">最左匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">1.8.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.9.</span> <span class="nav-text">全文索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">1.10.</span> <span class="nav-text">普通索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">1.11.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">1.12.</span> <span class="nav-text">唯一索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">1.13.</span> <span class="nav-text">主键索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="nav-number">1.14.</span> <span class="nav-text">Hash索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">1.15.</span> <span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-number">1.16.</span> <span class="nav-text">索引下推</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">1.17.</span> <span class="nav-text">失效场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#count"><span class="nav-number">1.18.</span> <span class="nav-text">count</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%92%E5%BA%8F"><span class="nav-number">1.19.</span> <span class="nav-text">索引与排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="nav-number">1.19.1.</span> <span class="nav-text">排序方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.19.2.</span> <span class="nav-text">排序算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A5%E6%BA%90"><span class="nav-number">2.</span> <span class="nav-text">来源</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '713a28a3ad93f2aa2323',
      clientSecret: '39dc40bb09b422ca4c99a748b5984a4d205e91be',
      repo        : 'swzxsyh.github.io',
      owner       : 'swzxsyh',
      admin       : ['swzxsyh'],
      id          : 'c79aeee06eaaf3c9ee48d29e397b8e06',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
