<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一.Spring概述1.1 Spring是什么Spring是分层的 Java SE&#x2F;EE应用 full-stack(全栈) 轻量级开源框架。Spring的核心是 IOC(Inverse Of Control:控制反转)和 AOP(Aspect Oriented Programming:面向切面编程) Spring一个全栈应用框架, 提供了表现层 Spring MVC 和持久层 Sprin">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 初识 &amp; 相关配置">
<meta property="og:url" content="https://swzxsyh.github.io/2020/05/28/Spring-%E5%88%9D%E8%AF%86-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:description" content="一.Spring概述1.1 Spring是什么Spring是分层的 Java SE&#x2F;EE应用 full-stack(全栈) 轻量级开源框架。Spring的核心是 IOC(Inverse Of Control:控制反转)和 AOP(Aspect Oriented Programming:面向切面编程) Spring一个全栈应用框架, 提供了表现层 Spring MVC 和持久层 Sprin">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-27T17:41:27.000Z">
<meta property="article:modified_time" content="2022-08-09T20:40:38.170Z">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swzxsyh.github.io/2020/05/28/Spring-%E5%88%9D%E8%AF%86-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring 初识 & 相关配置 | swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/28/Spring-%E5%88%9D%E8%AF%86-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring 初识 & 相关配置
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-28 01:41:27" itemprop="dateCreated datePublished" datetime="2020-05-28T01:41:27+08:00">2020-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一.Spring概述<br>1.1 Spring是什么<br>Spring是分层的 Java SE&#x2F;EE应用 full-stack(全栈) 轻量级开源框架。<br>Spring的核心是 IOC(Inverse Of Control:控制反转)和 AOP(Aspect Oriented Programming:面向切面编程)</p>
<p>Spring一个全栈应用框架, 提供了表现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众 多应用技术</p>
<p>Spring还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框 架</p>
<p>Spring官网:<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a></p>
<p>1.2 Spring发展历程<br>EJB</p>
<p>1997 年，IBM提出了EJB 的思想</p>
<p>1998 年，SUN制定开发标准规范 EJB1.0</p>
<p>1999 年，EJB1.1 发布</p>
<p>2001 年，EJB2.0 发布</p>
<p>2003 年，EJB2.1 发布</p>
<p>2006 年，EJB3.0 发布</p>
<p>Spring<br>Rod Johnson 2002年编著《Expert one on one J2EE design and development》指出了JavaEE和EJB组件框架中的存在的一些主要缺陷;提出普通java类依赖注入更为简单的解决方案。</p>
<p>2004年编著《Expert one-on-one J2EE Development without EJB》 阐述了JavaEE开发时不使用EJB的解决方式(Spring 雏形) 同年4月spring1.0诞生</p>
<p>2006年10月，发布 Spring2.0</p>
<p>2009年12月，发布 Spring3.0</p>
<p>2013年12月，发布 Spring4.0</p>
<p>2017年9月， 发布最新 Spring5.0 通用版(GA)</p>
<p>1.3 Spring优势<br>方便解耦，简化开发<br>通过Spring提供的 IOC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。</p>
<p>AOP编程的支持</p>
<p>通过Spring的AOP功能，方便进行面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
<p>声明式事务的支持</p>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
<p>方便程序的测试</p>
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<p>方便集成各种优秀框架</p>
<p>Spring对各种优秀框架(Struts、Hibernate、Hessian、Quartz等)的支持。</p>
<p>降低JavaEE API的使用难度</p>
<p>Spring对JavaEEAPI(如JDBC、JavaMail、RPC等)进行了薄薄的封装层，使这些 API 的使用难度大为降低。</p>
<p>1.4 Spring体系结构<br>核心容器（Core Container）<br>数据访问&#x2F;集成（Data Access&#x2F;Integration）层<br>Web层<br>AOP（Aspect Oriented Programming）模块<br>植入（Instrumentation）模块<br>消息传输（Messaging）<br>测试（Test）模块</p>
<p>二.初识IOC<br>2.1 介绍<br>控制反转(Inverse Of Control) 是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。</p>
<p>控制:在java中指的是对象的控制权限(创建、销毁)</p>
<p>反转:指的是对象控制权由原来 由开发者在类中手动控制 反转到 由Spring容器控制</p>
<p>2.2 环境搭建<br>IDEA new empty project &#x3D;&#x3D;&gt;设置Project Name、JDK Version、Encodings&#x3D;&#x3D;&gt;添加maven module&#x3D;&#x3D;&gt;导入Jar包</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</p>
<!--依赖管理--> 
<dependencies>
  <!--dom4j-->
  <dependency> 
    <groupId>dom4j</groupId> 
    <artifactId>dom4j</artifactId> 
    <version>1.6.1</version>
  </dependency>
  <!--xpath-->
  <dependency> 
    <groupId>jaxen</groupId> 
    <artifactId>jaxen</artifactId> 
    <version>1.1.6</version>
  </dependency>
  <!--junit-->
  <dependency> 
    <groupId>junit</groupId> 
    <artifactId>junit</artifactId> 
    <version>4.12</version>
  </dependency>
</dependencies>
2.3 版本一:原始版本
编写UserDao接口和实现类

<p>1<br>2<br>3<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }<br>}<br>编写UserService接口和实现类</p>
<p>1<br>2<br>3<br>public interface UserService {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        userDao.save();<br>    }<br>}<br>编写UserTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class UserTest{<br>  &#x2F;&#x2F;调用Service实现保存<br>  @Test<br>  public void testUser01() throws Exception{<br>    UserServiceImpl userService &#x3D; new UserServiceImpl();<br>    userService.save();<br>  }<br>}<br>问题</p>
<p>Service层和dao层代码产生耦合——松耦原则：编译期解耦，运行期可以耦合<br>每次调用save方法时，都会创建一个新的dao对象<br>2.4 版本二:工厂解耦<br>编写beans.xml</p>
<p>1<br>2<br>3<br><beans><br>  <bean id="userDao" class="com.test.dao.impl.UserDaoImpl"></bean><br></beans><br>编写BeanFactory</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>public class BeanFactory {</p>
<pre><code>public static Object getBean(String id) &#123;
    Object object = null;

    try &#123;
        // 1.通过类加载器读取 beans.xml
        InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;);

        // 2.创建dom4j核心解析器对象
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(in);

        // 3.编写xpath表达式
        String xpath = &quot;//bean[@id=&#39;&quot; + id + &quot;&#39;]&quot;;

        // 4.获取指定id的标签对象
        Element element = (Element) document.selectSingleNode(xpath);

        // 5.获取全限定名
        String className = element.attributeValue(&quot;class&quot;);

        // 6.通过反射创建对象实例
        object = Class.forName(className).newInstance();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    // 7.返回对象实例
    return object;
&#125;
</code></pre>
<p>}<br>修改UserServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>&#x2F;&#x2F;        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        UserDao userDao &#x3D; (UserDao) BeanFactory.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}<br>问题</p>
<p>每次调用save方法，都会创建一个新的dao对象，工厂每次调用getBean方法都会创建一个新的对象实例，浪费内存</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>&#x2F;&#x2F;        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        UserDao userDao &#x3D; (UserDao) BeanFactory.getBean(“userDao”);<br>        UserDao userDao1 &#x3D; (UserDao) BeanFactory.getBean(“userDao”);<br>        userDao.save();<br>        userDao1.save();<br>    }<br>}</p>
<p>&#x2F;*<br>com.test.dao.impl.UserDaoImpl@516be40f<br>com.test.dao.impl.UserDaoImpl@3c0a50da<br>UserDao Saved!<br>UserDao Saved!<br>*&#x2F;<br>2.5 版本三:工厂优化<br>修改BeanFactory</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>public class BeanFactory {</p>
<pre><code>// 声明存储对象的容器(map集合)
private static Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;();

// 静态代码块，初始化ioc容器
static &#123;
    String id = null;
    String className = null;
    Object object = null;

    try &#123;
        // 1.通过类加载器读取 beans.xml
        InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;);

        // 2.创建dom4j核心解析器对象
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(in);

        // 3.编写xpath表达式
        String xpath = &quot;//bean&quot;;

        // 4.获取所有bean标签对象
        List&lt;Element&gt; list = document.selectNodes(xpath);

        // 5.遍历集合，创建对象实例，设置到ioc容器中
        for (Element element : list) &#123;
            id = element.attributeValue(&quot;id&quot;);
            className = element.attributeValue(&quot;class&quot;);
            object = Class.forName(className).newInstance();

            // 设置到map集合
            ioc.put(id, object);
        &#125;
    &#125; catch (
            Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

// 7.从ioc容器获取指定id的对象实例
public static Object getBean(String id) &#123;
    return ioc.get(id);
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;*<br>com.test.dao.impl.UserDaoImpl@4ba2ca36<br>com.test.dao.impl.UserDaoImpl@4ba2ca36<br>UserDao Saved!<br>UserDao Saved!<br>*&#x2F;<br>2.6 小结<br>对象的创建由原来的 使用 new关键字 在类中主动创建 变成了 从工厂中获取, 而对象的创建过程由工厂 内部来实现, 而这个工厂就是 Spring的IOC容器。</p>
<p>也就是以后我们的对象不再自己创建,而是直接向 Spring要, 这种思想就是IOC</p>
<p>目的：松耦合</p>
<p>三.Spring快速入门<br>3.1 需求<br>UserServiceImpl		UserDaoImpl<br>UserDao userDao &#x3D; Spring客户端.getBean(id标识)		CURD方法<br>⬆⬇Spring框架		⬆⬇<br>读取xml配置文件<br>根据id标识获得Bean权限定名<br>通过反射创建Bean对象<br>返回对象	➡<br>⬅	xml配置文件<br>id标识&#x3D;com.test.dao.UserDaoImpl<br>3.2 代码实现<br>创建maven的java模块</p>
<p>IDEA new moudle&#x3D;&#x3D;&gt;MVN&#x3D;&#x3D;&gt;导入依赖管理Spring、Junit坐标，JDK1.8插件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br><?xml version="1.0" encoding="UTF-8"?><br><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelVersion>4.0.0</modelVersion></project></p>
<pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;
&lt;artifactId&gt;Spring_online_Day01_ioc_xml&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;!--依赖管理--&gt;
&lt;dependencies&gt;
    &lt;!--spring的核心坐标--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

编写UserDao接口和实现类(同上)

<p>1<br>2<br>3<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }<br>}<br>创建spring的核心配置文件，导入约束</p>
<p>官方推荐名称:applicationContext.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>

写bean标签(id、class)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;!--    将userDao的对象创建权交给ioc容器--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre>

测试(模拟service层)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class UserTest {<br>    &#x2F;&#x2F; spring的快速入门<br>    @Test<br>    public void testUser() throws Exception{<br>        &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>        ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        &#x2F;&#x2F; 2.获取指定id的对象实例<br>        UserDao userDao &#x3D; (UserDao) app.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}<br>四.Spring相关API<br>4.1 二个接口(创建的对象均为单例)<br>BeanFactory</p>
<p>介绍</p>
<p>IOC容器的顶级接口，定义了IOC的最基础的功能, 但功能比较简单,一般面向Spring自身使用</p>
<p>特点(懒汉设计)</p>
<p>在第一次使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化[用的时候再创建]</p>
<p>ApplicationContext</p>
<p>介绍</p>
<p>这是在BeanFactory基础上衍生出的接口,它扩展了BeanFactory的功能,一般面向程序员使用</p>
<p>特点(恶汉设计)</p>
<p>在容器启动时，一次性创建并加载了所有的Bean [初始化的时候全创建好]</p>
<p>4.2 三个实现类<br>ClassPathXmlApplicationContext</p>
<p>功能：读取类路径(classpath)下的xml配置文件</p>
<p>FileSystemXmlApplicationContext</p>
<p>功能：读取本地磁盘下的xml配置文件</p>
<p>AnnotationConfigApplicationContext</p>
<p>功能：读取java配置类加载配置</p>
<p>4.3 一个方法<br>public Object getBean(String name) throws BeansException;</p>
<p>功能：通过指定id获取对象的实例，需要手动强转</p>
<p>public <T> T getBean(Class<T> requiredType);</T></T></p>
<p>功能：通过指定类型获取对象的实例，不需要强转</p>
<p>public <T> T getBean(String name, Class<T> requiredType);</T></T></p>
<p>功能：通过指定id和类型获取对象的实例</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>&#x2F;&#x2F; getBean方法介绍<br>&#x2F;&#x2F; 方式一: 通过指定id获取对象的实例，需要手动强转<br>@Test<br>public void testUserByID() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>  &#x2F;&#x2F; 2.获取指定id的对象实例<br>  UserDao userDao &#x3D; (UserDao) app.getBean(“userDao”);<br>  userDao.save();<br>}</p>
<p>&#x2F;&#x2F; getBean方法介绍<br>&#x2F;&#x2F; 方式二:通过指定(接口)类型获取对象的实例，不需要强转<br>&#x2F;&#x2F;缺点:如果同一个接口类型下有多个对象实例，会报错<br>@Test<br>public void testUserByInstance() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  UserDao userDao &#x3D; app.getBean(UserDao.class);<br>  userDao.save();<br>}</p>
<p>&#x2F;&#x2F; getBean方法介绍<br>&#x2F;&#x2F; 方式三:通过指定id和类型获取对象的实例<br>@Test<br>public void testUserBySpecifyIdOfType() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  UserDao userDao &#x3D; app.getBean(“userDao”, UserDao.class);<br>  userDao.save();<br>}</p>
<p>4.4 知识小结<br>1<br>2<br>3<br>ApplicationContext app &#x3D; new ClasspathXmlApplicationContext(“xml文件”);<br>app.getBean(“id”);<br>app.getBean(Class);<br>五.Spring配置文件<br>5.1 Bean标签基本配置<br>基本配置</p>
<p>1<br><bean id="userDao" class="cn.itcast.dao.impl.UserDaoImpl"></bean><br>基本属性	<br>id	在ioc容器的唯一标识<br>class	创建对象实例的全限定名<br>作用范围</p>
<p>scope属性:声明此对象的作用范围	何时创建	对象运行	何时销毁<br>singleton(单例对象)	ioc容器初始化时，创建对象	ioc容器在,对象在	ioc容器关闭时，销毁对象<br>prototype(多例对象)	在调用getBean()方法时，创建	一直使用就一直活着	当对象不再使用后，根据JVM GC机制垃圾回收<br>生命周期</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;!--    将userDao的对象创建权交给ioc容器--&gt;
</code></pre>
<p>  <bean id="userDao" class="com.test.dao.impl.UserDaoImpl" scope="singleton" init-method="MethodInit" destroy-method="MethodDestory"></bean><br><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }</p>
<p>  &#x2F;&#x2F;当创建时，init-method&#x3D;”MethodInit”<br>    private void MethodInit() {<br>        System.out.println(“Method Init Now”);<br>    }</p>
<p>  &#x2F;&#x2F;当销毁时，destroy-method&#x3D;”MethodDestory”<br>    private void MethodDestory() {<br>        System.out.println(“Method Die Now”);<br>    }<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>@Test<br>public void testUserDestory() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>  &#x2F;&#x2F; 2.获取指定id的对象实例<br>  UserDao userDao &#x3D; (UserDao) app.getBean(“userDao”);<br>  UserDao userDao1 &#x3D; (UserDao) app.getBean(“userDao”);</p>
<p>  System.out.println(userDao);<br>  System.out.println(userDao1);</p>
<p>  ((ClassPathXmlApplicationContext) app).close();<br>}</p>
<p>&#x2F;*<br>Method Init Now<br>com.test.dao.impl.UserDaoImpl@78e67e0a<br>com.test.dao.impl.UserDaoImpl@78e67e0a<br>Method Die Now<br>*&#x2F;<br>5.2 spring创建对象实例三种方式<br>无参构造方法实例化</p>
<p>在企业开发时，所有的类必须提供无参构造方法</p>
<p>1<br>2<br>public UserDaoImpl(String a)<br>  &#x2F;&#x2F;若未提供无参构造，则xml中class&#x3D;”com.test.dao.impl.UserDaoImpl” 会报错<br>工厂静态方法实例化</p>
<p>依赖的jar包中有个A类，A类中有个静态方法m1，m1方法的返回值是一个B对象。如果我们频繁 使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无 需调用A类中的m1方法，直接从IOC容器获得。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>&#x2F;&#x2F;工厂静态方法实例化对象<br>public class StaticFactoryBean {<br>    public static UserDao createUserDao(){<br>        return new UserDaoImpl();<br>    }</p>
<pre><code>// 传统方式，自己通过工厂获取对象
public static void main(String[] args) &#123;
    UserDao userDao = StaticFactoryBean.createUserDao();
&#125;
</code></pre>
<p>}<br>1<br>2</p>
<!--工厂静态方法实例化对象-->
<p><bean id="userDao" class="com.test.factory.StaticFactoryBean" factory-method="createUserDao"></bean><br>工厂普通方法实例化</p>
<p>依赖的jar包中有个A类，A类中有个普通方法m1，m1方法的返回值是一个B对象。如果我们频繁 使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无 需调用A类中的m1方法，直接从IOC容器获得。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>&#x2F;&#x2F;工厂普通方法实例化对象<br>public class DynamicFactoryBean {</p>
<p>  public UserDao createUserDao() {<br>    return new UserDaoImpl();<br>  }</p>
<p>  &#x2F;&#x2F; 传统方式，自己通过工厂获取对象<br>  public static void main(String[] args) {<br>    &#x2F;&#x2F; 1.创建工厂对象<br>    DynamicFactoryBean dynamicFactoryBean &#x3D; new DynamicFactoryBean();<br>    &#x2F;&#x2F; 2.创建UserDao对象<br>    UserDao userDao &#x3D; dynamicFactoryBean.createUserDao();<br>  }<br>}<br>1<br>2<br>3</p>
<!--工厂普通方法实例化对象-->
<p><bean id="dynamicFactoryBean" class="com.test.factory.DynamicFactoryBean"></bean><br><bean id="userDao" factory-bean="dynamicFactoryBean"></bean><br>5.3 Bean依赖注入<br>5.3.1 概述<br>依赖注入(Dependency Injection, DI) 它是 Spring 框架核心 IOC 的具体实现</p>
<p>其实就是给对象中的属性赋值的过程，通过spring完成依赖注入</p>
<p>UserServiceImpl	➡依赖	UserDaoImpl<br>private UserDao userDao<br>userDao.save()		<br>⬆service层需要调用dao层对象的实例，就要从Spring的ioc容器注入此实例，<br>⬆这个过程称为依赖注入		<br>Spring的配置文件		<br><bean id="”userDao”" class="”xxx”"><br><bean id="”userService”" class="”xxx”">		<br>5.3.2 环境搭建<br>IDEA new moudle&#x3D;&#x3D;&gt;MVN&#x3D;&#x3D;&gt;导入依赖管理Spring、Junit坐标，JDK1.8插件&#x3D;&#x3D;&gt;复制UserDao,UserService&#x3D;&#x3D;&gt;编写spring的核心配置文件</bean></bean></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br><build><br>    <plugins><br>        <plugin><br>            <groupId>org.apache.maven.plugins</groupId><br>            <artifactId>maven-compiler-plugin</artifactId><br>            <configuration><br>                <source>1.8<br>                <target>1.8</target><br>                <encoding>UTF-8</encoding><br>            </configuration><br>        </plugin><br>    </plugins><br></build></p>
<!--依赖管理-->
<dependencies>
    <!--spring的核心坐标-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
    <!--junit-->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <dependency>
        <groupId>dom4j</groupId>
        <artifactId>dom4j</artifactId>
        <version>1.6</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd">

<pre><code>&lt;!--    将userDao的对象创建权交给ioc容器--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;


&lt;!--    将userService交给ioc容器--&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
</beans>
5.4 Bean依赖注入方式
构造方法

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class UserServiceImpl implements UserService {</p>
<pre><code>private UserDao userDao;

public UserServiceImpl(UserDao userDao) &#123;
    this.userDao = userDao;
&#125;

@Override
public void save() &#123;
    userDao.save();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<!--
构造方法注入: <constructor-arg> 子标签
版本一:
    name:构造方法参数名称 
    value:简单数据类型(String、int、double...)
    ref:引用数据类型(从ioc容器中获取的对象) 
版本二:
    index:构造方法参数索引 
    type:该索引对应的java类型(全限定名) 
    value:简单数据类型(String、int、double...) 
    ref:引用数据类型(从ioc容器中获取的对象)
-->

<!--    将userService交给ioc容器-->
<bean id="userService" class="com.test.service.impl.UserServiceImpl">
  <constructor-arg name="userDao" ref="userDao"></constructor-arg>
</bean>
set方法(推荐使用 )

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class UserServiceImpl implements UserService {</p>
<pre><code>private UserDao userDao;
</code></pre>
<p>&#x2F;&#x2F;    public UserServiceImpl(UserDao userDao) {<br>&#x2F;&#x2F;        this.userDao &#x3D; userDao;<br>&#x2F;&#x2F;    }</p>
<pre><code>public void setUserDao(UserDao userDao) &#123;
    this.userDao = userDao;
&#125;

@Override
public void save() &#123;
    userDao.save();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<!--    将userDao的对象创建权交给ioc容器-->
<p><bean id="userDao" class="com.test.dao.impl.UserDaoImpl"></bean></p>
<!--

    set方法注入:<property> 子标签
        name:set方法的属性名 setUserDao() -> UserDao -> userDao
        value:简单数据类型(String、int、double...)
        ref:引用数据类型(从ioc容器中获取的对象)
        -->
<bean id="userService" class="com.test.service.impl.UserServiceImpl">
  <property name="userDao" ref="userDao"></property>
</bean>
P命名空间注入

<p>P命名空间注入底层(本质)使用的也是set方法注入，只是在上着的基础上进行简化</p>
<p>导入P命名空间约束</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"><br>使用P命名空间注完成注入(单一属性来简洁，但是若变量多，则不如第二种规范)</beans></p>
<p>1<br><bean id="userService" class="com.test.service.impl.UserServiceImpl" p:userdao-ref="userDao"></bean><br>5.5 Bean依赖注入的数据类型<br>简单数据类型</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>public class User {</p>
<pre><code>private Integer id;

private String username;

public void setId(Integer id) &#123;
    this.id = id;
&#125;

public void setUsername(String username) &#123;
    this.username = username;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5</p>
<!-- 注入简单数据类型 -->
<bean id="user" class="com.test.domain.User">
  <property name="id" value="1"></property>
  <property name="username" value="jack"></property>
</bean>
引用数据类型

<p>参考5.4 Bean依赖注入方式</p>
<p>集合数据类型</p>
<p>单列集合(list、set、array)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>public class UserDaoImpl implements UserDao {</p>
<pre><code>private List&lt;Object&gt; list;
private Set&lt;Object&gt; set;
private Object[] array;

public void setList(List&lt;Object&gt; list) &#123;
    this.list = list;
&#125;

public void setSet(Set&lt;Object&gt; set) &#123;
    this.set = set;
&#125;

public void setArray(Object[] array) &#123;
    this.array = array;
&#125;

@Override
public void save() &#123;
    System.out.println(&quot;UserDao Saved!&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40</p>
<!--
    di 注入单列集合类型
        需要在 <property>标签中
    list集合 使用子标签 <list>
            <value> 简单数据类型
            <ref> 引用数据类型(对象在ioc容器中)
    set集合 使用子标签 <set>
        <value> 简单数据类型
        <ref> 引用数据类型(对象在ioc容器中)
    array数组 使用子标签<array>
        <value> 简单数据类型
        <ref> 引用数据类型(对象在ioc容器中)
-->


<bean id="userDao" class="com.test.dao.impl.UserDaoImpl">
  <property name="list">
    <list>
      <value>A</value>
      <value>B</value>
      <ref bean="user"></ref>
    </list>
  </property>

  <property name="set">
    <set>
      <value>C</value>
      <value>D</value>
      <ref bean="user"></ref>
    </set>
  </property>

  <property name="array">
    <array>
      <value>E</value>
      <value>F</value>
      <ref bean="user"></ref>
    </array>
  </property>
</bean>
双列集合(map、properties)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>package com.test.dao.impl;</p>
<p>import com.test.dao.UserDao;</p>
<p>import java.util.List;<br>import java.util.Map;<br>import java.util.Properties;<br>import java.util.Set;</p>
<p>public class UserDaoImpl implements UserDao {</p>
<p>&#x2F;&#x2F;    private List<Object> list;<br>&#x2F;&#x2F;    private Set<Object> set;<br>&#x2F;&#x2F;    private Object[] array;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setList(List<Object> list) {<br>&#x2F;&#x2F;        this.list &#x3D; list;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setSet(Set<Object> set) {<br>&#x2F;&#x2F;        this.set &#x3D; set;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setArray(Object[] array) {<br>&#x2F;&#x2F;        this.array &#x3D; array;<br>&#x2F;&#x2F;    }</Object></Object></Object></Object></p>
<pre><code>private Map&lt;String ,Object&gt; map;
private Properties properties;

public void setMap(Map&lt;String, Object&gt; map) &#123;
    this.map = map;
&#125;

public void setProperties(Properties properties) &#123;
    this.properties = properties;
&#125;

@Override
public void save() &#123;
    System.out.println(&quot;UserDao Saved!&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27</p>
<!--
di 注入双列集合类型
    需要在 <property>标签中
map集合 使用子标签<map>
    <entry key="" value="简单数据类型" | value-ref="引用数据类型(对象ioc中)" ></entry>
properties集合 使用子标签 <props>
     <prop key="" >value</prop>
-->
<bean id="userDao" class="com.test.dao.impl.UserDaoImpl">
    <property name="map">
        <map>
            <entry key="k1" value="v1"></entry>
            <entry key="k2" value="v2"></entry>
            <entry key="u1" value-ref="user"></entry>
        </map>
    </property>
    <property name="properties">
        <props>
            <prop key="k1">v1</prop>
            <prop key="k3">v2</prop>
            <prop key="k3">v3</prop>
        </props>
    </property>
</bean>
5.6 配置文件模块化
实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，也就是所谓的配置文件模块化。

<p>并列加载</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>&#x2F;&#x2F;并列加载<br>@Test<br>public void testParallels() throws Exception{<br>    ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext_dao.xml”,”applicationContext_service.xml”);</p>
<p>}<br>主从配置</p>
<p>1<br>2<br>3<br>4<br>5<br>tree<br>.<br>├── applicationContext-dao.xml<br>├── applicationContext-service.xml<br>└── applicationContext.xml<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<!-- applicationContext.xml-->

<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;import resource=&quot;classpath:applicationContext-dao.xml&quot;&gt;&lt;/import&gt;
&lt;import resource=&quot;classpath:applicationContext-service.xml&quot;&gt;&lt;/import&gt;
</code></pre>
<p>注意：不论是否同一个xml，都不得出现相同id，否则触发报错或覆盖问题</p>
<p>5.7 知识小结<br><bean>标签:创建对象并放到spring的IOC容器</bean></p>
<p>id属性:在容器中Bean实例的唯一标识，不允许重复</p>
<p>class属性:要实例化的Bean的全限定名</p>
<p>scope属性:Bean的作用范围，常用是Singleton(默认)和prototype</p>
<p><constructor-arg>标签:属性注入</constructor-arg></p>
<p>name属性:属性名称</p>
<p>value属性:注入的简单属性值</p>
<p>ref属性:注入的对象引用值</p>
<p><property>标签:属性注入</property></p>
<p>name属性:属性名称</p>
<p>value属性:注入的简单属性值</p>
<p>ref属性:注入的对象引用值</p>
<list>
<set>
<array>
<map>
<props>

<p><import>标签:导入其他的Spring的分文件</import></p>
<p>总结</p>
<h1 id="spring01"><a href="#spring01" class="headerlink" title="spring01"></a>spring01</h1><h2 id="一-Spring概述"><a href="#一-Spring概述" class="headerlink" title="一 Spring概述"></a>一 Spring概述</h2><h3 id="spring是一款-full-stack-轻量级开源框架"><a href="#spring是一款-full-stack-轻量级开源框架" class="headerlink" title="spring是一款 full-stack 轻量级开源框架"></a>spring是一款 full-stack 轻量级开源框架</h3><ul>
<li>IOC</li>
</ul>
<p>​ - 控制反转</p>
<ul>
<li>AOP</li>
</ul>
<p>​ - 面向切面编程</p>
<h2 id="二-初识IOC"><a href="#二-初识IOC" class="headerlink" title="二 初识IOC"></a>二 初识IOC</h2><h3 id="控制反转（Inverse-Of-Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。"><a href="#控制反转（Inverse-Of-Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。" class="headerlink" title="控制反转（Inverse Of Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。"></a>控制反转（Inverse Of Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。</h3><h3 id="自定义IOC容器"><a href="#自定义IOC容器" class="headerlink" title="自定义IOC容器"></a>自定义IOC容器</h3><ul>
<li>BeanFactory</li>
</ul>
<h2 id="三-Spring快速入门"><a href="#三-Spring快速入门" class="headerlink" title="三 Spring快速入门"></a>三 Spring快速入门</h2><h3 id="1-创建java项目，导入spring开发基本坐标"><a href="#1-创建java项目，导入spring开发基本坐标" class="headerlink" title="1. 创建java项目，导入spring开发基本坐标"></a>1. 创建java项目，导入spring开发基本坐标</h3><h3 id="2-编写Dao接口和实现类"><a href="#2-编写Dao接口和实现类" class="headerlink" title="2. 编写Dao接口和实现类"></a>2. 编写Dao接口和实现类</h3><h3 id="3-创建spring核心配置文件"><a href="#3-创建spring核心配置文件" class="headerlink" title="3. 创建spring核心配置文件"></a>3. 创建spring核心配置文件</h3><h3 id="4-在spring配置文件中配置-UserDaoImpl"><a href="#4-在spring配置文件中配置-UserDaoImpl" class="headerlink" title="4. 在spring配置文件中配置 UserDaoImpl"></a>4. 在spring配置文件中配置 UserDaoImpl</h3><h3 id="5-使用spring相关API获得Bean实例"><a href="#5-使用spring相关API获得Bean实例" class="headerlink" title="5. 使用spring相关API获得Bean实例"></a>5. 使用spring相关API获得Bean实例</h3><h2 id="四-Spring相关API"><a href="#四-Spring相关API" class="headerlink" title="四 Spring相关API"></a>四 Spring相关API</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><ul>
<li>是 IOC 容器的核心接口，它定义了IOC的基本功能。</li>
</ul>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><ul>
<li><p>代表应用上下文对象，可以获得spring中IOC容器的Bean对象。</p>
</li>
<li><p>常用实现类</p>
</li>
</ul>
<p>​ - 1. ClassPathXmlApplicationContext</p>
<p>​ - 2. FileSystemXmlApplicationContext</p>
<p>​ - 3. AnnotationConfigApplicationContext</p>
<ul>
<li>常用方法</li>
</ul>
<p>​ - 1. Object getBean(String name);</p>
<p>​ - 2. <T> T getBean(Class<T> requiredType);</T></T></p>
<p>​ - 3. <T> T getBean(String name,Class<T> requiredType);</T></T></p>
<h2 id="五-Spring配置文件"><a href="#五-Spring配置文件" class="headerlink" title="五 Spring配置文件"></a>五 Spring配置文件</h2><h3 id="5-1-Bean标签基本配置"><a href="#5-1-Bean标签基本配置" class="headerlink" title="5.1 Bean标签基本配置"></a>5.1 Bean标签基本配置</h3><ul>
<li><p>id：Bean实例在Spring容器中的唯一标识</p>
</li>
<li><p>class：Bean的全限定名</p>
</li>
</ul>
<h3 id="5-2-Bean标签范围配置"><a href="#5-2-Bean标签范围配置" class="headerlink" title="5.2 Bean标签范围配置"></a>5.2 Bean标签范围配置</h3><ul>
<li>scope</li>
</ul>
<p>​ - singleton</p>
<p>​ - prototype</p>
<h3 id="5-3-Bean生命周期配置"><a href="#5-3-Bean生命周期配置" class="headerlink" title="5.3 Bean生命周期配置"></a>5.3 Bean生命周期配置</h3><ul>
<li><p>init-method</p>
</li>
<li><p>destroy-method</p>
</li>
</ul>
<h3 id="5-4-Bean实例化三种方式"><a href="#5-4-Bean实例化三种方式" class="headerlink" title="5.4 Bean实例化三种方式"></a>5.4 Bean实例化三种方式</h3><p>无参构造方法</p>
<p>工厂静态方法</p>
<p>工厂实例方法</p>
<h3 id="5-5-Bean依赖注入概述"><a href="#5-5-Bean依赖注入概述" class="headerlink" title="5.5 Bean依赖注入概述"></a>5.5 Bean依赖注入概述</h3><p>通过框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<h3 id="5-6-Bean依赖注入方式"><a href="#5-6-Bean依赖注入方式" class="headerlink" title="5.6 Bean依赖注入方式"></a>5.6 Bean依赖注入方式</h3><p>构造方法<br><constructor-arg name="”userDao”" ref="”userDao”/"><br>set方法<br><property name="”userDao”" ref="”userDao”/"><br>p命名空间<br><bean id="”userService”" class="”com.test.service.impl.UserServiceImpl”" p:userdao-ref="”userDao”/"></bean></property></constructor-arg></p>
<h3 id="5-7-Bean依赖注入的数据类型"><a href="#5-7-Bean依赖注入的数据类型" class="headerlink" title="5.7 Bean依赖注入的数据类型"></a>5.7 Bean依赖注入的数据类型</h3><ul>
<li><p>简单数据类型</p>
</li>
<li><p>引用数据类型</p>
</li>
<li><p>集合数据类型</p>
</li>
</ul>
<p>​ - list</p>
<p>​ - set</p>
<p>​ - array</p>
<p>​ - map</p>
<p>​ - properties</p>
<h3 id="5-8-配置文件模块化"><a href="#5-8-配置文件模块化" class="headerlink" title="5.8 配置文件模块化"></a>5.8 配置文件模块化</h3><ul>
<li>主从配置</li>
</ul>
<import resource="”applicationContext-xxx.xml”/"></import></props></map></array></set></list>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/25/Linux-Nginx/" rel="prev" title="Linux & Nginx">
      <i class="fa fa-chevron-left"></i> Linux & Nginx
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/03/Spring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="next" title="Spring 声明式事务">
      Spring 声明式事务 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#spring01"><span class="nav-number">1.</span> <span class="nav-text">spring01</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-Spring%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">一 Spring概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring%E6%98%AF%E4%B8%80%E6%AC%BE-full-stack-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">spring是一款 full-stack 轻量级开源框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%88%9D%E8%AF%86IOC"><span class="nav-number">1.2.</span> <span class="nav-text">二 初识IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88Inverse-Of-Control%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%82%E5%AE%83%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E6%8C%87%E5%AF%BC%E6%88%91%E4%BB%AC%E8%AE%BE%E8%AE%A1%E5%87%BA%E6%9B%B4%E5%8A%A0%E6%9D%BE%E8%80%A6%E5%90%88%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%82"><span class="nav-number">1.2.1.</span> <span class="nav-text">控制反转（Inverse Of Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89IOC%E5%AE%B9%E5%99%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">自定义IOC容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-Spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">1.3.</span> <span class="nav-text">三 Spring快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%AF%BC%E5%85%A5spring%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%9D%90%E6%A0%87"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 创建java项目，导入spring开发基本坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99Dao%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 编写Dao接口和实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BAspring%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 创建spring核心配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9C%A8spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE-UserDaoImpl"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 在spring配置文件中配置 UserDaoImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8spring%E7%9B%B8%E5%85%B3API%E8%8E%B7%E5%BE%97Bean%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. 使用spring相关API获得Bean实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-Spring%E7%9B%B8%E5%85%B3API"><span class="nav-number">1.4.</span> <span class="nav-text">四 Spring相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory"><span class="nav-number">1.4.1.</span> <span class="nav-text">BeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">1.4.2.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.</span> <span class="nav-text">五 Spring配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Bean%E6%A0%87%E7%AD%BE%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 Bean标签基本配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Bean%E6%A0%87%E7%AD%BE%E8%8C%83%E5%9B%B4%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 Bean标签范围配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 Bean生命周期配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 Bean实例化三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-Bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A6%82%E8%BF%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5 Bean依赖注入概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-Bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6 Bean依赖注入方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-Bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.7.</span> <span class="nav-text">5.7 Bean依赖注入的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">1.5.8.</span> <span class="nav-text">5.8 配置文件模块化</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '713a28a3ad93f2aa2323',
      clientSecret: '39dc40bb09b422ca4c99a748b5984a4d205e91be',
      repo        : 'swzxsyh.github.io',
      owner       : 'swzxsyh',
      admin       : ['swzxsyh'],
      id          : '7e2b37087e696741d143a4d3619b0ac4',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
