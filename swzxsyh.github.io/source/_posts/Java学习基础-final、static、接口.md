---
title: Java学习基础-final、static、接口
date: 2020-03-03 00:19:57
tags:
---
一. final关键字
1.1 final在Java中是一个定义修饰符：修饰类，修饰方法，修饰局部变量，修饰成员变量，修饰引用类型变量
1.2 final的作用和介绍
•final修饰类，不能被继承（只能做子类）。
•final修饰方法，不能被@override
•final修饰局部变量：被final修饰的局部变量，表示该变量只能赋值一次。（在循环框中，每次赋值都是新的局部变量）
•final修饰引用类型变量
final修饰引用类型变量，表示该引用类型变量地址值中表示的地址值不能改变。
注意：final修饰引用变量，只能表示引用变量的地址不能改变，并不代表地址所指向的成员值是可以改变的。
•final修饰成员变量，只能赋值一次，必须赋值。
但是赋值可以有两种选择。
a.定义该成员变量时赋值。
b.或者在构造方法中给该成员变量赋值。

总之，final修饰的成员变量，必须在创建对象之前有值。

final和abstract冲突。

二. static ：静态关键字
2.1 概述：也是一个修饰符，用于修饰类中的成员变量/方法，被static修饰的成员称为静态成员/类成员。

被static修饰的成员，不属于任何一个对象，属于整个类，被所有对象共享(这也是判断是否使用静态关键字的条件)

2.2 定义和格式
•类变量：就是使用static修饰的成员变量，称之为类变量/静态变量
特点：静态变量/类变量，在内存方法中的静态区，只有一份，所有对象共享它
•静态方法：就是使用static修饰的方法，也称为类方法。
特点：正常的方法必须通过对象才能调用，静态方法不需要通过对象，通过类名就可以直接调用

2.3 静态和非静态之间的相互调用
静态成员变量
静态成员方法
与类是同级，只要类加载到内存，静态的成员变量/成员方法就存在（对象不一定存在）

非静态成员变量
非静态成员方法
必须创建对象之后才能访问/调用

生命周期：
静态出现的要比非静态要早

非静态成员方法：
•能访问静态的成员变量
•能访问非静态的成员变量
•能访问静态的成员方法
•能访问非静态的成员方法

静态成员方法：
•能访问静态的成员变量
•能访问静态的成员方法

结论：
a.静态与静态之间，非静态与非静态之间，能相互访问
b.静态可以访问静态，但是静态不能访问非静态
即：静态成员方法只能访问静态成员

2.4 建议调用格式
静态的成员变量
对象名.静态成员变量 [可以访问，但是不建议]
类名.静态成员变量 [建议访问的方式]

静态的成员方法
对象名。静态成员方法 [可以访问，不建议]
类名.静态成员方法 [建议的访问方式]
总结：静态成员虽然可以通过对象名去访问/嗲用，但是更建议通过类名去访问/调用

三. 接口
3.1 概述
也是一种引用类型，接口是方法的集合（接口中主要写方法）
接口是一种公共的规范标准，只要符合规范标准，就可以通用
Java中的接口更多是体现着对行为的抽象。

3.2 定义格式
定义类：class
定义接口：interface
定义枚举：enum
定义注解：@interface

```java
public interface interfaceName{
  abstract method [JDK 7]
    default method & static method [JDK 8]
    private method & private static method [JDK 9]
}
```


接口的特点：
•接口用关键字interface修饰
public interface接口名{}
•类实现接口用implements表示
public class 类名 implements 接口名{}
•接口不能实例化
参照多态的方式，通过实现类对象实例化，叫做接口多态。
多态的形式：具体类多态，抽象类多态，接口多态
多态的前提：有继承或实现关系；有方法重写；有父(类/接口)引用指向(子/实现)类对象
•接口的实现类
要么重写接口中所有的抽象方法
要么是抽象类

3.3 接口的使用
a.和abstract method类似，接口也是不能创建对象（new object）的
b.接口也是作为Super interface使用的，用于被其他类 实现 的
c.继承使用extends关键字，实现使用”implements”关键字

使用方式：

```java
public class 实现类 implements interfaceName{
  //实现类必须重写接口中的所有抽象方法
  //实现类可以选择性重写默认方法但是@override后不能加default
  //静态方法通过类名/接口名直接调用的，没有@override说法
}
```
3.4 接口的多实现
格式：

```java
public class 实现类 implements interface1,interface2...{
  //实现类需要重写所有接口中的所有抽象方法
  //如果有抽象方法是一样的，那么实现类只需要重写一次
  //如果接口中有一样的默认方法，那么实现类必须重写一次！
  //静态方法没有重写的概念，就算多个接口中有一样的静态方法也不冲突，通过各自所在的接口名调用，没有歧义
}
```
3.5 实现和继承的优先级问题
一个类 可以在继承一个父类的同时实现多个接口（继承和实现可以同时存在）
格式：

```java
public class 子类/实现类 exttends 父类 implements 接口，接口1{

}
```
继承的优先级 高于 实现，所以必须先extends 后 implements

3.6 接口的多继承
类和类直接：继承关系，只能单继承，但是可以多层继承
类和接口：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
接口和接口：继承关系，可以单继承，也可以多继承
格式：

```java
public interface MyInter extends Inter1,Inter2{
  MyInter 接口包含了Inter1和Inter2接口所有东西
}

例：
  public class MyClass impelements MyInter{

  }
和
  public class MyClass impelements Inter1,Inter{

  }
等价
```
3.7 接口中其他成员特点
•接口中，无法定义成员变量，但是可以定义常量（字面值常量，由public static final修饰的常量），其值不可改变，默认使用public static final修饰
【public static final】数据类型 常量名 = 值；【常量名一般纯大写，多个单词用”_”分隔】

•接口中，没有构造方法，也不能创建对象，因为接口主要是对行为进行抽象的，是没有具体存在
一个类如果没有父类，默认继承自Object类

•接口中，没有静态代码块
•【public static final】可省略直接 数据类型 常量名 = 值。但是默认是存在的

•成员方法
只能是抽象方法
默认修饰符public abstract

抽象类和接口的区别：
•成员区别

抽象类	变量，常量；有构造方法；有抽象方法，也有非抽象方法
接口	常量；抽象方法
•关系区别

类与类	继承，单继承
类与接口	实现，可以单实现，也可以多实现
接口与接口	继承，但继承，多继承
•设计理念区别

抽象类	对类抽象，包括属性，行为
接口	对行为抽象，主要是行为
3.8 接口名作为形参和返回值
•方法的形参是接口名，其实需要的是该接哦哭的实现类对象
•方法的返回值是接口名，其实返回的是该接口的实现类对象

总结：
描述final
修饰类：该类不能被继承
修饰方法：该方法不能被重写
修饰变量：该变量只能赋值一次
——局部变量：可以在定义时赋值，也可以先定义后赋值
——成员变量：可以在定义时赋值，也可以在构造方法中赋值
——引用类型变量：表示该引用类型变量的地址不能改变，但是地址内成员的值是可以改变的

static关键字修饰的变量调用方式
类名.成员变量名 【建议的使用方式】

static关键字修饰的方法调用方式
类名.成员() 【建议的使用方式】

接口定义格式：

```java
public interface interfaceName{
  //抽象方法[最多使用]
  //默认方法
  //静态方法
}
```
接口实现方式：

```java
public class 实现类 impelements interfaceName01,02{
  //a.重写所有抽象方法，如果有相同，仅需重写一次
  //b.选择性重写默认方法，如果相同必须重写一次
  //c.静态方法没有重写的概念
}
```
接口中其他成员特点：
a.没有成员变量，只有常量 【public static final】数据类型 常量名 = 值；
b.没有构造方法，也不能创建对象
c.没有静态代码块