---
layout: post
title: JAVA-JMM
date: 2022-06-30 23:10:41
tags:
---

# Java内存模型概念

java内存模型（java memory model，简称JMM）用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。

目标：定义程序中各个变量的访问规则，即在虚拟机中将变量从内存中进行存储和取出这样的底层细节。

内存模型的组成：

1.主内存，java内存模型规定，所有变量都存储在主内存（Main Memory）中

2.工作内存，每条线程都有自己的工作内存（working memory，又称本地内存），工作内存是JMM的一个抽象概念，并不真实存在，它涵盖了：缓存、写缓冲区、寄存器以及其他硬件和编译器优化

![image](./JAVA-JMM/screen_shot.png)

<!-- more -->

# 内存交互

关于主内存和工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，java内存模型中定义了8种操作

​    ![8种基本操作](./JAVA-JMM/stickPicture.png)

1.lock（锁定）作用于主内存变量，它把一个变量标识为一条线程独占的状态。

2.unlock（解锁）作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他变量锁定

3.read（读取）作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便于随后的load动作使用

4.load（载入）作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

5.use（使用）作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时就会执行这个操作

6.assign（赋值）作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行这个操作

7.store（存储）作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write操作使用

8.write（写入）作用于主内存的变量，它把store操作从主内存中得到的变量的值放入到主内存中

![image](./JAVA-JMM/sync_load_store.png)

# 同步规则

- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。

# JVM内存操作的并发问题

**1.工作内存数据一致性** 

各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及到同一个共享变量时，将导致各自的共享变量副本不一致，如果发生这种情况，以谁的副本为准呢?

**2.指令重排序优化** 

java中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序的一种手段。重排序分为两类：**编译器重排序和运行期重排序**，分别对应编译器和运行时环境，指令重排序满足两个条件：

1.单线程情况下，要给程序一个顺序执行的假象，即经过重排序的执行结果与顺序执行的结果保持一致

2.存在数据依赖关系的不允许重排序

# 内存交互的3个基本特征

1. **原子性** 
2. **可见性** 
3. **有序性**

# 内存屏障

1.java中如何保证底层操作的有序性和可见性呢？可以通过内存屏障。

内存屏障是被插入两个CPU指令之间的一种指令，用来**禁止**处理器指令发生**重排序**，从而保障**有序性**的。

为了达到屏障的效果，它也会使处理器写入、读取之前，将**主内存的值写入高速缓存**，**清空无效队列**，从而**保障可见性**。

例：

Store1; 

Store2;   

Load1;   

StoreLoad;  //内存屏障

Store3;   

Load2;   

Load3;

2.常见的四种屏障

1）LoadLoad屏障：对于这样的语句：Load1；LoadLoad；Load2，在load2及后续读操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。

2）StoreStore屏障：例：Store1;StoreStore;Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其他处理器可见。

3）LoadStore屏障：例：Load1;LoadStore;Store2，在Store2及后续写入操作执行前，保证Load1要读取的数据被读取完毕。

4）StoreLoad屏障：例：Store1;StoreLoad;Load2,在Load2及后续所有读操作执行前，保证Store1的写入对所有处理器可见（开销最大，冲刷写缓冲区，清空无效队列）。在大多数处理器中，这个屏障是个万能屏障

# Volatile

volatile的中文意思是不稳定的、易变的，用volatile修饰的变量是为了**保证变量的可见性**。

volatile有两种语义：

1.**保证可见性**，

线程写volatile变量的过程：

1）改变线程工作内存中volatile变量副本的值

2）将改变后的副本的值从工作内存刷到主内存中

线程读volatile变量值的过程

1）从主内存中读取volatile变量的最新值到线程的工作内存中

2）从工作内存中读取volatile变量的副本

**2.禁止进行指令重排序**

1）当程序执行到volatile变量的**读操作或者写操作时**，在**其前面的操作的更改肯定已经全部进行**，**且结果对后面的操作可见**（happens-before）；在**其后面的操作肯定还没有进行**

2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能讲volatile变量后面的语句放在其前面执行（不能改变volatile变量前后的语句顺序）

**3.实现原理**

![image](./JAVA-JMM/image-20220703171312027.png)



来源：

https://rumenz.com/rumenbiji/java-jmm-synchronize-eight-operations.html
