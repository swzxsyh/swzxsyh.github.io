---
layout: post
title: MySQL-MVCC
date: 2022-06-30 23:09:09
tags:
---

# MVCC

目的：解决不可重复读，用于RR隔离级别

MVCC，全称：multiversion concurrency control，多版本并发控制，是innodb实现事务回滚与并发的重要功能

具体实现：在数据库的每一行中添加额外的三个字段：

- DB_TRX_ID：记录插入或更新该行的最后一个事务的事务ID
- DB_ROLL_PTR：指向该行的undolog指针
- DB_ROW_ID：单调递增的行ID，他就是AUTO_INCREMENT 的主键ID

<!-- more -->

## Read View

- 事务进行**快照读**的时候会生成一个读视图,格式

```
|--------------|------ |-----------|----------- |
|creator_trx_id  | m_ids | min_trx_id | max_trx_id  |
|--------------|------ |-----------|----------- |
```
- creator_trx_id
	创建该Read View的事务的事务id
- m_ids 
	创建视图时当前数据库中活跃且未提交的事务的事务id列表
- min_trx_id
	创建Read View时当前数据库中活跃且未提交的事务中最小的事务id
- max_trx_id
		创建Read View 时当前数据库应该给下一个事务的id

## 读已提交隔离原理

- 假设事务A、事务B同时执行，事务B执行update a = 10 操作
  - 事务开启时，Read View 记录情况（如图）：
    事务A的Read View中，它的事务id时是1001，由于与事务B同时执行，所以此时活跃的事务的事务id列表（m_ids）为【1001，1002】，活跃的事务id中最小的为事务A的事务id ：1001；下一事务id为1003
    事务B的Read View中，它的事务id时是1002，由于与事务A同时执行，所以此时活跃的事务的事务id列表（m_ids）为【1001，1002】，活跃的事务id中最小的为事务A的事务id ：1001；下一事务id为1003
    
    
    
  - 此时，事务A查询id为1的记录，找到记录后，发现该记录的trx_id 为1000，通过和自己的Read View中的m_ids中的事务id比较，发现该事务id不在活跃的事务id列表中，并且小于事务A的事务id，即该记录早在事务A之前已经提交，因此该记录对事务A可见
  
  - 事务B通过update操作将字段a的值修改为10，但未提交事务，此时最新的记录的trx_id为1002。如图
  
    
  
  - 然后事务A再次读取该记录时，发现记录的trx_id变为1002，比自己的事务id大，并且比下一个事务id 1003小，即事务A读取到的是和自身同时执行的事务B提交的数据。这是事务A并不会读取这条记录，而是沿着undo log的版本链往下寻找，知道找到trx_id 小于等于自身事务id的第一条记录，即a字段值为1的这条记录
  
  - 此时事务B提交后，事务A再次读取到该记录，发现记录的trx_id比自身的事务id大，并且不在活跃事务的id列表中，则说明事务B已经提交事务，则该记录可以被读取



## 可重复读隔离原理

- 假设事务A、事务B同时执行，事务B执行update a = 10 操作
  - 事务开启时，Read View 记录情况（如图）：
    事务A的Read View中，它的事务id时是1001，由于与事务B同时执行，所以此时活跃的事务的事务id列表（m_ids）为【1001，1002】，活跃的事务id中最小的为事务A的事务id ：1001；下一事务id为1003
    
    
    
    事务B的Read View中，它的事务id时是1002，由于与事务A同时执行，所以此时活跃的事务的事务id列表（m_ids）为【1001，1002】，活跃的事务id中最小的为事务A的事务id ：1001；下一事务id为1003
    
  - 此时，事务A查询id为1的记录，找到记录后，发现该记录的trx_id 为1000，通过和自己的Read View中的m_ids中的事务id比较，发现该事务id不在活跃的事务id列表中，并且小于事务A的事务id，即该记录早在事务A之前已经提交，因此该记录对事务A可见
  
  - 然后，事务B通过update操作将字段a的值修改为10，这是MySQL会记录undo log，并以链表的方式串联起来，形成版本链，如图所示，此前的记录就会变成旧版记录
  
    
  
  - 然后事务A再次读取该记录时，发现记录的trx_id变为1002，比自己的事务id大，并且比下一个事务id 1003小，即事务A读取到的是和自身同时执行的事务B提交的数据。这是事务A并不会读取这条记录，而是沿着undo log的版本链往下寻找，知道找到trx_id 小于等于自身事务id的第一条记录，即a字段值为1的这条记录

## 当前读

- 除了普通select外的所有操作，如update、insert都会读取最新的数据

  update/delete/insert/select...for update/select lock in share model

## 快照读

- 【可重复读隔离】级别下，普通的select读都是快照读。读的都是当前快照版本的数据，看不到其他版本的数据，其他事务操作的未提交时，记录的trx_id字段不会更新



## 数据库的几种并发场景

- 读读：不存在数据安全问题

- 写写：有数据安全问题，更新丢失

- 读写：有线程安全问题，脏读、幻读、不可重复读（MVCC就是为了解决这种问题而存在的）

如果是RC隔离级别，那么每次在进行快照读的时候都会生成一个新的readview

如果是RR隔离级别，那么只有在当前事务第一次进行快照读的时候会生成readview，之后的快照读都会沿用当前的readview

RC和RR之间的区别就在于生成readview的时机不同

![image](./MySQL-MVCC/aefb3beb449db7713aea01b265b997d6.jpg)
