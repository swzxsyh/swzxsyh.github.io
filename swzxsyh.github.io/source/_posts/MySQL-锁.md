---
layout: post
title: MySQL-锁
date: 2022-06-30 23:09:28
tags:
---

# 锁

## 	全局锁(数据库只读)

- FTWRL
  - 执行：
    flush tables with read lock
    执行后数据库处于只读状态，对数据的增删改查操作(select、insert、update、delete)以及对表结构的更改操作（alter table、drop table）都会被阻塞​
  - 执行:
    unlock tables
    释放全局锁，或者断开会话自动释放全局锁​
  - 主要应用于做全库逻辑备份，保证备份文件不会因备份期间数据库的更改而与预期不一致。
    数据量大的时候会导致业务受影响，因为数据库处于只读状态。因此可以利用MVCC的机制，在备份前开启事务，生成Read View进行保证可重复读，这样备份期间仍然可以对数据库进行增删操作，前提是数据库存储引擎支持事务(数据库只读,MVCC)

## 表级锁

- 表锁

  - lock tables t read -- 表锁,读锁,共享锁
  - lock tables t write -- 表锁,写锁,排他锁
  - 表锁除会限制别的线程读写外，也会限制当前线程后续的读写操作。即对表 t 加了【共享表锁】。当前线程及其他线程的后续写操作会被阻塞直至锁被释放

- 元数据锁（MDL）

  - 对数据库表进行CRUD操作时会自动加MDL读锁 -- 读锁
  - 对数据库表结构进行变更操作时会自动加MDL写锁 -- 写锁
  - MDL在事务提交后才会释放。在事务未提交前执行数据库表操作可能会导致数据库线程爆满。
    如：线程A在执行selct操作时会自动持有MDL读锁，此时线程B执行数据库表结构变更，则需要获取MDL 写锁，但由于事务未提交，读锁未释放，线程C获取写锁会被阻塞，进入队列等待。队列中【写锁获取优先级大于读锁】，一旦出现写锁等待，会阻塞后续的读锁获取，及阻塞其他的CURD操作线程

- 意向锁(InnoDB)

  - 意向锁是表级锁，不会和行级锁发生冲突，并且意向锁之间也不会发生冲突。
    只会和共享表锁、独占表锁发生冲突

  - 普通的select操作利用MVCC实现一致性读，是【无锁】的

    - select ... lock in shard mode
      先对表加上【意向共享锁】，在对读取的记录加上【排它锁】

    - select ... for update
      先对表加上【意向排他锁】，再对读取的记录加【排它锁】

  - 执行插入、更新、删除操作前，需要先对表加上【意向共享锁】，再对记录加【排它锁】
      		
  - 表锁和行锁之间满足【读读共享】、【读写互斥】、【写写互斥】
      		如果没有【意向锁】，那么加【排他表锁】时需要遍历表里的所有记录，查看是否有记录存在【排它锁】，效率会很慢。
      有了【意向锁】之后，由于在对记录加排他锁之前，先会加上表级别的【意向排它锁】，那么在对记录加【排他锁时】，直接查看该表是否存在【意向排他锁】即可
  
- AUTO-INC锁
  			字段被声明为AUTO_INCREATMENT时，数据库会自动给该字段赋递增的值，通过AUTO-INC锁实现的
    			在插入数据时，会加上AUTO-INC锁，插入语句执行完成后会释放。
  事务持有该锁的过程，其他事务的插入将会被阻塞
  				大量数据插入时会影响性能。
  				MySQL 5.1.22版本后InnoDB提供了【轻量级】的锁实现自增
  				innodb_autoinc_lock_mode 变量控制选择AUTO-INC还是轻量级锁
  innodb_autoinc_lock_mode = 0 时选用AUTO-INC锁
  innodb_autoinc_lock_mode = 2 时选用轻量级锁
  innodb_autoinc_lock_mode = 1  (默认值)时混用两种锁
  					采用轻量级锁时，性能高但在并发插入时，自增长的值可能不是连续的，在主从复制的场景是【不安全】的

## 行级锁

- Next-Key Lock
  - 它是对记录【加锁的基本单位】
    由【记录锁】和【间隙锁】组合而成
  - next-key lock 【前开后闭】区间
  - 某些场景下会退化成为【记录锁】或【间隙锁】
    - 唯一索引等值查询
      记录存在，会退化成为【记录锁】(记录锁,前开后闭区间)
      记录不存在，会退化成为【间隙锁】
    - 唯一索引范围查询
      会退化为加【记录锁】或【间隙锁】，也可能同时加两个锁
    - 非唯一索引等值查询
      记录存在时会加上next-key lock以及【间隙锁】
      记录不存在时，会加上多个【间隙锁】
    - 非唯一索引范围查询
      不会退化，只会加【next-key lock】
  - sql_safe_updates
- Record Lock
- Gap Lock
  【前开后开】区间

## 死锁

- innodb_lock_wait_timeout
  设置锁超时时间，默认50秒
- innodb_deadlock_detect
  开启死锁检测，在检测到死锁时回滚两条中的某一个事务
