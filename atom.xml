<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>swzxsyh</title>
  
  <subtitle>--笔记</subtitle>
  <link href="https://swzxsyh.github.io/atom.xml" rel="self"/>
  
  <link href="https://swzxsyh.github.io/"/>
  <updated>2022-08-02T20:14:35.809Z</updated>
  <id>https://swzxsyh.github.io/</id>
  
  <author>
    <name>swzxsyh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker-Kubernetes关联与演变</title>
    <link href="https://swzxsyh.github.io/2022/08/02/Docker-K8S/"/>
    <id>https://swzxsyh.github.io/2022/08/02/Docker-K8S/</id>
    <published>2022-08-02T14:21:38.000Z</published>
    <updated>2022-08-02T20:14:35.809Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-Kubernetes关联与演变&quot;&gt;&lt;a href=&quot;#Docker-Kubernetes关联与演变&quot; class=&quot;headerlink&quot; title=&quot;Docker-Kubernetes关联与演变&quot;&gt;&lt;/a&gt;Docker-Kubernetes关联与演变&lt;/h1&gt;&lt;h2 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h2&gt;&lt;h3 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h3&gt;&lt;p&gt;是指容器化技术，用于支持创建和使用 &lt;a href=&quot;https://www.redhat.com/zh/topics/containers&quot;&gt;Linux® 容器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么使用Docker&quot;&gt;&lt;a href=&quot;#为什么使用Docker&quot; class=&quot;headerlink&quot; title=&quot;为什么使用Docker&quot;&gt;&lt;/a&gt;为什么使用Docker&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;更高效的利用系统资源&lt;/li&gt;
&lt;li&gt;更快速的启动时间&lt;/li&gt;
&lt;li&gt;一致的运行环境&lt;/li&gt;
&lt;li&gt;持续交付和部署&lt;/li&gt;
&lt;li&gt;更轻松的迁移&lt;/li&gt;
&lt;li&gt;更轻松的维护和扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Docker基本概念&quot;&gt;&lt;a href=&quot;#Docker基本概念&quot; class=&quot;headerlink&quot; title=&quot;Docker基本概念&quot;&gt;&lt;/a&gt;Docker基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;镜像（&lt;code&gt;Image&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容器（&lt;code&gt;Container&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;容器的实质是进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;仓库（&lt;code&gt;Repository&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://swzxsyh.github.io/2022/08/02/Distributed-Transaction/"/>
    <id>https://swzxsyh.github.io/2022/08/02/Distributed-Transaction/</id>
    <published>2022-08-01T19:27:24.000Z</published>
    <updated>2022-08-02T09:32:02.818Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;h2 id=&quot;什么是分布式系统&quot;&gt;&lt;a href=&quot;#什么是分布式系统&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式系统&quot;&gt;&lt;/a&gt;什么是分布式系统&lt;/h2&gt;&lt;p&gt;部署在不同结点上的系统通过网络交互来完成协同工作的系统&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;h3 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h3&gt;&lt;p&gt;事务是指由一组操作组成的一个工作单元，这个工作单元具有原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。&lt;/p&gt;
&lt;h3 id=&quot;什么是本地事务&quot;&gt;&lt;a href=&quot;#什么是本地事务&quot; class=&quot;headerlink&quot; title=&quot;什么是本地事务&quot;&gt;&lt;/a&gt;什么是本地事务&lt;/h3&gt;&lt;p&gt;本地事务就是用关系数据库来控制事务，关系数据库通常都具有ACID特性，传统的单体应用通常会将数据全部存储在一个数据库中，会借助关系数据库来完成事务控制。&lt;/p&gt;
&lt;h3 id=&quot;什么是分布式事务&quot;&gt;&lt;a href=&quot;#什么是分布式事务&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式事务&quot;&gt;&lt;/a&gt;什么是分布式事务&lt;/h3&gt;&lt;p&gt;在分布式系统中一次操作由多个系统协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为分布式事务。这里强调的是多个系统通过网络协同完成一个事务的过程，并不强调多个系统访问了不同的数据库，即使多个系统访问的是同一个数据库也是分布式事务，&lt;/p&gt;
&lt;p&gt;另外一种分布式事务的表现是，一个应用程序使用了多个数据源连接了不同的数据库，当一次事务需要操作多个数据源，此时也属于分布式事务，当系统作了数据库拆分后会出现此种情况&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>布隆过滤器 与 布谷鸟过滤器</title>
    <link href="https://swzxsyh.github.io/2022/07/19/Bloom-Filter-VS-Cuckoo-Filter/"/>
    <id>https://swzxsyh.github.io/2022/07/19/Bloom-Filter-VS-Cuckoo-Filter/</id>
    <published>2022-07-19T15:46:54.000Z</published>
    <updated>2022-07-19T16:58:54.545Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;布隆过滤器-Bloom-Filter&quot;&gt;&lt;a href=&quot;#布隆过滤器-Bloom-Filter&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器 Bloom Filter&quot;&gt;&lt;/a&gt;布隆过滤器 Bloom Filter&lt;/h1&gt;&lt;p&gt;大概的思路就是,当你请求的信息来的时候,先检查一下你查询的数据我这有没有,有的话将请求压给数据库,没有的话直接返回&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存入过程&lt;/p&gt;
&lt;p&gt;通过三个hash函数计算出三个哈希值，然后将三个值映射到数组中将0改成1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询过程&lt;/p&gt;
&lt;p&gt;通过三个hash函数计算出查询数据的哈希值，然后检查布隆过滤器对应位置上的值是否为1，如果有一个不为1表示该值不存在，如果都为1表示该值可能存在。（查询时间复杂度为O(k)，k为哈希函数个数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除过程&lt;/p&gt;
&lt;p&gt;不能进行删除，因为会删除掉其他数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新过程&lt;/p&gt;
&lt;p&gt;不能进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;h3 id=&quot;布隆过滤器基础版&quot;&gt;&lt;a href=&quot;#布隆过滤器基础版&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器基础版&quot;&gt;&lt;/a&gt;布隆过滤器基础版&lt;/h3&gt;&lt;p&gt;原理就是一个对一个key进行k个hash算法获取k个值，在比特数组中将这k个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/07/19/Bloom-Filter-VS-Cuckoo-Filter/94957b79c1faedcadc033ee1528a239a.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个bitmap用于记录，bitmap原始数值全都是0。当一个数据存进来的时候，用三个Hash函数分别计算三次Hash值,并且将bitmap对应的位置设置为1,上图中,bitmap 的1,3,6位置被标记为1,这时候如果一个数据请求过来,依然用之前的三个Hash函数计算Hash值,如果是同一个数据的话,势必依旧是映射到1,3,6位,那么就可以判断这个数据之前存储过,如果新的数据映射的三个位置,有一个匹配不上,假如映射到1,3,7位,由于7位是0,也就是这个数据之前并没有加入进数据库,所以直接返回。&lt;/p&gt;
&lt;p&gt;Redis的bitmap只支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率及小，省去了大量无效的数据库连接。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-Container</title>
    <link href="https://swzxsyh.github.io/2022/07/14/Spring-Container/"/>
    <id>https://swzxsyh.github.io/2022/07/14/Spring-Container/</id>
    <published>2022-07-14T15:59:55.000Z</published>
    <updated>2022-07-14T17:25:49.428Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-容器是什么&quot;&gt;&lt;a href=&quot;#Spring-容器是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring 容器是什么&quot;&gt;&lt;/a&gt;Spring 容器是什么&lt;/h1&gt;&lt;p&gt;Spring容器帮程序员处理了大量繁琐的过程，可以说Spring 容器是 Spring 框架的核心。&lt;/p&gt;
&lt;h2 id=&quot;Spring容器到底是什么&quot;&gt;&lt;a href=&quot;#Spring容器到底是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring容器到底是什么&quot;&gt;&lt;/a&gt;Spring容器到底是什么&lt;/h2&gt;&lt;h3 id=&quot;从概念上讲&quot;&gt;&lt;a href=&quot;#从概念上讲&quot; class=&quot;headerlink&quot; title=&quot;从概念上讲&quot;&gt;&lt;/a&gt;从概念上讲&lt;/h3&gt;&lt;p&gt;Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。&lt;/p&gt;
&lt;h3 id=&quot;从具象化讲&quot;&gt;&lt;a href=&quot;#从具象化讲&quot; class=&quot;headerlink&quot; title=&quot;从具象化讲&quot;&gt;&lt;/a&gt;从具象化讲&lt;/h3&gt;&lt;p&gt;在java项目中，我们使用实现了org.springframework.context.ApplicationContext接口的实现类。在web项目中，我们使用spring.xml——Spring的配置文件。&lt;/p&gt;
&lt;h3 id=&quot;从代码上讲&quot;&gt;&lt;a href=&quot;#从代码上讲&quot; class=&quot;headerlink&quot; title=&quot;从代码上讲&quot;&gt;&lt;/a&gt;从代码上讲&lt;/h3&gt;&lt;p&gt;一个Spring容器就是某个实现了ApplicationContext接口的类的实例。也就是说，从代码层面，Spring容器其实就是一个ApplicationContext（一个实例化对象）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SearchEngine-ElasticSearch</title>
    <link href="https://swzxsyh.github.io/2022/07/11/SearchEngine-ElasticSearch/"/>
    <id>https://swzxsyh.github.io/2022/07/11/SearchEngine-ElasticSearch/</id>
    <published>2022-07-10T16:06:35.000Z</published>
    <updated>2022-07-14T17:25:49.396Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;ElasticSearch&quot;&gt;&lt;a href=&quot;#ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch&quot;&gt;&lt;/a&gt;ElasticSearch&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Elasticsearch（简称ES）是一个分布式、可扩展、实时的搜索与数据分析引擎。ES不仅仅只是全文搜索，还支持结构化搜索、数据分析、复杂的语言处理、地理位置和对象间关联关系等。&lt;/p&gt;
&lt;p&gt;ES的底层依赖Lucene，Lucene可以说是当下最先进、高性能、全功能的搜索引擎库。但是Lucene仅仅只是一个库。为了充分发挥其功能，你需要使用Java并将Lucene直接集成到应用程序中。更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理，因为Lucene非常复杂——《ElasticSearch官方权威指南》。&lt;/p&gt;
&lt;p&gt;鉴于Lucene如此强大却难以上手的特点，诞生了ES。ES也是使用Java编写的，它的内部使用Lucene做索引与搜索，它的目的是隐藏Lucene的复杂性，取而代之的提供一套简单一致的RESTful API。&lt;/p&gt;
&lt;p&gt;总体来说，ES具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个分布式的实时文档存储引擎，每个字段都可以被索引与搜索&lt;/li&gt;
&lt;li&gt;一个分布式实时分析搜索引擎，支持各种查询和聚合操作&lt;/li&gt;
&lt;li&gt;能胜任上百个服务节点的扩展，并可以支持PB级别的结构化或者非结构化数据&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA-Synchronized与ReentrantLock</title>
    <link href="https://swzxsyh.github.io/2022/07/08/JAVA-Synchronized%E4%B8%8EReentrantLock/"/>
    <id>https://swzxsyh.github.io/2022/07/08/JAVA-Synchronized%E4%B8%8EReentrantLock/</id>
    <published>2022-07-07T19:00:16.000Z</published>
    <updated>2022-07-14T17:25:49.029Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h1&gt;&lt;h2 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h2&gt;&lt;h3 id=&quot;公平和非公平锁&quot;&gt;&lt;a href=&quot;#公平和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平和非公平锁&quot;&gt;&lt;/a&gt;公平和非公平锁&lt;/h3&gt;&lt;p&gt;公平锁指的就是：在竞争环境下，先到临界区的线程比后到的线程一定更快地获取得到锁&lt;/p&gt;
&lt;p&gt;那非公平就很好理解了：先到临界区的线程未必比后到的线程更快地获取得到锁&lt;/p&gt;
&lt;h3 id=&quot;怎么实现公平和非公平锁？&quot;&gt;&lt;a href=&quot;#怎么实现公平和非公平锁？&quot; class=&quot;headerlink&quot; title=&quot;怎么实现公平和非公平锁？&quot;&gt;&lt;/a&gt;怎么实现公平和非公平锁？&lt;/h3&gt;&lt;p&gt;公平锁可以把竞争的线程放在一个先进先出的队列上&lt;/p&gt;
&lt;p&gt;只要持有锁的线程执行完了，唤醒队列的下一个线程去获取锁就好了&lt;/p&gt;
&lt;p&gt;非公平锁的概念上面已经提到了：后到的线程可能比前到临界区的线程获取得到锁&lt;/p&gt;
&lt;p&gt;那实现也很简单，线程先尝试能不能获取得到锁，如果获取得到锁了就执行同步代码了&lt;/p&gt;
&lt;p&gt;如果获取不到锁，那就再把这个线程放到队列呗&lt;/p&gt;
&lt;p&gt;所以公平和非公平的区别就是：线程执行同步代码块时，是否会去尝试获取锁。&lt;/p&gt;
&lt;p&gt;如果会尝试获取锁，那就是非公平的。如果不会尝试获取锁，直接进队列，再等待唤醒，那就是公平的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-BeanFactory</title>
    <link href="https://swzxsyh.github.io/2022/07/08/Spring-BeanFactory/"/>
    <id>https://swzxsyh.github.io/2022/07/08/Spring-BeanFactory/</id>
    <published>2022-07-07T16:40:14.000Z</published>
    <updated>2022-07-14T17:25:49.415Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-IOC-BeanFactory&quot;&gt;&lt;a href=&quot;#Spring-IOC-BeanFactory&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC BeanFactory&quot;&gt;&lt;/a&gt;Spring IOC BeanFactory&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/07/08/Spring-BeanFactory/BeanFactory.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-三级缓存</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Spring-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Spring-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-07T11:35:42.000Z</published>
    <updated>2022-07-14T17:25:49.437Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-三级缓存&quot;&gt;&lt;a href=&quot;#Spring-三级缓存&quot; class=&quot;headerlink&quot; title=&quot;Spring 三级缓存&quot;&gt;&lt;/a&gt;Spring 三级缓存&lt;/h1&gt;&lt;p&gt;Spring的三级缓存解决循环依赖问题&lt;/p&gt;
&lt;p&gt;org.springframework.beans.factory.support.DefaultSingletonBeanRegistry&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Cache of singleton objects: bean name to bean instance. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonObjects = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConcurrentHashMap&lt;/span&gt;&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//二级缓存，提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Cache of early singleton objects: bean name to bean instance. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConcurrentHashMap&lt;/span&gt;&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//三级缓存，单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Cache of singleton factories: bean name to ObjectFactory. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;&lt;img src=&quot;/2022/07/07/Spring-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/Spring.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-生命周期</title>
    <link href="https://swzxsyh.github.io/2022/07/07/SpringBoot-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://swzxsyh.github.io/2022/07/07/SpringBoot-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-07-07T11:34:50.000Z</published>
    <updated>2022-07-14T17:25:49.492Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot-生命周期&quot;&gt;&lt;a href=&quot;#SpringBoot-生命周期&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 生命周期&quot;&gt;&lt;/a&gt;SpringBoot 生命周期&lt;/h1&gt;&lt;p&gt;SpringBoot应用的生命周期，整体上可以分为SpringApplication初始化阶段、SpringApplication运行阶段、SpringApplication结束阶段、SpringBoot应用退出四个阶段。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-Bean生命周期</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-07-07T11:33:49.000Z</published>
    <updated>2022-07-14T17:25:49.423Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Bean生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean生命周期&quot;&gt;&lt;/a&gt;Spring Bean生命周期&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/07/07/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat-为什么要JAVA破坏双亲委派机制</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Tomcat-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81JAVA%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Tomcat-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81JAVA%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2022-07-07T09:22:30.000Z</published>
    <updated>2022-07-14T17:25:49.568Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Tomcat-为什么要JAVA破坏双亲委派机制&quot;&gt;&lt;a href=&quot;#Tomcat-为什么要JAVA破坏双亲委派机制&quot; class=&quot;headerlink&quot; title=&quot;Tomcat-为什么要JAVA破坏双亲委派机制&quot;&gt;&lt;/a&gt;Tomcat-为什么要JAVA破坏双亲委派机制&lt;/h1&gt;&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tomcat本身也是一个Web应用程序&lt;/li&gt;
&lt;li&gt;不同Web程序依赖不同，向上查询时可能导致依赖版本异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打破双亲的机制，每个应用独立classloader其实自己做到隔离机制&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别</title>
    <link href="https://swzxsyh.github.io/2022/07/07/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://swzxsyh.github.io/2022/07/07/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-07-06T17:54:49.000Z</published>
    <updated>2022-07-14T17:25:49.567Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="https://swzxsyh.github.io/2022/07/07/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://swzxsyh.github.io/2022/07/07/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-07-06T17:54:41.000Z</published>
    <updated>2022-07-14T17:25:49.576Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>wait和sleep的区别</title>
    <link href="https://swzxsyh.github.io/2022/07/07/wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://swzxsyh.github.io/2022/07/07/wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-07-06T17:54:32.000Z</published>
    <updated>2022-07-14T17:25:49.576Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Synchronized和Lock的区别</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-07-06T17:54:21.000Z</published>
    <updated>2022-07-14T17:25:49.568Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat-组件</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Tomcat-%E7%BB%84%E4%BB%B6/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Tomcat-%E7%BB%84%E4%BB%B6/</id>
    <published>2022-07-06T17:41:37.000Z</published>
    <updated>2022-07-14T17:25:49.571Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat-责任链</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Tomcat-%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Tomcat-%E8%B4%A3%E4%BB%BB%E9%93%BE/</id>
    <published>2022-07-06T17:41:26.000Z</published>
    <updated>2022-07-14T17:25:49.573Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat-类加载器</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Tomcat-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Tomcat-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2022-07-06T17:41:12.000Z</published>
    <updated>2022-07-14T17:25:49.570Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-总述</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Spring-%E6%80%BB%E8%BF%B0/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Spring-%E6%80%BB%E8%BF%B0/</id>
    <published>2022-07-06T17:16:53.000Z</published>
    <updated>2022-07-14T17:25:49.476Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-总述&quot;&gt;&lt;a href=&quot;#Spring-总述&quot; class=&quot;headerlink&quot; title=&quot;Spring-总述&quot;&gt;&lt;/a&gt;Spring-总述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/07/07/Spring-%E6%80%BB%E8%BF%B0/Spring-ALL.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-PostProcessor &amp;&amp; Aware</title>
    <link href="https://swzxsyh.github.io/2022/07/07/Spring-PostProcessor-Aware/"/>
    <id>https://swzxsyh.github.io/2022/07/07/Spring-PostProcessor-Aware/</id>
    <published>2022-07-06T17:14:45.000Z</published>
    <updated>2022-07-14T17:25:49.436Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
</feed>
