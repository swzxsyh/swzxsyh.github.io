<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java面试题 Specification Java Spring MQ Cache Database ES Network Tools Theory">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题收集">
<meta property="og:url" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:description" content="Java面试题 Specification Java Spring MQ Cache Database ES Network Tools Theory">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/fa697f963b38ee9ec2fd535a41ad25d9.png">
<meta property="og:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png">
<meta property="article:published_time" content="2023-02-11T22:05:05.000Z">
<meta property="article:modified_time" content="2023-02-28T20:38:54.450Z">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/fa697f963b38ee9ec2fd535a41ad25d9.png">

<link rel="canonical" href="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试题收集 | swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题收集
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-12 06:05:05" itemprop="dateCreated datePublished" datetime="2023-02-12T06:05:05+08:00">2023-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-01 04:38:54" itemprop="dateModified" datetime="2023-03-01T04:38:54+08:00">2023-03-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><ul>
<li>Specification</li>
<li>Java</li>
<li>Spring</li>
<li>MQ</li>
<li>Cache</li>
<li>Database</li>
<li>ES</li>
<li>Network</li>
<li>Tools</li>
<li>Theory</li>
</ul>
<span id="more"></span>


<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h4 id="设计模式有哪些原则"><a href="#设计模式有哪些原则" class="headerlink" title="设计模式有哪些原则"></a>设计模式有哪些原则</h4><ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转(倒置)原则</li>
<li>里氏替换原则</li>
<li>开闭原则（OCP）</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ul>
<h4 id="设计模式理解"><a href="#设计模式理解" class="headerlink" title="设计模式理解"></a>设计模式理解</h4><ul>
<li>对软件设计的解决方案</li>
<li>提高拓展性</li>
<li>通过模式名称快速沟通相关问题</li>
</ul>
<h4 id="编程规范理解"><a href="#编程规范理解" class="headerlink" title="编程规范理解"></a>编程规范理解</h4><ul>
<li>利于共同开发</li>
<li>降低Bug与维护成本</li>
<li>利于Code Review</li>
</ul>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><h3 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h3><h4 id="买卖股票的最佳时机（leecode121）"><a href="#买卖股票的最佳时机（leecode121）" class="headerlink" title="买卖股票的最佳时机（leecode121）"></a>买卖股票的最佳时机（leecode121）</h4><ul>
<li><p>贪心算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) &lt; prices.length &amp;&amp; prices[i + <span class="number">1</span>] &gt; minPrice) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i + <span class="number">1</span>] - minPrice &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[i + <span class="number">1</span>] - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h4><ul>
<li><p>贪心算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currentProfit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; prices.length &amp;&amp; prices[i] &lt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            currentProfit = -prices[i] + prices[i + <span class="number">1</span>];</span><br><span class="line">            maxProfit += currentProfit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="合并两个有序链表-LeetCode-21"><a href="#合并两个有序链表-LeetCode-21" class="headerlink" title="合并两个有序链表(LeetCode 21)"></a>合并两个有序链表(LeetCode 21)</h4><h4 id="单链表反转-LeetCode-206"><a href="#单链表反转-LeetCode-206" class="headerlink" title="单链表反转(LeetCode 206)"></a>单链表反转(LeetCode 206)</h4><h3 id="Middle"><a href="#Middle" class="headerlink" title="Middle"></a>Middle</h3><h4 id="最大数-LeetCode179"><a href="#最大数-LeetCode179" class="headerlink" title="最大数(LeetCode179)"></a>最大数(LeetCode179)</h4><ul>
<li><p>重点方法：自定义比较器Comparator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  </span><br><span class="line">    Arrays.stream(nums).mapToObj(String::valueOf).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> o1 + o2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> o2 + o1;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> str2.compareTo(str1);</span><br><span class="line">    &#125;).map(sb::append).collect(Collectors.joining());</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sb.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="版本号比较-LeetCode-165"><a href="#版本号比较-LeetCode-165" class="headerlink" title="版本号比较(LeetCode 165)"></a>版本号比较(LeetCode 165)</h4><ul>
<li>&#96;&#96;&#96;java<br>public int compareVersion(String version1, String version2) {<br>  String[] splitV1 &#x3D; version1.split(“\.”);<br>  String[] splitV2 &#x3D; version2.split(“\.”);<br><br>  if (splitV1.length &#x3D;&#x3D; splitV2.length) {<br>      for (int i &#x3D; 0; i &lt; splitV1.length; i++) {<br>          if (Integer.parseInt(splitV1[i]) &gt; Integer.parseInt(splitV2[i])) {<br>              return 1;<br>          }<br>          if (Integer.parseInt(splitV1[i]) &lt; Integer.parseInt(splitV2[i])) {<br>              return -1;<br>          }<br>      }<br>      return 0;<br>  }<br><br><br>  int shortLength &#x3D; Math.min(splitV1.length, splitV2.length);<br><br>  StringBuilder sbV1 &#x3D; new StringBuilder();<br>  StringBuilder sbV2 &#x3D; new StringBuilder();<br>  for (int i &#x3D; 0; i &lt; shortLength; i++) {<br>      sbV1.append(Integer.valueOf(splitV1[i]));<br>      sbV2.append(Integer.valueOf(splitV2[i]));<br>  }<br><br>  int result &#x3D; sbV1.toString().compareTo(sbV2.toString());<br>  if (result &#x3D;&#x3D; 0) {<br>      if (splitV1.length &#x3D;&#x3D; shortLength) {<br>          for (int i &#x3D; shortLength; i &lt; splitV2.length; i++) {<br>              if (Integer.parseInt(splitV2[i]) &gt; 0) {<br>                  return -1;<br>              }<br>          }<br>      }<br>      for (int i &#x3D; shortLength; i &lt; splitV1.length; i++) {<br>          if (Integer.parseInt(splitV1[i]) &gt; 0) {<br>              return 1;<br>          }<br>      }<br>  }<br>  return result;<br>  }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 字符串消消乐</span><br><span class="line"></span><br><span class="line">TODO</span><br><span class="line"></span><br><span class="line">#### 链表如何快速查找到两个相关的值</span><br><span class="line"></span><br><span class="line">#### 二叉树中序遍历</span><br><span class="line"></span><br><span class="line">#### 输出一个二叉树的宽度(LeetCode 102)</span><br><span class="line"></span><br><span class="line">#### 阿拉伯数字转汉字</span><br><span class="line"></span><br><span class="line">#### 字符串的全排列</span><br><span class="line"></span><br><span class="line">#### 最长上升子序列(LeetCode 300 DP)</span><br><span class="line"></span><br><span class="line">#### 有序列表，找出所有两数之和为10000的组合</span><br><span class="line"></span><br><span class="line">#### 链表倒数第N个节点算法</span><br><span class="line"></span><br><span class="line">#### 单链表奇数节点移动到最前面</span><br><span class="line"></span><br><span class="line">#### 组合（LeetCode 77）</span><br><span class="line"></span><br><span class="line">#### BFS与DFS区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 二分查找</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Java如何实现一个阻塞队列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 手写HashMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### IPv4转数字，只能用int类型</span><br><span class="line"></span><br><span class="line">- IPv4地址是由四个8位二进制数组成，可以将它们转换成一个32位的无符号整数来表示。IPv4地址的每个分量都可以用8位二进制数表示，这个二进制数转换为10进制整数即为IPv4地址分量的值。可以将每个分量的值左移位运算8、16、24位后相加，得到一个32位整数表示IPv4地址。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">    public void ipv4ToIntTest() &#123;</span><br><span class="line">        String ipAddr = &quot;192.168.50.236&quot;;</span><br><span class="line">        String[] ip = ipAddr.split(&quot;\\.&quot;);</span><br><span class="line">        int result = (Integer.parseInt(ip[0]) &lt;&lt; 24) | (Integer.parseInt(ip[1]) &lt;&lt; 16) |</span><br><span class="line">                (Integer.parseInt(ip[2]) &lt;&lt; 8) | Integer.parseInt(ip[3]);</span><br><span class="line">        log.info(&quot;result: &#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="什么是红黑树？和其他树有什么区别？"><a href="#什么是红黑树？和其他树有什么区别？" class="headerlink" title="什么是红黑树？和其他树有什么区别？"></a>什么是红黑树？和其他树有什么区别？</h4><h4 id="计算机内存管理"><a href="#计算机内存管理" class="headerlink" title="计算机内存管理"></a>计算机内存管理</h4><h2 id="Java-相关"><a href="#Java-相关" class="headerlink" title="Java 相关"></a>Java 相关</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h4><ul>
<li>long short int double float char byte boolean</li>
</ul>
<h4 id="float如何判断是否为0"><a href="#float如何判断是否为0" class="headerlink" title="float如何判断是否为0"></a>float如何判断是否为0</h4><ul>
<li>IEEE754 ，0.00000f&lt;1e-6</li>
</ul>
<h4 id="Java包装类型理解"><a href="#Java包装类型理解" class="headerlink" title="Java包装类型理解"></a>Java包装类型理解</h4><ul>
<li>对于基本类型的包装</li>
<li>存储位置不同<ul>
<li>包装类型存储于堆，通过地址引用</li>
<li>基本类型根据不同方法存放不同位置<ul>
<li>方法-栈帧局部变量表</li>
<li>类成员变量-栈</li>
<li>静态变量&#x2F;常量-方法区</li>
</ul>
</li>
</ul>
</li>
<li>包装类默认值为Null值，基本类型不能为null</li>
<li>OOP思想</li>
</ul>
<h4 id="Java面向对象特征"><a href="#Java面向对象特征" class="headerlink" title="Java面向对象特征"></a>Java面向对象特征</h4><ul>
<li>封装，继承，多态</li>
</ul>
<h4 id="接口能不能实现接口"><a href="#接口能不能实现接口" class="headerlink" title="接口能不能实现接口"></a>接口能不能实现接口</h4><ul>
<li>不能，只能继承</li>
</ul>
<h4 id="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么？"><a href="#抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么？" class="headerlink" title="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？"></a>抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？</h4><ul>
<li><p>抽象类和接口的区别</p>
<ul>
<li>一个类只能继承一个抽象类（单继承），却能实现多接口（多实现）</li>
<li>抽象类可以有定义和实现，接口原本只有定义，JDK1.8后可以default实现</li>
<li>接口强调特定功能实现，抽象类强调所属关系</li>
<li>接口成员变量默认public static final，必须赋值且不能修改，所有成员方法都是public、abstract的。抽象类变量默认default，可在自类被重新定义，也可以被重新赋值。</li>
</ul>
</li>
<li><p>类可以继承多个类么</p>
<p>不可以</p>
</li>
<li><p>接口可以继承多个接口么</p>
<p>可以</p>
</li>
<li><p>类可以实现多个接口么</p>
<p>可以</p>
</li>
</ul>
<h4 id="为什么重写Equals一定也要重写HashCode"><a href="#为什么重写Equals一定也要重写HashCode" class="headerlink" title="为什么重写Equals一定也要重写HashCode"></a>为什么重写Equals一定也要重写HashCode</h4><ul>
<li>自定义对象要比较时，先比较hashCode再比较equals，hashCode保证性能，equals保证可靠性</li>
<li>从Object继承的这两个方法都是<code>比较内存地址</code>，如果不重写HashCode，自定义的两个对象内存地址肯定不一样导致比较失效，Equals比较同理，Object比较也是<code>内存地址</code>，也会导致比较失效。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61307537">https://zhuanlan.zhihu.com/p/61307537</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024478811">https://segmentfault.com/a/1190000024478811</a></li>
</ul>
<h4 id="对一个数异或两次等于没有异或"><a href="#对一个数异或两次等于没有异或" class="headerlink" title="对一个数异或两次等于没有异或"></a>对一个数异或两次等于没有异或</h4><ul>
<li><p>异或是一种按位逻辑韵味，规则为：两个二进制位相同则结果为0，不同则为1</p>
</li>
<li><p>异或满足交换律和结合律，因此对一个数异或异或两次没有异或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = x ^ y <span class="comment">// (a ^ b, b)</span></span><br><span class="line">y = x ^ y <span class="comment">// (a ^ b, a ^ b ^ b) =&gt; (a ^ b, a)</span></span><br><span class="line">x = x ^ y <span class="comment">// (a ^ b ^ a, a) =&gt; (b, a)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="float在内存中怎么表示"><a href="#float在内存中怎么表示" class="headerlink" title="float在内存中怎么表示"></a>float在内存中怎么表示</h4><ul>
<li>s | eeeeeeee | mmm mmmm mmmm mmmm mmmm mmmm</li>
<li>符号位：31位，符号0为负，1为正</li>
<li>指数位：23-30位，用8位存储指数部分</li>
<li>尾数位：0-22位，存储小数部分</li>
</ul>
<h4 id="数组动态分配内存如何实现"><a href="#数组动态分配内存如何实现" class="headerlink" title="数组动态分配内存如何实现"></a>数组动态分配内存如何实现</h4><ul>
<li>Java中动态数组分配内存是通过JVM中的Heap实现的。</li>
<li>Java数组是一种固定长度的数据结构，因此分配动态数组的实现方式是创建一个新的更大的数组，将原数组数据复制System.arraycopy()，并释放原数组空间。</li>
<li>频繁操作会导致性能问题，应尽量避免数组扩容</li>
</ul>
<h4 id="如何防止非原子操作的冲突问题"><a href="#如何防止非原子操作的冲突问题" class="headerlink" title="如何防止非原子操作的冲突问题"></a>如何防止非原子操作的冲突问题</h4><ul>
<li>使用synchronized关键字，避免并发到这数据冲突</li>
<li>使用ReentrantLock</li>
<li>使用Atomic包</li>
<li>使用ThreadLocal</li>
<li>使用JUC并发容器</li>
</ul>
<h4 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h4><ul>
<li>最优二叉树，是一种带权路径长度最短的树，常用于数据压缩中的编码和解码</li>
<li>每个叶子节点对应着一个权值，而每个非叶子节点对应着一个权值之和。哈夫曼编码则是将字符映射为哈夫曼树中对应的叶子节点的路径，路径的方向为从根节点到叶子节点的方向。由于哈夫曼树的带权路径长度最短，所以哈夫曼编码也是一种最优编码方式，能够实现高效的数据压缩。</li>
</ul>
<h4 id="Object-常用方法及每个方法的大致含义"><a href="#Object-常用方法及每个方法的大致含义" class="headerlink" title="Object 常用方法及每个方法的大致含义"></a>Object 常用方法及每个方法的大致含义</h4><ul>
<li><p>Object.equals()</p>
<p>判断对象hashCode是否相同</p>
</li>
<li><p>Object.wait()</p>
<p>线程停止</p>
</li>
<li><p>Object.toString()</p>
<p>将对象转换为字符串</p>
</li>
</ul>
<h4 id="在JDK1-5中引入了泛型，泛型的存在是用来解决什么问题"><a href="#在JDK1-5中引入了泛型，泛型的存在是用来解决什么问题" class="headerlink" title="在JDK1.5中引入了泛型，泛型的存在是用来解决什么问题"></a>在JDK1.5中引入了泛型，泛型的存在是用来解决什么问题</h4><ul>
<li><strong>泛型主要针对向下转型时所带来的安全隐患，其核心组成是在声明类或接口时，不设置参数或属性的类型</strong></li>
<li><strong>第一是泛化。</strong>可以用T代表任意类型Java语言中引入泛型是一个较大的功能增强不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了，这带来了很多好处。</li>
<li><strong>第二是类型安全。</strong>泛型的一个主要目标就是提高ava程序的类型安全，使用泛型可以使编译器知道变量的类型限制，进而可以在更高程度上验证类型假设。如果不用泛型，则必须使用强制类型转换，而强制类型转换不安全，在运行期可能发生ClassCast Exception异常，如果使用泛型，则会在编译期就能发现该错误。<strong>第三是消除强制类型转换。</strong>泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错</li>
<li>的机会。</li>
<li><strong>第四是向后兼容。</strong>支持泛型的Java编译器（例如JDK1.5中的Javac）可以用来编译经过泛型扩充的Java程序（Generics Java程序），但是现有的没有使用泛型扩充的Java程序仍然可以用这些编译器来编译。</li>
<li>JAVA 泛型只存在于编译时期，在运行时期会被擦除</li>
</ul>
<h4 id="有没有可能2个不相等的对象有相同的hashcode"><a href="#有没有可能2个不相等的对象有相同的hashcode" class="headerlink" title="有没有可能2个不相等的对象有相同的hashcode"></a>有没有可能2个不相等的对象有相同的hashcode</h4><ul>
<li><p>有，Hash冲突</p>
</li>
<li><p>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入</p>
</li>
<li><p>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突.</p>
</li>
</ul>
<h4 id="举例几个树形结构"><a href="#举例几个树形结构" class="headerlink" title="举例几个树形结构"></a>举例几个树形结构</h4><ul>
<li>B+Tree，MySQL</li>
<li>红黑树，HashMap</li>
</ul>
<h4 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h4><ul>
<li>Error 一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。仅靠程序本身无法恢复</li>
<li>Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</li>
</ul>
<h4 id="你知道什么是指令重排序？为什么要重排序？"><a href="#你知道什么是指令重排序？为什么要重排序？" class="headerlink" title="你知道什么是指令重排序？为什么要重排序？"></a>你知道什么是指令重排序？为什么要重排序？</h4><ul>
<li>指令重排序是指源码顺序和程序顺序不一样，或者说程序顺序和执行的顺序不一致，重排序的对象是指令。 指令重排序是编译器处于性能考虑，在不影响程序（单线程程序） 指令重排序不是必然发生的，指令重排序会导致线程安全问题。</li>
<li>volatile（引申Singleton Pattern为什么使用）</li>
</ul>
<h4 id="Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同"><a href="#Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同" class="headerlink" title="Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同"></a>Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同</h4><ul>
<li><p>Java中的volatile关键是什么作用</p>
<p>多线程环境下，保证共享变量的可见性，当一个线程修改共享变量的值，其他线程可以立即看到，其他线程回去主内存重新读取该变量的值，避免数据不一致问题。</p>
<p>禁止指令重排序，保证多线程环境下，共享变量的读写是有序的</p>
</li>
<li><p>在Java中它跟synchronized方法有什么不同</p>
<p>volatile可以保证可见性和有序性，不能保证原子性。</p>
<p>synchronized可以保证可见效，有序性和原子性</p>
</li>
</ul>
<h4 id="Overload、Override、Overwrite的区别"><a href="#Overload、Override、Overwrite的区别" class="headerlink" title="Overload、Override、Overwrite的区别"></a>Overload、Override、Overwrite的区别</h4><ul>
<li>overload意为重载，同一个类中，存在多个方法名相同的函数，但是他们拥有不同的参数</li>
<li>override意为覆盖，针对父类，实现类而言，参数名称相同，方法不同</li>
<li>overwrite意为重写，Java没有</li>
</ul>
<h4 id="什么是浅拷贝和深拷贝"><a href="#什么是浅拷贝和深拷贝" class="headerlink" title="什么是浅拷贝和深拷贝"></a>什么是浅拷贝和深拷贝</h4><ul>
<li>浅拷贝只是增加了一个指针指向已经存在的内存</li>
<li>深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。</li>
<li>浅拷贝更改数据会变更原数据</li>
</ul>
<h4 id="什么是不可变对象，它对写并发应用有什么帮助"><a href="#什么是不可变对象，它对写并发应用有什么帮助" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助"></a>什么是不可变对象，它对写并发应用有什么帮助</h4><ul>
<li>一旦创建及无法被修改的对象称为不可变对象。</li>
<li>并发应用的帮助<ul>
<li>多线程下不会出现线程同步问题，不需要担心数据被其他线程修改</li>
<li>可以作为Map的Key 和Set元素</li>
<li>但由于不可变，因此每次创建一个不同的对象都会产生一个新对象</li>
</ul>
</li>
</ul>
<h4 id="如何创建不可变的类？"><a href="#如何创建不可变的类？" class="headerlink" title="如何创建不可变的类？"></a>如何创建不可变的类？</h4><ul>
<li>private + final修饰</li>
<li>不暴露改变成员变量的方法，如setter</li>
<li>通过构造器初始化所有成员，进行深拷贝(this.myArray &#x3D; array.clone())</li>
<li>getter方法中，不要返回对象本身，而是返回clone对象</li>
</ul>
<h4 id="String能不能有子类，为什么-String-被设计为是不可变的？"><a href="#String能不能有子类，为什么-String-被设计为是不可变的？" class="headerlink" title="String能不能有子类，为什么 String 被设计为是不可变的？"></a>String能不能有子类，为什么 String 被设计为是不可变的？</h4><ul>
<li><p>String能不能有子类</p>
<p>不能，public final class String</p>
<p>JDK 1.8 本质是final char value[]，JDK 1.9 本质是 final byte[] value;</p>
<p>实际可以通过反射变更array</p>
</li>
<li><p>为什么 String 被设计为是不可变的</p>
<p>线程安全，不可变对象一定是线程安全的</p>
<p>字符串常量池，节约空间</p>
<p>Hash Code 唯一性，JVM直接缓存HashCode，对于HashMap类引用查找速度快</p>
</li>
</ul>
<h4 id="描述动态代理的几种实现方式，分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式，分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式，分别说出相应的优缺点"></a>描述动态代理的几种实现方式，分别说出相应的优缺点</h4><ul>
<li>JDKProxy<ul>
<li>JDK自带</li>
<li>只能代理接口</li>
</ul>
</li>
<li>CGLibProxy<ul>
<li>第三方类，通过继承的方法进行代理</li>
<li>可以代理类和方法，不能代理final类和final方法</li>
</ul>
</li>
<li><a href="https://swzxsyh.github.io/2022/07/05/Spring-AOP/">Spring-AOP | swzxsyh</a></li>
</ul>
<h4 id="JAVA实现反射的两种方式？为什么要这样设计？"><a href="#JAVA实现反射的两种方式？为什么要这样设计？" class="headerlink" title="JAVA实现反射的两种方式？为什么要这样设计？"></a>JAVA实现反射的两种方式？为什么要这样设计？</h4><h4 id="JAVA的反射机制"><a href="#JAVA的反射机制" class="headerlink" title="JAVA的反射机制"></a>JAVA的反射机制</h4><h4 id="怎么保证幂等"><a href="#怎么保证幂等" class="headerlink" title="怎么保证幂等"></a>怎么保证幂等</h4><h4 id="什么是原子操作，Java中的原子操作是什么"><a href="#什么是原子操作，Java中的原子操作是什么" class="headerlink" title="什么是原子操作，Java中的原子操作是什么"></a>什么是原子操作，Java中的原子操作是什么</h4><h4 id="如何同步一个原子操作"><a href="#如何同步一个原子操作" class="headerlink" title="如何同步一个原子操作"></a>如何同步一个原子操作</h4><h3 id="List-amp-amp-Map-相关"><a href="#List-amp-amp-Map-相关" class="headerlink" title="List &amp;&amp; Map 相关"></a>List &amp;&amp; Map 相关</h3><h4 id="Java集合理解，Map的理解，HashMap关键属性"><a href="#Java集合理解，Map的理解，HashMap关键属性" class="headerlink" title="Java集合理解，Map的理解，HashMap关键属性"></a>Java集合理解，Map的理解，HashMap关键属性</h4><ul>
<li><p>Java集合</p>
<ul>
<li><p>即容器，一个是Collection接口，存放单一元素，另一个是Map接口，存储键值对。</p>
</li>
<li><p>Collection接口下存在Set、List、Queue三大子接口</p>
<ul>
<li><p>List</p>
<ul>
<li><p><code>ArrayList</code>： <code>Object[]</code> 数组</p>
</li>
<li><p><code>Vector</code>：<code>Object[]</code> 数组</p>
</li>
<li><p><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</p>
</li>
<li><p><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</p>
</li>
<li><p><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</p>
</li>
</ul>
</li>
<li><p>Queue</p>
<ul>
<li><p><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</p>
</li>
<li><p><code>ArrayQueue</code>（Dqueue子接口再实现）: <code>Object[]</code> 数组 + 双指针</p>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
</ul>
</li>
<li><p>List: 可存储有序重复的元素</p>
</li>
<li><p>Set: 存储无序不可重复元素</p>
</li>
<li><p>Queue: 按特定规则确定顺序，存储的元素有序可重复</p>
</li>
<li><p>Map: 使用K-V存储，Key无序不可重复，Value无序，可重复，每个Key正常情况下最多映射一个值</p>
</li>
</ul>
</li>
<li><p>HashMap关键属性</p>
<ul>
<li><p>java.util.HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放临界值的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放数组个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"><span class="comment">//临界值，当大小超过时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子，如果增大，空间利用率提高，但是碰撞概率也加大，链表长度增常，降低查找效率</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="用过哪些Map类，都有什么区别，HashMap是线程安全的吗"><a href="#用过哪些Map类，都有什么区别，HashMap是线程安全的吗" class="headerlink" title="用过哪些Map类，都有什么区别，HashMap是线程安全的吗"></a>用过哪些Map类，都有什么区别，HashMap是线程安全的吗</h4><ul>
<li>用过哪些Map类<ul>
<li>ConcurrentHashMap线程安全，K-V 设定为@Nullable。数组+链表+红黑树</li>
<li>LinkedHashMap记录插入顺序</li>
<li>TreeMap根据Key排序</li>
</ul>
</li>
<li>HashMap是线程安全的吗<ul>
<li>不是,HashMap不支持线程的同步</li>
</ul>
</li>
</ul>
<h4 id="HashMap初始化容量1W，存1W个是否会扩容"><a href="#HashMap初始化容量1W，存1W个是否会扩容" class="headerlink" title="HashMap初始化容量1W，存1W个是否会扩容"></a>HashMap初始化容量1W，存1W个是否会扩容</h4><ul>
<li><p>当数值为1W时，不会扩容，但如果是1000，则会进行扩容</p>
</li>
<li><p>HashMap会调用tableSizeFor方法进行运算，运算 result * 0.75 是初始化的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前方法存在命名不规范问题</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tableSizeFor</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">double</span> <span class="variable">loadFactor</span> <span class="operator">=</span> <span class="number">0.75</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cap_1K</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cap_1W</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Method</span> <span class="variable">tableSizeFor</span> <span class="operator">=</span> HashMap.class.getDeclaredMethod(<span class="string">&quot;tableSizeFor&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">      tableSizeFor.setAccessible(Boolean.TRUE);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result_1K</span> <span class="operator">=</span> (<span class="type">int</span>) tableSizeFor.invoke(<span class="literal">null</span>, cap_1K);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result_1W</span> <span class="operator">=</span> (<span class="type">int</span>) tableSizeFor.invoke(<span class="literal">null</span>, cap_1W);</span><br><span class="line">      System.out.println(<span class="string">&quot;tableSizeFor 1000 result: &quot;</span> + result_1K);</span><br><span class="line">      System.out.println(<span class="string">&quot;tableSizeFor 10000 result: &quot;</span> + result_1W + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">finalSize_1K</span> <span class="operator">=</span> (<span class="type">int</span>) (result_1K * loadFactor);</span><br><span class="line">      <span class="type">int</span> <span class="variable">finalSize_1W</span> <span class="operator">=</span> (<span class="type">int</span>) (result_1W * loadFactor);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;finalSize 1000 result: &quot;</span> + finalSize_1K);</span><br><span class="line">      System.out.println(<span class="string">&quot;finalSize 10000 result: &quot;</span> + finalSize_1W);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor 1000 result: 1024</span></span><br><span class="line"><span class="comment">//tableSizeFor 10000 result: 16384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//finalSize 1000 result: 768</span></span><br><span class="line"><span class="comment">//finalSize 10000 result: 12288</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="解决Hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决Hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决Hash冲突的办法有哪些？HashMap用的哪种？"></a>解决Hash冲突的办法有哪些？HashMap用的哪种？</h4><ul>
<li>解决Hash冲突的办法有哪些<ul>
<li>开放地址法：被占用就找下一个位置。下一个位置的方案有 线性探测再散列，平方探测再散列，随机探测再散列<ul>
<li>线性探测再散列：发生冲突时，顺序查看哈希表下一单元是否可用，直到找到可用的单元</li>
<li>二次探测再散列：发生冲突时，以冲突的位置为中心向左右探测是否有可用单元</li>
<li>伪随机探测再散列：通过一组伪随机数列计算得到对应的单位位置</li>
</ul>
</li>
<li>链地址法：Hash相同的放在一个新的同义词链的链表里，链头指针放到Value位置</li>
<li>再散列：运用多个Hash函数，冲突时使用其他函数运算值</li>
<li>建立公共溢出区：将Hash表分为基本表和溢出表，发生冲突的全放入溢出表</li>
</ul>
</li>
<li>HashMap用的哪种<ul>
<li>链地址法</li>
</ul>
</li>
</ul>
<h4 id="HashMap如何通过K-V管理数据"><a href="#HashMap如何通过K-V管理数据" class="headerlink" title="HashMap如何通过K-V管理数据"></a>HashMap如何通过K-V管理数据</h4><h4 id="HashMap为什么选择2的倍数当作容量"><a href="#HashMap为什么选择2的倍数当作容量" class="headerlink" title="HashMap为什么选择2的倍数当作容量"></a>HashMap为什么选择2的倍数当作容量</h4><ul>
<li><p>扩容时位运算效率高</p>
</li>
<li><p><code>key.hashCode() &amp;  (容量-1)</code>  碰撞概率降低</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/422840340">https://www.zhihu.com/question/422840340</a></p>
</li>
</ul>
<h4 id="HashMap初始为什么16"><a href="#HashMap初始为什么16" class="headerlink" title="HashMap初始为什么16"></a>HashMap初始为什么16</h4><ul>
<li>JDK 没有给出理由，可能是位运算方便，且16更通用于业务</li>
</ul>
<h4 id="HashMap因子为什么是0-75"><a href="#HashMap因子为什么是0-75" class="headerlink" title="HashMap因子为什么是0.75"></a>HashMap因子为什么是0.75</h4><ul>
<li><p>可能与泊松分布相关。过小容易增加扩容概率，过大容易增加碰撞概率，0.75属于经验中间值，提高利用率且降低冲突。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023308658">https://segmentfault.com/a/1190000023308658</a></p>
</li>
</ul>
<h4 id="HashMap扩容后如何再散列"><a href="#HashMap扩容后如何再散列" class="headerlink" title="HashMap扩容后如何再散列"></a>HashMap扩容后如何再散列</h4><h4 id="HashMap在Java-7-为什么会进入死循环"><a href="#HashMap在Java-7-为什么会进入死循环" class="headerlink" title="HashMap在Java 7 为什么会进入死循环"></a>HashMap在Java 7 为什么会进入死循环</h4><ul>
<li>JDK 1.7 使用头插法，头插法+链表+多线程+HashMap扩容可能导致死循环</li>
</ul>
<h4 id="HashMap在Java内部是如何工作的"><a href="#HashMap在Java内部是如何工作的" class="headerlink" title="HashMap在Java内部是如何工作的"></a>HashMap在Java内部是如何工作的</h4><h4 id="HashMap为什么要在存储量变更时切换结构，如何切换"><a href="#HashMap为什么要在存储量变更时切换结构，如何切换" class="headerlink" title="HashMap为什么要在存储量变更时切换结构，如何切换"></a>HashMap为什么要在存储量变更时切换结构，如何切换</h4><h4 id="ConcurrentHashMap如何解决安全问题"><a href="#ConcurrentHashMap如何解决安全问题" class="headerlink" title="ConcurrentHashMap如何解决安全问题"></a>ConcurrentHashMap如何解决安全问题</h4><h4 id="ConcurrentHashMap为什么在Java-8放弃了分段锁"><a href="#ConcurrentHashMap为什么在Java-8放弃了分段锁" class="headerlink" title="ConcurrentHashMap为什么在Java 8放弃了分段锁"></a>ConcurrentHashMap为什么在Java 8放弃了分段锁</h4><h4 id="ConcurrentHashMap在Java-7性能问题"><a href="#ConcurrentHashMap在Java-7性能问题" class="headerlink" title="ConcurrentHashMap在Java 7性能问题"></a>ConcurrentHashMap在Java 7性能问题</h4><h4 id="什么是阻塞队列？你知道Java中有哪些阻塞队列吗？"><a href="#什么是阻塞队列？你知道Java中有哪些阻塞队列吗？" class="headerlink" title="什么是阻塞队列？你知道Java中有哪些阻塞队列吗？"></a>什么是阻塞队列？你知道Java中有哪些阻塞队列吗？</h4><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><h4 id="用Java写代码来解决生产者——消费者问题"><a href="#用Java写代码来解决生产者——消费者问题" class="headerlink" title="用Java写代码来解决生产者——消费者问题"></a>用Java写代码来解决生产者——消费者问题</h4><h3 id="Thread-amp-amp-Lock-相关"><a href="#Thread-amp-amp-Lock-相关" class="headerlink" title="Thread &amp;&amp; Lock 相关"></a>Thread &amp;&amp; Lock 相关</h3><h4 id="进程和线程的区别，使用线程真的能节省时间吗"><a href="#进程和线程的区别，使用线程真的能节省时间吗" class="headerlink" title="进程和线程的区别，使用线程真的能节省时间吗"></a>进程和线程的区别，使用线程真的能节省时间吗</h4><ul>
<li>进程间数据独立，线程数据共享，一个进程可以包括多个线程</li>
<li>不一定，要看设置是否合理，CPU分页调度问题</li>
</ul>
<h4 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h4><h4 id="线程有几种状态"><a href="#线程有几种状态" class="headerlink" title="线程有几种状态"></a>线程有几种状态</h4><ul>
<li><p>在JAVA中有六种状态</p>
<p><img src="/2023/02/12/Collection-InterviewQuestion/fa697f963b38ee9ec2fd535a41ad25d9.png" alt="Thread_State"></p>
</li>
<li><p>new创建进入初始状态，start方法进入就绪状态。线程只要抢占了CPU时间片就能不获得全部的锁运行，但当运行到需要的锁而仍未获得时，进入阻塞状态。</p>
</li>
<li><p>线程被Sleep后，会先进入超时等待状态，时间结束后会先进入等待阻塞状态，当有锁以后再进入就绪状态</p>
</li>
<li><p>java.lang.Thread.State</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A thread state.  A thread can be in one of the following states:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #NEW&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that has not yet started is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #RUNNABLE&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread executing in the Java virtual machine is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #BLOCKED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that is blocked waiting for a monitor lock</span></span><br><span class="line"><span class="comment"> *     is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that is waiting indefinitely for another thread to</span></span><br><span class="line"><span class="comment"> *     perform a particular action is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #TIMED_WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that is waiting for another thread to perform an action</span></span><br><span class="line"><span class="comment"> *     for up to a specified waiting time is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #TERMINATED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *     A thread that has exited is in this state.</span></span><br><span class="line"><span class="comment"> *     &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A thread can be in only one state at a given point in time.</span></span><br><span class="line"><span class="comment"> * These states are virtual machine states which do not reflect</span></span><br><span class="line"><span class="comment"> * any operating system thread states.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="什么是竞争条件？你怎样发现和解决竞争"><a href="#什么是竞争条件？你怎样发现和解决竞争" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争"></a>什么是竞争条件？你怎样发现和解决竞争</h4><ul>
<li><p>什么是竞争条件</p>
<ul>
<li>多线程不确定的执行顺序导致不正确的结果，就是竞争条件</li>
</ul>
</li>
<li><p>你怎样发现和解决竞争</p>
<ul>
<li><p>发现</p>
<p>使用Java竞争条件坚持工具，如Facebook开源的RacerD</p>
</li>
<li><p>解决</p>
<p>可以采用加锁的方式使线程串行访问临界区</p>
</li>
</ul>
</li>
</ul>
<h4 id="在Java中CyclicBarrier和CountdownLatch有什么区别"><a href="#在Java中CyclicBarrier和CountdownLatch有什么区别" class="headerlink" title="在Java中CyclicBarrier和CountdownLatch有什么区别"></a>在Java中CyclicBarrier和CountdownLatch有什么区别</h4><table>
<thead>
<tr>
<th>区别</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>计数方式</td>
<td>递减计数</td>
<td>加法计数</td>
</tr>
<tr>
<td>可重复利用性</td>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
<tr>
<td>初始值</td>
<td>初始值为N, N&gt;0</td>
<td>N为0</td>
</tr>
<tr>
<td>计数方式</td>
<td>调用countDown, N-1</td>
<td>调用await, N+1</td>
</tr>
<tr>
<td>阻塞条件</td>
<td>N&gt;0,调用await一直阻塞</td>
<td>N小于指定值</td>
</tr>
<tr>
<td>何时释放等待线程</td>
<td>计数为0时</td>
<td>计数达到指定值N</td>
</tr>
</tbody></table>
<h4 id="你知道哪几种锁？分别有什么特点？"><a href="#你知道哪几种锁？分别有什么特点？" class="headerlink" title="你知道哪几种锁？分别有什么特点？"></a>你知道哪几种锁？分别有什么特点？</h4><ul>
<li><p>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</p>
<p>特指synchronized锁状态，通过对象头中的mark word表明锁状态</p>
<ul>
<li>偏向锁：当线程获取锁时，打上标记，不做其他事</li>
<li>轻量级锁：多线程情况下，并发竞争锁或短时间竞争锁，通过CAS即可获取，当锁被其他线程获取时，自旋等待获取锁，不进行阻塞</li>
<li>重量级锁：自旋达到16次时还未获取到锁，则升级为重锁，线程进入阻塞状态</li>
</ul>
</li>
<li><p>可重入锁&#x2F;非可重入锁</p>
<ul>
<li>可重入锁：当前线程已经持有这把锁，可以不释放这把锁情况下，再次获取这把锁。如ReentrrantLock</li>
<li>不可重入锁：当前线程持有这把锁，需要先释放，才能再次获取这把锁</li>
</ul>
</li>
<li><p>共享锁&#x2F;独占锁</p>
<ul>
<li>共享锁：一把锁可以被多个线程共同持有</li>
<li>独占锁：一把锁只能被一个线程持有</li>
</ul>
</li>
<li><p>公平锁&#x2F;非公平锁</p>
<ul>
<li>公平锁：线程拿不到锁情况下进入等待队列顺序获取锁</li>
<li>非公平锁：线程拿不到锁，在锁释放时争抢锁</li>
</ul>
</li>
<li><p>悲观锁&#x2F;乐观锁</p>
<ul>
<li>悲观锁：获取资源之前必须先拿到锁，其他未能获取锁的线程无法影响当前线程</li>
<li>乐观锁：利用CAS，不独占资源状态下，完成对资源的修改</li>
</ul>
</li>
<li><p>自旋锁&#x2F;非自旋锁</p>
<ul>
<li>自旋锁：线程拿不到锁时，进入循环无限请求锁资源直至获取</li>
<li>非自旋锁：拿不到锁就放弃&#x2F;处理其他逻辑</li>
</ul>
</li>
<li><p>可中断锁&#x2F;不可中断锁</p>
<ul>
<li>可中断锁：获取锁过程中突然要不想获取了，可以中断后做其他事，不需要一直等待获取锁。ReentrantLock就是可中断锁，打断方法为lockInterruptible</li>
<li>不可中断锁：一旦申请锁，只能一直等待直到获取成功，中途不可执行其他事件。Synchronized修饰的锁就锁不可中断锁</li>
</ul>
</li>
</ul>
<h4 id="synchronize锁有几种"><a href="#synchronize锁有几种" class="headerlink" title="synchronize锁有几种"></a>synchronize锁有几种</h4><ul>
<li>普通方法（对象级别）</li>
<li>静态方法（全局锁）</li>
<li>代码块（需指定一个对象，this为每个对象加锁，xxx.class使用某个类加锁）</li>
</ul>
<h4 id="线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？"><a href="#线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？" class="headerlink" title="线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？"></a>线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？</h4><ul>
<li>线程加锁有哪些方式</li>
<li>synchronized和lock的区别</li>
<li>Lock接口比synchronized块的优势是什么</li>
</ul>
<h4 id="JUC提供的锁于synchronized有什么区别"><a href="#JUC提供的锁于synchronized有什么区别" class="headerlink" title="JUC提供的锁于synchronized有什么区别"></a>JUC提供的锁于synchronized有什么区别</h4><h4 id="为什么Java-11取消synchronized锁升级"><a href="#为什么Java-11取消synchronized锁升级" class="headerlink" title="为什么Java 11取消synchronized锁升级"></a>为什么Java 11取消synchronized锁升级</h4><h4 id="volatile是否能保证线程安全"><a href="#volatile是否能保证线程安全" class="headerlink" title="volatile是否能保证线程安全"></a>volatile是否能保证线程安全</h4><h4 id="伪共享怎么理解"><a href="#伪共享怎么理解" class="headerlink" title="伪共享怎么理解"></a>伪共享怎么理解</h4><h4 id="你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h4><h4 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h4><ul>
<li>CPU分页。不合理线程的设置。</li>
</ul>
<h4 id="Thread-sleep-Object-wait-LockSupport-park-Condition-await-区别"><a href="#Thread-sleep-Object-wait-LockSupport-park-Condition-await-区别" class="headerlink" title="Thread.sleep(), Object.wait(), LockSupport.park(),Condition.await()区别"></a>Thread.sleep(), Object.wait(), LockSupport.park(),Condition.await()区别</h4><ul>
<li>Thread.sleep()<ul>
<li>必须指定休眠时间</li>
<li>休眠时线程状态为TIME_WAITING</li>
<li>需要捕获InterruptedException异常</li>
<li>不会释放持有的锁</li>
<li>只能等待自己到时间后醒来，唤醒后一定执行后续代码</li>
<li>本身是一个Native方法</li>
<li>通常被用于暂停</li>
</ul>
</li>
<li>Object.wait()<ul>
<li>不带时间的重载可以通过Thread.notify()唤醒，也可以等待超时唤醒。notify()必须在wait()之后执行，否则会丢失唤醒信号</li>
<li>唤醒后不一定执行后续代码</li>
<li>休眠时线程状态为WAITTING</li>
<li>需要捕获InterruptedException异常</li>
<li>会释放持有的锁<ul>
<li>调用Object.wait()时需先上锁，JVM底层会进行检查是否上锁，没持有则抛出IllegalMonitorStateException异常   synchronized (waitObject){waitObject.wait()}</li>
<li>调用Object.notify()时也需要上锁，否则如果当前线程不是对象锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</li>
</ul>
</li>
<li>wait(TimeOut)是一个Native方法</li>
<li>通常被用于线程间交互</li>
</ul>
</li>
<li>LockSupport.park()<ul>
<li>通过二元信号量实现的阻塞</li>
<li>底层调用的是UnSafe的Native方法park()</li>
<li>休眠时线程状态为WAITING</li>
<li>无需捕获InterruptedException异常，但也会响应中断</li>
<li>不会释放持有的锁</li>
<li>可以通过unpark()唤醒， unpack()方法可以比 park() 先执行，不会丢失唤醒信号</li>
<li>唤醒后一定执行后续代码</li>
</ul>
</li>
<li>Condition.await()<ul>
<li>不带时间的重载只能通过另一个的Condition.single()唤醒，唤醒后不一定执行后续代码</li>
<li>await还是single都必须先ReentreentLock的lock()块中执行，否则IllegalMonitorStateException异常</li>
<li>single不能在其之前执行</li>
<li>需要捕获InterruptedException异常</li>
<li>会释放锁资源</li>
<li>底层调用LockSupport.park()实现</li>
</ul>
</li>
</ul>
<h4 id="Java中怎样唤醒一个阻塞的线程"><a href="#Java中怎样唤醒一个阻塞的线程" class="headerlink" title="Java中怎样唤醒一个阻塞的线程"></a>Java中怎样唤醒一个阻塞的线程</h4><ul>
<li>Object.wait()使用Object.notify()唤醒。必须配合synchronized使用</li>
<li>Condition.await()使用Condition.singal()唤醒。需搭配ReentrantLock使用</li>
<li>LockSupport.park()使用LockSupport.unpark()唤醒。</li>
</ul>
<h4 id="wait与await区别"><a href="#wait与await区别" class="headerlink" title="wait与await区别"></a>wait与await区别</h4><ul>
<li>wait与notify必须配合synchronized使用，因为调用之前必须持有锁，wait会立即释放锁，notify则是同步块执行完了才释放</li>
<li>因为Lock没有使用synchronized机制，故无法使用wait方法区操作多线程，所以使用了Condition的await来操作</li>
<li>Lock实现主要是基于AQS，而AQS实现则是基于LockSupport，所以说LockSupport更底层，所以使用park效率会高一些</li>
</ul>
<h4 id="Thread-sleep-0-目的"><a href="#Thread-sleep-0-目的" class="headerlink" title="Thread.sleep(0)目的"></a>Thread.sleep(0)目的</h4><ul>
<li>让GC线程有机会被操作系统选中，从而进行垃圾清理工作。但可能导致频繁GC问题</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012060033/article/details/126781986">https://blog.csdn.net/u012060033/article/details/126781986</a></li>
</ul>
<h4 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h4><ul>
<li>使线程让出当前被调度机会</li>
<li>但是与Thread.sleep()不考虑线程优先级问题，谁都有机会抢到下一次机会。yield()只会给同等优先级或更高的线程运行</li>
<li>调用sleep()进入阻塞状态，yield()进入就绪状态，yield可能会再运行一小会儿才交出机会</li>
<li>sleep抛出InterruptedException，yield无异常。</li>
</ul>
<h4 id="在Java中线程间有哪些通信方式"><a href="#在Java中线程间有哪些通信方式" class="headerlink" title="在Java中线程间有哪些通信方式"></a>在Java中线程间有哪些通信方式</h4><ul>
<li>volatile，synchronized关键字</li>
<li>join() 方法</li>
<li>ThreadLocal</li>
<li>等待&#x2F;通知 Object.wait() Object.notify()&#x2F;notifyAll()</li>
<li>管道输入输出流</li>
</ul>
<h4 id="为什么AtomicInteger在高并发下性能不好"><a href="#为什么AtomicInteger在高并发下性能不好" class="headerlink" title="为什么AtomicInteger在高并发下性能不好"></a>为什么AtomicInteger在高并发下性能不好</h4><ul>
<li>CAS自旋等待数值计算。</li>
<li>LongAdder空间换时间，利用分段原理累加，高吞吐量时性能更佳，低吞吐量时两者差距不大</li>
<li>但AtomicInteger提供更多方法</li>
</ul>
<h4 id="有哪些解决死锁问题的策略"><a href="#有哪些解决死锁问题的策略" class="headerlink" title="有哪些解决死锁问题的策略"></a>有哪些解决死锁问题的策略</h4><h4 id="有哪些线程安全问题"><a href="#有哪些线程安全问题" class="headerlink" title="有哪些线程安全问题"></a>有哪些线程安全问题</h4><h4 id="线程池有哪几种拒绝策略"><a href="#线程池有哪几种拒绝策略" class="headerlink" title="线程池有哪几种拒绝策略"></a>线程池有哪几种拒绝策略</h4><ul>
<li>AbortPolicy：中止策略，线程池会<strong>抛出异常</strong>并中止执行此任务;</li>
<li>CallerRunsPolicy：把任务交给添加此任务的(main)线程来执行;</li>
<li>DiscardPolicy：忽略此任务，忽略最新的一个任务;</li>
<li>DiscardOldestPolicy：忽略最早的任务，最先加入队列的任务。</li>
<li>new RejectedExecutionHandler 自定义</li>
</ul>
<h4 id="一个线程两次调用start-方法会出现什么情况"><a href="#一个线程两次调用start-方法会出现什么情况" class="headerlink" title="一个线程两次调用start()方法会出现什么情况"></a>一个线程两次调用start()方法会出现什么情况</h4><ul>
<li>IllegalThreadStateException</li>
<li>原因：start state状态已变更，if(state !&#x3D; 0) throw new IllegalThreadStateException</li>
</ul>
<h4 id="线程如何中断"><a href="#线程如何中断" class="headerlink" title="线程如何中断"></a>线程如何中断</h4><h4 id="线程如何停止"><a href="#线程如何停止" class="headerlink" title="线程如何停止"></a>线程如何停止</h4><h4 id="线程读写资源，在不使用锁的情况下高效实现"><a href="#线程读写资源，在不使用锁的情况下高效实现" class="headerlink" title="线程读写资源，在不使用锁的情况下高效实现"></a>线程读写资源，在不使用锁的情况下高效实现</h4><h4 id="ThreadLocal是什么？你在工作中用到过ThreadLocal吗？"><a href="#ThreadLocal是什么？你在工作中用到过ThreadLocal吗？" class="headerlink" title="ThreadLocal是什么？你在工作中用到过ThreadLocal吗？"></a>ThreadLocal是什么？你在工作中用到过ThreadLocal吗？</h4><h4 id="ThreadLocal怎么实现的"><a href="#ThreadLocal怎么实现的" class="headerlink" title="ThreadLocal怎么实现的"></a>ThreadLocal怎么实现的</h4><ul>
<li>entry</li>
</ul>
<h4 id="ThreadLocal-内存泄露是怎么回事"><a href="#ThreadLocal-内存泄露是怎么回事" class="headerlink" title="ThreadLocal 内存泄露是怎么回事"></a>ThreadLocal 内存泄露是怎么回事</h4><h4 id="ThreadLocalMap的结构了解吗？扩容机制了解吗？"><a href="#ThreadLocalMap的结构了解吗？扩容机制了解吗？" class="headerlink" title="ThreadLocalMap的结构了解吗？扩容机制了解吗？"></a>ThreadLocalMap的结构了解吗？扩容机制了解吗？</h4><h4 id="ThreadLocal父子线程怎么共享数据？"><a href="#ThreadLocal父子线程怎么共享数据？" class="headerlink" title="ThreadLocal父子线程怎么共享数据？"></a>ThreadLocal父子线程怎么共享数据？</h4><h4 id="为什么大厂规定不能使用Executors去创建线程池？"><a href="#为什么大厂规定不能使用Executors去创建线程池？" class="headerlink" title="为什么大厂规定不能使用Executors去创建线程池？"></a>为什么大厂规定不能使用Executors去创建线程池？</h4><h4 id="如何根据实际需要，定制自己的线程池？"><a href="#如何根据实际需要，定制自己的线程池？" class="headerlink" title="如何根据实际需要，定制自己的线程池？"></a>如何根据实际需要，定制自己的线程池？</h4><h4 id="你知道为什么需要-AQS？AQS-的作用和重要性是什么？"><a href="#你知道为什么需要-AQS？AQS-的作用和重要性是什么？" class="headerlink" title="你知道为什么需要 AQS？AQS 的作用和重要性是什么？"></a>你知道为什么需要 AQS？AQS 的作用和重要性是什么？</h4><h4 id="CAS是一种什么样的同步机制？"><a href="#CAS是一种什么样的同步机制？" class="headerlink" title="CAS是一种什么样的同步机制？"></a>CAS是一种什么样的同步机制？</h4><ul>
<li>Compare And Swap</li>
</ul>
<h4 id="你知道CAS-有什么缺点？"><a href="#你知道CAS-有什么缺点？" class="headerlink" title="你知道CAS 有什么缺点？"></a>你知道CAS 有什么缺点？</h4><ul>
<li>ABA问题</li>
<li>循环时间长开销</li>
<li>只能保证一个变量的原子操作<ul>
<li>多个变量操作时，使用互斥锁保证原子性</li>
<li>将多个变量封装成对象，通过AtomicReference保证原子性</li>
</ul>
</li>
</ul>
<h4 id="你知道线程池实现“线程复用”的原理吗？"><a href="#你知道线程池实现“线程复用”的原理吗？" class="headerlink" title="你知道线程池实现“线程复用”的原理吗？"></a>你知道线程池实现“线程复用”的原理吗？</h4><h4 id="阻塞和非阻塞队列的并发安全原理是什么？"><a href="#阻塞和非阻塞队列的并发安全原理是什么？" class="headerlink" title="阻塞和非阻塞队列的并发安全原理是什么？"></a>阻塞和非阻塞队列的并发安全原理是什么？</h4><h4 id="你对“公平锁”了解吗？为什么会有“非公平锁”？"><a href="#你对“公平锁”了解吗？为什么会有“非公平锁”？" class="headerlink" title="你对“公平锁”了解吗？为什么会有“非公平锁”？"></a>你对“公平锁”了解吗？为什么会有“非公平锁”？</h4><h4 id="你对“自旋锁”了解吗？优缺点分别是什么？"><a href="#你对“自旋锁”了解吗？优缺点分别是什么？" class="headerlink" title="你对“自旋锁”了解吗？优缺点分别是什么？"></a>你对“自旋锁”了解吗？优缺点分别是什么？</h4><h4 id="合适的线程数量是多少？CPU-核心数和线程数的关系？"><a href="#合适的线程数量是多少？CPU-核心数和线程数的关系？" class="headerlink" title="合适的线程数量是多少？CPU 核心数和线程数的关系？"></a>合适的线程数量是多少？CPU 核心数和线程数的关系？</h4><h4 id="你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？"><a href="#你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？" class="headerlink" title="你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？"></a>你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？</h4><h4 id="在java中绿色线程和本地线程区别"><a href="#在java中绿色线程和本地线程区别" class="headerlink" title="在java中绿色线程和本地线程区别"></a>在java中绿色线程和本地线程区别</h4><ul>
<li>绿色线程为早期无法映射到OS线程而在JVM上建立的用户态线程，需要JVM进行调度</li>
<li>已被取代，目前完全是内核态线程</li>
</ul>
<h4 id="死锁与活锁的区别，死锁与饥饿的区别"><a href="#死锁与活锁的区别，死锁与饥饿的区别" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别"></a>死锁与活锁的区别，死锁与饥饿的区别</h4><ul>
<li>死锁：两个线程互相持有对方需要的资源，一直等待</li>
<li>活锁：没有被阻塞，但因缺少必要条件，一直无限重试，线程状态会一直变更</li>
<li>饥饿锁：高优先级线程一直抢占资源，低优先级线程无法获取资源而饥饿。当高优先级线程结束后可以恢复</li>
</ul>
<h4 id="Java中用到的线程调度算法是什么"><a href="#Java中用到的线程调度算法是什么" class="headerlink" title="Java中用到的线程调度算法是什么"></a>Java中用到的线程调度算法是什么</h4><ul>
<li>分时调度</li>
<li>抢占式调度（Java默认）</li>
</ul>
<h4 id="在线程中怎么处理不可捕捉异常"><a href="#在线程中怎么处理不可捕捉异常" class="headerlink" title="在线程中怎么处理不可捕捉异常"></a>在线程中怎么处理不可捕捉异常</h4><ul>
<li>实现Thread.UncaughtExceptionHandler自定义异常处理器捕获s</li>
</ul>
<h4 id="什么是线程组，为什么在Java中不推荐使用"><a href="#什么是线程组，为什么在Java中不推荐使用" class="headerlink" title="什么是线程组，为什么在Java中不推荐使用"></a>什么是线程组，为什么在Java中不推荐使用</h4><ul>
<li>线程不安全</li>
<li>resume、suspend等方法会导致DeadLock问题，已被官方废弃</li>
</ul>
<h4 id="为什么使用Executor框架比使用应用创建和管理线程好"><a href="#为什么使用Executor框架比使用应用创建和管理线程好" class="headerlink" title="为什么使用Executor框架比使用应用创建和管理线程好"></a>为什么使用Executor框架比使用应用创建和管理线程好</h4><ul>
<li>控制线程总数，控制并发数量</li>
<li>复用线程</li>
</ul>
<h4 id="在Java中Executor和Executors的区别"><a href="#在Java中Executor和Executors的区别" class="headerlink" title="在Java中Executor和Executors的区别"></a>在Java中Executor和Executors的区别</h4><ul>
<li>Executor有子类ExecutorService，可自定义线程池，子类支持Runnable和Callable方法</li>
<li>Executors为官方线程池</li>
</ul>
<h4 id="如何在Windows和Linux上查找哪个线程使用的CPU时间最长"><a href="#如何在Windows和Linux上查找哪个线程使用的CPU时间最长" class="headerlink" title="如何在Windows和Linux上查找哪个线程使用的CPU时间最长"></a>如何在Windows和Linux上查找哪个线程使用的CPU时间最长</h4><ul>
<li>Jstack查询CPU使用最多的PID编号</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h4 id="如何用10行代码实现一个负载均衡服务"><a href="#如何用10行代码实现一个负载均衡服务" class="headerlink" title="如何用10行代码实现一个负载均衡服务"></a>如何用10行代码实现一个负载均衡服务</h4><ul>
<li>Servlet 代码中调用响应重定向方法</li>
</ul>
<h4 id="百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字"><a href="#百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字" class="headerlink" title="百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字"></a>百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字</h4><ul>
<li>Hash笔记，求出每个小文件中重复次数最多的，再整合后统计</li>
<li>BitMap记录</li>
</ul>
<h4 id="JAVA-LIST查询过大容易OOM解决方案"><a href="#JAVA-LIST查询过大容易OOM解决方案" class="headerlink" title="JAVA LIST查询过大容易OOM解决方案"></a>JAVA LIST查询过大容易OOM解决方案</h4><ul>
<li>分页，分Batch处理</li>
<li>调整Heap大小参数</li>
</ul>
<h4 id="用Java编程一个会导致死锁的程序，你将怎么解决"><a href="#用Java编程一个会导致死锁的程序，你将怎么解决" class="headerlink" title="用Java编程一个会导致死锁的程序，你将怎么解决"></a>用Java编程一个会导致死锁的程序，你将怎么解决</h4><h3 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h3><h4 id="Java几种Copy方式，哪种效率最高"><a href="#Java几种Copy方式，哪种效率最高" class="headerlink" title="Java几种Copy方式，哪种效率最高"></a>Java几种Copy方式，哪种效率最高</h4><h2 id="JMM-相关"><a href="#JMM-相关" class="headerlink" title="JMM 相关"></a>JMM 相关</h2><h4 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h4><h4 id="什么是“内存可见性”问题"><a href="#什么是“内存可见性”问题" class="headerlink" title="什么是“内存可见性”问题"></a>什么是“内存可见性”问题</h4><h4 id="你知道主内存和工作内存的关系？"><a href="#你知道主内存和工作内存的关系？" class="headerlink" title="你知道主内存和工作内存的关系？"></a>你知道主内存和工作内存的关系？</h4><h4 id="你知道什么是-happens-before-原则吗？"><a href="#你知道什么是-happens-before-原则吗？" class="headerlink" title="你知道什么是 happens-before 原则吗？"></a>你知道什么是 happens-before 原则吗？</h4><h4 id="JAVA创建对象时是否存在窗口期"><a href="#JAVA创建对象时是否存在窗口期" class="headerlink" title="JAVA创建对象时是否存在窗口期"></a>JAVA创建对象时是否存在窗口期</h4><ul>
<li>Memory Order</li>
</ul>
<h2 id="JVM-相关"><a href="#JVM-相关" class="headerlink" title="JVM 相关"></a>JVM 相关</h2><h4 id="JVM-GCRoots对象"><a href="#JVM-GCRoots对象" class="headerlink" title="JVM GCRoots对象"></a>JVM GCRoots对象</h4><ul>
<li>虚拟机栈（栈帧的本地变量表）引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
<li>方法区中类静态属性引用对象</li>
<li>方法区中常量引用对象</li>
<li>被synchronized锁持有的对象</li>
<li>基本数据类型对应的Class对象、常驻对象、类加载器</li>
<li>反映JVM内部情况的JMXBean等</li>
</ul>
<h4 id="什么是不可达"><a href="#什么是不可达" class="headerlink" title="什么是不可达"></a>什么是不可达</h4><ul>
<li><p>通过一系列GC Root对象作为起点向下搜索，搜索时走过的路径称为引用链 (Refrence Chain)，当一个对象到GC Root没有任何引用链相连时，则认为该对象不可达，会被GC回收</p>
<p><img src="/2023/02/12/Collection-InterviewQuestion/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" alt="可达性算法"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">JVM垃圾收集器与内存分配策略 | 一蓑烟雨任平生 (sunliaodong.cn)</a></p>
</li>
</ul>
<h4 id="A、B对象可回收，一定就会被回收吗"><a href="#A、B对象可回收，一定就会被回收吗" class="headerlink" title="A、B对象可回收，一定就会被回收吗"></a>A、B对象可回收，一定就会被回收吗</h4><ul>
<li><p>不一定，要看是否执行过finalize()方法，没执行但有必要执行的对象放入F-Queue，虚拟机建立一个优先级低的Finalizer线程对F-Queue中的对象进行finalize()方法，之后F-Queued对其二次标记，如果没能逃脱则回收</p>
</li>
<li><p><img src="/2023/02/12/Collection-InterviewQuestion/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png" alt="对象已死"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">JVM垃圾收集器与内存分配策略 | 一蓑烟雨任平生 (sunliaodong.cn)</a></p>
</li>
</ul>
<h4 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h4><h4 id="为什么要分新生代老年代"><a href="#为什么要分新生代老年代" class="headerlink" title="为什么要分新生代老年代"></a>为什么要分新生代老年代</h4><h4 id="为什么用元空间替换永久代"><a href="#为什么用元空间替换永久代" class="headerlink" title="为什么用元空间替换永久代"></a>为什么用元空间替换永久代</h4><h3 id="ClassLoader相关"><a href="#ClassLoader相关" class="headerlink" title="ClassLoader相关"></a>ClassLoader相关</h3><h4 id="简单说说你了解的类加载器，可以打破双亲委派么？"><a href="#简单说说你了解的类加载器，可以打破双亲委派么？" class="headerlink" title="简单说说你了解的类加载器，可以打破双亲委派么？"></a>简单说说你了解的类加载器，可以打破双亲委派么？</h4><h4 id="如果创建一个java-lang-String类，这个类是否可以被类加载器加载"><a href="#如果创建一个java-lang-String类，这个类是否可以被类加载器加载" class="headerlink" title="如果创建一个java.lang.String类，这个类是否可以被类加载器加载"></a>如果创建一个java.lang.String类，这个类是否可以被类加载器加载</h4><ul>
<li>默认不行，bootstrap默认JVM加载java.*的类（双亲委派机制保护）</li>
<li>可以通过修改父类findClass方法加载，不建议</li>
</ul>
<h4 id="JVM是如何处理异常的"><a href="#JVM是如何处理异常的" class="headerlink" title="JVM是如何处理异常的"></a>JVM是如何处理异常的</h4><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给JVM。该异常对象包含：异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并交给JVM的过程叫做抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM会顺着调用栈去查找是否有可以处理异常的代码，如果有，则调用异常处理代码。如果没有找到，JVM就会将该异常转交给默认的异常处理器（默认处理器是JVM的一部分）默认异常处理器会打印出异常信息并终止程序运行。</p>
<h4 id="finnal、finnally、finalize的区别"><a href="#finnal、finnally、finalize的区别" class="headerlink" title="finnal、finnally、finalize的区别"></a>finnal、finnally、finalize的区别</h4><p>finnal可以修饰类、变量、方法；修饰类，则该类不能被继承；修饰变量，则表示该变量是一个常量，不能被重新赋值；修饰方法，表示该方法不能被重写</p>
<p>finnally一般作用在try-catch代码中，在异常处理的时候，通常代码一定要执行的方法写在finnaly代码块中，通常写在finnally中的代码一定会被执行。一般写关闭资源的代码语句</p>
<p>finalize是一个方法，属于Object类，Object类是所有类的父类，java中允许使用finalize()方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</strong></p>
<h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><h4 id="GC什么时候启动"><a href="#GC什么时候启动" class="headerlink" title="GC什么时候启动"></a>GC什么时候启动</h4><h4 id="Mutator"><a href="#Mutator" class="headerlink" title="Mutator"></a>Mutator</h4><h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><ul>
<li><p>引用计数</p>
</li>
<li><p>复制</p>
</li>
<li><p>？？</p>
</li>
<li><p>？？</p>
</li>
<li><p>都是各种组合</p>
</li>
</ul>
<h4 id="垃圾收集器有哪几种"><a href="#垃圾收集器有哪几种" class="headerlink" title="垃圾收集器有哪几种"></a>垃圾收集器有哪几种</h4><h4 id="CMS是什么，简述工作流程"><a href="#CMS是什么，简述工作流程" class="headerlink" title="CMS是什么，简述工作流程"></a>CMS是什么，简述工作流程</h4><h4 id="CMS缺陷"><a href="#CMS缺陷" class="headerlink" title="CMS缺陷"></a>CMS缺陷</h4><h4 id="为什么配置了CMS-GC仍然会触发Full-GC"><a href="#为什么配置了CMS-GC仍然会触发Full-GC" class="headerlink" title="为什么配置了CMS GC仍然会触发Full GC"></a>为什么配置了CMS GC仍然会触发Full GC</h4><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h4 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h4><h4 id="内存溢出和内存泄漏区别"><a href="#内存溢出和内存泄漏区别" class="headerlink" title="内存溢出和内存泄漏区别"></a>内存溢出和内存泄漏区别</h4><h4 id="频繁Young-GC原因"><a href="#频繁Young-GC原因" class="headerlink" title="频繁Young GC原因"></a>频繁Young GC原因</h4><h2 id="Spring-相关"><a href="#Spring-相关" class="headerlink" title="Spring 相关"></a>Spring 相关</h2><h4 id="RestController与Controller区别"><a href="#RestController与Controller区别" class="headerlink" title="RestController与Controller区别"></a>RestController与Controller区别</h4><ul>
<li>@RestController &#x3D; @ResponseBody ＋ @Controller，无法返回指定页面</li>
<li>@Controller可以返回指定页面，如果需要返回数据需要+ @ResponseBody辅助</li>
</ul>
<h4 id="RequestBody与ResponseBody区别"><a href="#RequestBody与ResponseBody区别" class="headerlink" title="RequestBody与ResponseBody区别"></a>RequestBody与ResponseBody区别</h4><ul>
<li>RequestBody 入参</li>
<li>ResponseBody 出参，将数据转化为JSON等格式返回</li>
</ul>
<h4 id="Spring底层实现"><a href="#Spring底层实现" class="headerlink" title="Spring底层实现"></a>Spring底层实现</h4><h4 id="Spring事务底层实现"><a href="#Spring事务底层实现" class="headerlink" title="Spring事务底层实现"></a>Spring事务底层实现</h4><h4 id="IOC理解"><a href="#IOC理解" class="headerlink" title="IOC理解"></a>IOC理解</h4><h4 id="IOC主要容器"><a href="#IOC主要容器" class="headerlink" title="IOC主要容器"></a>IOC主要容器</h4><h4 id="Spring生命周期"><a href="#Spring生命周期" class="headerlink" title="Spring生命周期"></a>Spring生命周期</h4><h4 id="Spring-Bean加载初始化过程"><a href="#Spring-Bean加载初始化过程" class="headerlink" title="Spring Bean加载初始化过程"></a>Spring Bean加载初始化过程</h4><h4 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h4><h4 id="BeanFactory与FactoryBean的区别"><a href="#BeanFactory与FactoryBean的区别" class="headerlink" title="BeanFactory与FactoryBean的区别"></a>BeanFactory与FactoryBean的区别</h4><h4 id="Spring中Bean默认是Singleton还是多态的"><a href="#Spring中Bean默认是Singleton还是多态的" class="headerlink" title="Spring中Bean默认是Singleton还是多态的"></a>Spring中Bean默认是Singleton还是多态的</h4><ul>
<li>Singleton</li>
</ul>
<h4 id="为什么默认Singleton"><a href="#为什么默认Singleton" class="headerlink" title="为什么默认Singleton"></a>为什么默认Singleton</h4><ul>
<li>serverless</li>
<li>方法执行结束后，不改变类的状态，不变更全局参数</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h4><h4 id="SpringMVC组件工作流程，如果不这么设计会有什么问题"><a href="#SpringMVC组件工作流程，如果不这么设计会有什么问题" class="headerlink" title="SpringMVC组件工作流程，如果不这么设计会有什么问题"></a>SpringMVC组件工作流程，如果不这么设计会有什么问题</h4><h4 id="检查拦截器的执行链路在哪个方法比对"><a href="#检查拦截器的执行链路在哪个方法比对" class="headerlink" title="检查拦截器的执行链路在哪个方法比对"></a>检查拦截器的执行链路在哪个方法比对</h4><h4 id="Spring有几种依赖注入方式"><a href="#Spring有几种依赖注入方式" class="headerlink" title="Spring有几种依赖注入方式"></a>Spring有几种依赖注入方式</h4><h4 id="Spring有几种异步调用方式"><a href="#Spring有几种异步调用方式" class="headerlink" title="Spring有几种异步调用方式"></a>Spring有几种异步调用方式</h4><h4 id="如何解决跨域，原理是什么"><a href="#如何解决跨域，原理是什么" class="headerlink" title="如何解决跨域，原理是什么"></a>如何解决跨域，原理是什么</h4><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="Service相互调用，被调用类已Catch异常，为何-Transactional仍然回滚"><a href="#Service相互调用，被调用类已Catch异常，为何-Transactional仍然回滚" class="headerlink" title="Service相互调用，被调用类已Catch异常，为何@Transactional仍然回滚"></a>Service相互调用，被调用类已Catch异常，为何@Transactional仍然回滚</h4><ul>
<li><p>场景</p>
<p>@Transactional 在ServiceA 上注解，当ServiceA调用ServiceB，在ServiceB出现异常并捕获时，ServiceA落库的数据仍然抛出异常被回滚</p>
</li>
<li><p>原因</p>
<p>由于事务传播机制，ServiceB默认Propagation.REQUIRED传播方式，因此当ServiceB出现异常时，即使被捕获，仍然已被标记需要回滚</p>
</li>
<li><p>解决方案</p>
<p>ServiceB设置为Propagation.REQUIRES_NEW传播机制，同时取消ServiceB的捕获try-catch，移入serviceA调用serviceB的部分，由serviceA进行捕获即可</p>
</li>
</ul>
<h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><h4 id="SSO与OAuth2有什么不同"><a href="#SSO与OAuth2有什么不同" class="headerlink" title="SSO与OAuth2有什么不同"></a>SSO与OAuth2有什么不同</h4><h2 id="SpringBoot-相关"><a href="#SpringBoot-相关" class="headerlink" title="SpringBoot 相关"></a>SpringBoot 相关</h2><h4 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h4><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含 了以下<code> 3 个注解</code>：</p>
<p><code>@SpringBootConfiguration：</code>组合了 @Configuration 注解，实现配置文件的功能。</p>
<p><code>@EnableAutoConfiguration：</code>打开自动配置的功能，也可以关闭某个自动配置的选项</p>
<p><code>@ComponentScan</code>：Spring组件扫描。</p>
<h4 id="SpringBoot-生命周期"><a href="#SpringBoot-生命周期" class="headerlink" title="SpringBoot 生命周期"></a>SpringBoot 生命周期</h4><p>SpringBoot应用的生命周期，整体上可以分为SpringApplication初始化阶段、SpringApplication运行阶段、SpringApplication结束阶段、SpringBoot应用退出四个阶段。</p>
<h4 id="Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h4><ul>
<li>Log4j2,LogBack等</li>
<li>推荐使用LogBack</li>
</ul>
<h4 id="SpringBoot-Starter的工作原理"><a href="#SpringBoot-Starter的工作原理" class="headerlink" title="SpringBoot Starter的工作原理"></a>SpringBoot Starter的工作原理</h4><ul>
<li>解析Maven各个starter中的spring.factories文件，根据需求自动配置把Bean注入SpringContext中</li>
</ul>
<h4 id="SpringBoot事务的使用"><a href="#SpringBoot事务的使用" class="headerlink" title="SpringBoot事务的使用"></a>SpringBoot事务的使用</h4><ul>
<li>声明式：@Transactional(rollbackFor&#x3D;Exception.class)，这种方法可能出现事务失效问题</li>
<li>非声明式：TransactionTemplate</li>
</ul>
<h4 id="声明式事务失效原因"><a href="#声明式事务失效原因" class="headerlink" title="声明式事务失效原因"></a>声明式事务失效原因</h4><h4 id="Async异步调用方法"><a href="#Async异步调用方法" class="headerlink" title="Async异步调用方法"></a>Async异步调用方法</h4><ul>
<li>启动类加上@EnableSync注解后，直接在需要的方法上打上@Async注解</li>
<li>建议配置额外线程池使用@Async</li>
<li>需注意与其他AOP注入冲突问题，可以用@Lazy注解解决</li>
</ul>
<h4 id="如何在-Spring-Boot-启动的时候运行一些特定的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特定的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特定的代码？"></a>如何在 Spring Boot 启动的时候运行一些特定的代码？</h4><ul>
<li>可以实现接口 <code>ApplicationRunner</code> 或者 <code>CommandLineRunner</code>，这两个接口实现方式一样，它们都只提供了一个 <code>run</code> 方法</li>
<li>Spring Listener周期启动？</li>
</ul>
<h4 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h4><ul>
<li>Spring Boot 可以通过<code> @PropertySource,@Value,@Environment, @ConfigurationPropertie注解</code>来绑定变量</li>
</ul>
<h4 id="bootstrap-properties-和-application-properties-有何异同"><a href="#bootstrap-properties-和-application-properties-有何异同" class="headerlink" title="bootstrap.properties 和 application.properties 有何异同"></a>bootstrap.properties 和 application.properties 有何异同</h4><ul>
<li>都可以是核心文件</li>
<li>bootstrap优先级比application高</li>
<li>Springboot一般使用application，SpringCloud使用bootstrap</li>
</ul>
<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><ul>
<li>后端通过通过实现WebMvcConfifigurer接口然后重写addCorsMappings方法解决</li>
</ul>
<h4 id="SpringBoot异常处理相关注解"><a href="#SpringBoot异常处理相关注解" class="headerlink" title="SpringBoot异常处理相关注解?"></a>SpringBoot异常处理相关注解?</h4><ul>
<li>@ControllerAdvice</li>
<li>@ExceptionHandler</li>
</ul>
<h4 id="SpringBoot配置监控"><a href="#SpringBoot配置监控" class="headerlink" title="SpringBoot配置监控?"></a>SpringBoot配置监控?</h4><ul>
<li>Maven 引入 spring-boot-starter-actuator</li>
</ul>
<h2 id="Spring-Cloud-相关"><a href="#Spring-Cloud-相关" class="headerlink" title="Spring Cloud 相关"></a>Spring Cloud 相关</h2><h4 id="为什么要进行系统拆分？如何进行系统拆分？"><a href="#为什么要进行系统拆分？如何进行系统拆分？" class="headerlink" title="为什么要进行系统拆分？如何进行系统拆分？"></a>为什么要进行系统拆分？如何进行系统拆分？</h4><h4 id="什么是微服务？微服务之间是如何独立通讯的？"><a href="#什么是微服务？微服务之间是如何独立通讯的？" class="headerlink" title="什么是微服务？微服务之间是如何独立通讯的？"></a>什么是微服务？微服务之间是如何独立通讯的？</h4><h4 id="微服务架构优缺点"><a href="#微服务架构优缺点" class="headerlink" title="微服务架构优缺点"></a>微服务架构优缺点</h4><h4 id="服务之间如何快速通信"><a href="#服务之间如何快速通信" class="headerlink" title="服务之间如何快速通信"></a>服务之间如何快速通信</h4><h4 id="OpenFeign底层调用原理"><a href="#OpenFeign底层调用原理" class="headerlink" title="OpenFeign底层调用原理"></a>OpenFeign底层调用原理</h4><h4 id="Spring-Boot-和-Spring-Cloud，谈谈你对它们的理解？"><a href="#Spring-Boot-和-Spring-Cloud，谈谈你对它们的理解？" class="headerlink" title="Spring Boot 和 Spring Cloud，谈谈你对它们的理解？"></a>Spring Boot 和 Spring Cloud，谈谈你对它们的理解？</h4><ul>
<li>Spring Boot基于Spring的脚手架</li>
<li>Spring Cloud是一套依托于Spring生态的微服务解决方案</li>
</ul>
<h4 id="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h4><h4 id="如何限流？在工作中是怎么做的？说一下具体的实现？"><a href="#如何限流？在工作中是怎么做的？说一下具体的实现？" class="headerlink" title="如何限流？在工作中是怎么做的？说一下具体的实现？"></a>如何限流？在工作中是怎么做的？说一下具体的实现？</h4><h4 id="集群分布式-Session-如何实现？"><a href="#集群分布式-Session-如何实现？" class="headerlink" title="集群分布式 Session 如何实现？"></a>集群分布式 Session 如何实现？</h4><ul>
<li>Redis存储，各服务器共享</li>
<li>tomcat-redis-session-manager，session粘滞：强行分发session到各个服务器</li>
</ul>
<h4 id="如何设计一个高并发的系统"><a href="#如何设计一个高并发的系统" class="headerlink" title="如何设计一个高并发的系统"></a>如何设计一个高并发的系统</h4><h4 id="请解释一下什么是C10K问题，后来是怎么解决的"><a href="#请解释一下什么是C10K问题，后来是怎么解决的" class="headerlink" title="请解释一下什么是C10K问题，后来是怎么解决的"></a>请解释一下什么是C10K问题，后来是怎么解决的</h4><ul>
<li>在同时连接到服务器的客户端数量超过 10000 个的环境中，即便硬件性能足够， 依然无法正常提供服务</li>
<li>多路复用，非阻塞IO，减少不必要性能损耗，异步响应</li>
</ul>
<h4 id="高并发除了加锁还有什么解决方案"><a href="#高并发除了加锁还有什么解决方案" class="headerlink" title="高并发除了加锁还有什么解决方案"></a>高并发除了加锁还有什么解决方案</h4><h4 id="Spring-Cloud-和-Dubbo-有哪些区别？"><a href="#Spring-Cloud-和-Dubbo-有哪些区别？" class="headerlink" title="Spring Cloud 和 Dubbo 有哪些区别？"></a>Spring Cloud 和 Dubbo 有哪些区别？</h4><ul>
<li>定位不同：SpringCloud是解决方案，Dubbo作用于服务调用与治理</li>
<li>生态不同：SpringCloud是Spring平台生态，Dubbo初始设计是SOA的RPC远程调用</li>
<li>调用方式：SpringCloud是Http调用，通常是Rest风格。Dubbo使用Dubbo协议，接口一般是Java的Service接口，传输二进制数据，内部Netty的NIO方式，性能更好</li>
<li>Spring Cloud注册中心Eureka（Spring Cloud Alibaba是Nacos），Dubbo采用Zookeeper</li>
</ul>
<h4 id="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"><a href="#Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？" class="headerlink" title="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"></a>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</h4><h4 id="Nacos作用"><a href="#Nacos作用" class="headerlink" title="Nacos作用"></a>Nacos作用</h4><h4 id="Nacos优缺点"><a href="#Nacos优缺点" class="headerlink" title="Nacos优缺点"></a>Nacos优缺点</h4><h4 id="Nacos和Zookeeper区别"><a href="#Nacos和Zookeeper区别" class="headerlink" title="Nacos和Zookeeper区别"></a>Nacos和Zookeeper区别</h4><h4 id="SpringCloud几个组件主要功能"><a href="#SpringCloud几个组件主要功能" class="headerlink" title="SpringCloud几个组件主要功能"></a>SpringCloud几个组件主要功能</h4><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h4 id="Dubbo-负载均衡策略都有哪些？"><a href="#Dubbo-负载均衡策略都有哪些？" class="headerlink" title="Dubbo 负载均衡策略都有哪些？"></a>Dubbo 负载均衡策略都有哪些？</h4><h4 id="Dubbo-的工作原理？"><a href="#Dubbo-的工作原理？" class="headerlink" title="Dubbo 的工作原理？"></a>Dubbo 的工作原理？</h4><h4 id="Dubbo-进行服务治理、服务降级、失败重试以及超时重试？"><a href="#Dubbo-进行服务治理、服务降级、失败重试以及超时重试？" class="headerlink" title="Dubbo 进行服务治理、服务降级、失败重试以及超时重试？"></a>Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</h4><h4 id="Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗"><a href="#Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗" class="headerlink" title="Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗"></a>Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗</h4><h4 id="Dubbo-的-SPI-和-Java-的-SPI-有什么区别？"><a href="#Dubbo-的-SPI-和-Java-的-SPI-有什么区别？" class="headerlink" title="Dubbo 的 SPI 和 Java 的 SPI 有什么区别？"></a>Dubbo 的 SPI 和 Java 的 SPI 有什么区别？</h4><h4 id="Dubbo组件之间的关联性"><a href="#Dubbo组件之间的关联性" class="headerlink" title="Dubbo组件之间的关联性"></a>Dubbo组件之间的关联性</h4><h4 id="如何自己设计一个类似-Dubbo-的-RPC-框架？"><a href="#如何自己设计一个类似-Dubbo-的-RPC-框架？" class="headerlink" title="如何自己设计一个类似 Dubbo 的 RPC 框架？"></a>如何自己设计一个类似 Dubbo 的 RPC 框架？</h4><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="分布式事务，缓存和数据库的一致性保持"><a href="#分布式事务，缓存和数据库的一致性保持" class="headerlink" title="分布式事务，缓存和数据库的一致性保持"></a>分布式事务，缓存和数据库的一致性保持</h4><h4 id="分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势"><a href="#分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势" class="headerlink" title="分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势"></a>分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势</h4><ul>
<li>2PC 3PC TCC Saga事务 本地消息表，MQ消息事务最大努力通知</li>
</ul>
<h4 id="Seata模式"><a href="#Seata模式" class="headerlink" title="Seata模式"></a>Seata模式</h4><h2 id="MQ-相关"><a href="#MQ-相关" class="headerlink" title="MQ 相关"></a>MQ 相关</h2><h3 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h3><h4 id="MQ选型"><a href="#MQ选型" class="headerlink" title="MQ选型"></a>MQ选型</h4><ul>
<li>Kafka：高吞吐量，适合数据量大的业务</li>
<li>RocketMQ：拥有事务消息，可靠性要求高可使用</li>
<li>RabbitMQ：结合Erlang并发性好，但不利于二次开发</li>
<li>ActiveMQ：维护越来越少，不建议使用</li>
</ul>
<h4 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h4><h4 id="手写生产者消费者（Product-A、C，Follower-B、D，Bind-AC-amp-amp-BD-Exchange）"><a href="#手写生产者消费者（Product-A、C，Follower-B、D，Bind-AC-amp-amp-BD-Exchange）" class="headerlink" title="手写生产者消费者（Product A、C，Follower B、D，Bind AC &amp;&amp; BD + Exchange）"></a>手写生产者消费者（Product A、C，Follower B、D，Bind AC &amp;&amp; BD + Exchange）</h4><h4 id="项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？"><a href="#项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？" class="headerlink" title="项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？"></a>项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？</h4><h4 id="MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？"><a href="#MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？" class="headerlink" title="MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？"></a>MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？</h4><h4 id="MQ有遇到过重复消费的问题吗？怎么解决的呢？"><a href="#MQ有遇到过重复消费的问题吗？怎么解决的呢？" class="headerlink" title="MQ有遇到过重复消费的问题吗？怎么解决的呢？"></a>MQ有遇到过重复消费的问题吗？怎么解决的呢？</h4><h4 id="MQ有遇到过消息丢失吗？可靠性怎么保证呢？"><a href="#MQ有遇到过消息丢失吗？可靠性怎么保证呢？" class="headerlink" title="MQ有遇到过消息丢失吗？可靠性怎么保证呢？"></a>MQ有遇到过消息丢失吗？可靠性怎么保证呢？</h4><h4 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</h4><h3 id="Kafka相关"><a href="#Kafka相关" class="headerlink" title="Kafka相关"></a>Kafka相关</h3><h4 id="Kafka底层原理"><a href="#Kafka底层原理" class="headerlink" title="Kafka底层原理"></a>Kafka底层原理</h4><h4 id="Kafka机制"><a href="#Kafka机制" class="headerlink" title="Kafka机制"></a>Kafka机制</h4><h4 id="Kafka事务"><a href="#Kafka事务" class="headerlink" title="Kafka事务"></a>Kafka事务</h4><h4 id="如何处理消息堆积"><a href="#如何处理消息堆积" class="headerlink" title="如何处理消息堆积"></a>如何处理消息堆积</h4><h4 id="Kafka消息顺序性"><a href="#Kafka消息顺序性" class="headerlink" title="Kafka消息顺序性"></a>Kafka消息顺序性</h4><h4 id="Kafka持久化内存满了除了迁移还能怎么办"><a href="#Kafka持久化内存满了除了迁移还能怎么办" class="headerlink" title="Kafka持久化内存满了除了迁移还能怎么办"></a>Kafka持久化内存满了除了迁移还能怎么办</h4><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><h3 id="RocketMQ相关"><a href="#RocketMQ相关" class="headerlink" title="RocketMQ相关"></a>RocketMQ相关</h3><h4 id="rocketMQ保证顺序消费，为何要在broker端锁定该消息队列，保证只有一个消费者会获得该消费队列"><a href="#rocketMQ保证顺序消费，为何要在broker端锁定该消息队列，保证只有一个消费者会获得该消费队列" class="headerlink" title="rocketMQ保证顺序消费，为何要在broker端锁定该消息队列，保证只有一个消费者会获得该消费队列"></a>rocketMQ保证顺序消费，为何要在broker端锁定该消息队列，保证只有一个消费者会获得该消费队列</h4><ul>
<li>rocketMQ再均衡没有类似kafka的coordinator参与，都是各个consumer独立完成。肯存在某一时刻多个consumer消费同一个consumequeue的情况</li>
</ul>
<h3 id="RabbitMQ相关"><a href="#RabbitMQ相关" class="headerlink" title="RabbitMQ相关"></a>RabbitMQ相关</h3><h2 id="Cache-相关"><a href="#Cache-相关" class="headerlink" title="Cache 相关"></a>Cache 相关</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis主从、哨兵和集群区别"><a href="#Redis主从、哨兵和集群区别" class="headerlink" title="Redis主从、哨兵和集群区别"></a>Redis主从、哨兵和集群区别</h4><ul>
<li><p>主从</p>
<p>主从复制，读写分离。但不能自动恢复</p>
</li>
<li><p>哨兵</p>
<p>哨兵选举可以自动恢复，着眼于高可用。但不能解决负载均衡问题</p>
</li>
<li><p>集群</p>
<p>着眼于高并发，可以解决负载均衡问题，方案是slot，通过一致性哈希算法将数据分散在不同的slot中 16384个slot</p>
</li>
</ul>
<h4 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h4><h4 id="为什么要设计Redis-Slot结构，如何查找数据"><a href="#为什么要设计Redis-Slot结构，如何查找数据" class="headerlink" title="为什么要设计Redis Slot结构，如何查找数据"></a>为什么要设计Redis Slot结构，如何查找数据</h4><h4 id="如何找出Redis中的慢查询记录"><a href="#如何找出Redis中的慢查询记录" class="headerlink" title="如何找出Redis中的慢查询记录"></a>如何找出Redis中的慢查询记录</h4><ul>
<li>redis设置slowlog-log-slower-than、 slowlog-max-len两个参数</li>
<li>slowlog get 查看</li>
<li>redis慢日志的删除采用 <strong>先进先出</strong> 的方式</li>
</ul>
<h4 id="Redis-List过大如何优化"><a href="#Redis-List过大如何优化" class="headerlink" title="Redis List过大如何优化"></a>Redis List过大如何优化</h4><ul>
<li>分片</li>
</ul>
<h4 id="你们是如何对Redis进行性能优化的"><a href="#你们是如何对Redis进行性能优化的" class="headerlink" title="你们是如何对Redis进行性能优化的"></a>你们是如何对Redis进行性能优化的</h4><ul>
<li>Key尽量短</li>
<li>数据尽量小</li>
<li>不使用lrange之类命令查询</li>
<li>设置Key生命周期</li>
<li>选择默认LRU策略</li>
</ul>
<h4 id="为什么-使用-Redis-而不是用-Memcached"><a href="#为什么-使用-Redis-而不是用-Memcached" class="headerlink" title="为什么 使用 Redis 而不是用 Memcached"></a>为什么 使用 Redis 而不是用 Memcached</h4><ul>
<li>Redis可以持久化数据</li>
<li>速度更快</li>
<li>支持数据结构更多，Memcached只支持字符串，Redis支持String，Hash，List，Set，ZSet，以及BitMap、Geospatial、Hyperloglog</li>
</ul>
<h4 id="ZSet数据结构以及空间复杂度"><a href="#ZSet数据结构以及空间复杂度" class="headerlink" title="ZSet数据结构以及空间复杂度"></a>ZSet数据结构以及空间复杂度</h4><h4 id="跳跃列表原理怎么实现"><a href="#跳跃列表原理怎么实现" class="headerlink" title="跳跃列表原理怎么实现"></a>跳跃列表原理怎么实现</h4><h4 id="quickList和zipList原理"><a href="#quickList和zipList原理" class="headerlink" title="quickList和zipList原理"></a>quickList和zipList原理</h4><h4 id="Redis异步消息怎么处理"><a href="#Redis异步消息怎么处理" class="headerlink" title="Redis异步消息怎么处理"></a>Redis异步消息怎么处理</h4><h4 id="Redis-5-0-新增Stream对它有什么理解"><a href="#Redis-5-0-新增Stream对它有什么理解" class="headerlink" title="Redis 5.0 新增Stream对它有什么理解"></a>Redis 5.0 新增Stream对它有什么理解</h4><h4 id="为什么redis7用listpack取代ziplist"><a href="#为什么redis7用listpack取代ziplist" class="headerlink" title="为什么redis7用listpack取代ziplist"></a>为什么redis7用listpack取代ziplist</h4><h4 id="大批量删除Redis-key导致Redis不稳定如何解决"><a href="#大批量删除Redis-key导致Redis不稳定如何解决" class="headerlink" title="大批量删除Redis key导致Redis不稳定如何解决"></a>大批量删除Redis key导致Redis不稳定如何解决</h4><ul>
<li>开启 lazy-free<ul>
<li>lazyfree-lazy-eviction：当 redis 内存达到阈值 maxmemory 时，将执行内存淘汰</li>
<li>lazyfree-lazy-expire：当设置了过期 key 的过期时间到了，将删除 key</li>
<li>lazyfree-lazy-server-del：这种主要用户提交 del 删除指令</li>
<li>replica-lazy-flush：主要用于复制过程中，全量同步的场景，从节点需要删除整个 db</li>
</ul>
</li>
</ul>
<h4 id="如何保证Redis高并发、高可用"><a href="#如何保证Redis高并发、高可用" class="headerlink" title="如何保证Redis高并发、高可用"></a>如何保证Redis高并发、高可用</h4><ul>
<li>集群Slot</li>
</ul>
<h4 id="Redis持久化机制，以及优缺点"><a href="#Redis持久化机制，以及优缺点" class="headerlink" title="Redis持久化机制，以及优缺点"></a>Redis持久化机制，以及优缺点</h4><ul>
<li>RDB<ul>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
<li>AOF<ul>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
</ul>
<h4 id="雪崩、穿透、击穿问题怎么解决"><a href="#雪崩、穿透、击穿问题怎么解决" class="headerlink" title="雪崩、穿透、击穿问题怎么解决"></a>雪崩、穿透、击穿问题怎么解决</h4><ul>
<li>雪崩，不同过期时间</li>
<li>穿透，即查询不存在数据。无数据时设定假数据，有时进行更新</li>
<li>击穿，互斥锁</li>
</ul>
<h4 id="Redis的内存用完了会发生什么"><a href="#Redis的内存用完了会发生什么" class="headerlink" title="Redis的内存用完了会发生什么"></a>Redis的内存用完了会发生什么</h4><ul>
<li>新增报错，但旧数据可查询</li>
<li>等待Key过期与LRU删除</li>
</ul>
<h4 id="在项目里面缓存是怎么用的"><a href="#在项目里面缓存是怎么用的" class="headerlink" title="在项目里面缓存是怎么用的"></a>在项目里面缓存是怎么用的</h4><ul>
<li>修改频次低的数据缓存到Redis进行快速查询反馈，权限模块功能权限的缓存</li>
<li>队列使用，redission.getBlockingQueue(queueName)，多节点消费使用同一中间件新增List数据判定是否全部处理，出库模块</li>
<li>redission锁，高并发修改数据时进行锁定</li>
</ul>
<h4 id="用Redis实现一个成绩的排序"><a href="#用Redis实现一个成绩的排序" class="headerlink" title="用Redis实现一个成绩的排序"></a>用Redis实现一个成绩的排序</h4><ul>
<li>Sorted Set</li>
</ul>
<h4 id="高并发下，redis和mysql双写一致性如何保证"><a href="#高并发下，redis和mysql双写一致性如何保证" class="headerlink" title="高并发下，redis和mysql双写一致性如何保证"></a>高并发下，redis和mysql双写一致性如何保证</h4><ul>
<li>旁路缓存读写模式</li>
</ul>
<h4 id="Redis-Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致"><a href="#Redis-Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致" class="headerlink" title="Redis Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致"></a>Redis Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致</h4><h4 id="Redis-存在线程安全问题吗"><a href="#Redis-存在线程安全问题吗" class="headerlink" title="Redis 存在线程安全问题吗"></a>Redis 存在线程安全问题吗</h4><h4 id="Redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h4><h4 id="Redis-大量Key集中过期，为什么这时访问Redis其他Key有延迟"><a href="#Redis-大量Key集中过期，为什么这时访问Redis其他Key有延迟" class="headerlink" title="Redis 大量Key集中过期，为什么这时访问Redis其他Key有延迟"></a>Redis 大量Key集中过期，为什么这时访问Redis其他Key有延迟</h4><ul>
<li>单线程问题导致。Redis必须在数据过期清理任务结束后才能响应后续访问任务，因此会导致访问延迟</li>
<li>过期策略<ul>
<li>主动过期：LRU删除，每100ms挑20个Key，如果过期比例超25%则循环删除直至比例低于25%或当前任务时间时间超过25ms才退出循环</li>
<li>懒惰过期：访问到Key时如果过期则删除</li>
</ul>
</li>
</ul>
<h4 id="Redis锁弊端"><a href="#Redis锁弊端" class="headerlink" title="Redis锁弊端"></a>Redis锁弊端</h4><h3 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h3><h4 id="RedLock红锁算法"><a href="#RedLock红锁算法" class="headerlink" title="RedLock红锁算法"></a>RedLock红锁算法</h4><h4 id="Redission细节源码"><a href="#Redission细节源码" class="headerlink" title="Redission细节源码"></a>Redission细节源码</h4><h4 id="分布式锁超时问题怎么解决"><a href="#分布式锁超时问题怎么解决" class="headerlink" title="分布式锁超时问题怎么解决"></a>分布式锁超时问题怎么解决</h4><ul>
<li>Watchdog</li>
</ul>
<h2 id="DataBase相关"><a href="#DataBase相关" class="headerlink" title="DataBase相关"></a>DataBase相关</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="OLTP与OLAP联系与区别"><a href="#OLTP与OLAP联系与区别" class="headerlink" title="OLTP与OLAP联系与区别"></a>OLTP与OLAP联系与区别</h4><h3 id="MyBatis相关"><a href="#MyBatis相关" class="headerlink" title="MyBatis相关"></a>MyBatis相关</h3><h4 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h4><p>区分一级缓存和二级缓存</p>
<ul>
<li><p>一级缓存</p>
<p>强制开启，同一事务同一语句优先命中一级缓存。</p>
<p>执行参数通过算法生成Cache-Key，结果为Value，存储结构为Map</p>
<p>任何Update、Insert、Delete语句都会清除缓存</p>
</li>
<li><p>二级缓存</p>
<p>非强制开启，外部存储介质，以不同NameSpace隔离。</p>
<p>多Instance状态下，应用A更改 NameSpace-A缓存，不会变更NameSpace-B缓存，当应用B访问会获得错误结果</p>
<p>不建议开启</p>
</li>
</ul>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="IP地址如何在数据库中存储"><a href="#IP地址如何在数据库中存储" class="headerlink" title="IP地址如何在数据库中存储"></a>IP地址如何在数据库中存储</h4><ul>
<li><p>32位UNSIGNED INT类型存储</p>
</li>
<li><p>节省空间，不管是数据存储空间，还是索引存储空间</p>
</li>
<li><p>便于使用范围查询（BETWEEN…AND），且效率更高</p>
</li>
<li><p>Java代码中的 移位操作 和 &amp; 计算</p>
</li>
<li><p>MYSQL 命令 inet_aton() 命令将IP字符串转化为数字类型，inet_ntoa 命令将数字转化为字符串IP</p>
</li>
</ul>
<h4 id="说说MySQL中SQL语句执行过程？"><a href="#说说MySQL中SQL语句执行过程？" class="headerlink" title="说说MySQL中SQL语句执行过程？"></a>说说MySQL中SQL语句执行过程？</h4><h4 id="SQL查询突然变慢如何分析"><a href="#SQL查询突然变慢如何分析" class="headerlink" title="SQL查询突然变慢如何分析"></a>SQL查询突然变慢如何分析</h4><h4 id="为什么不推荐SLECT-FROM"><a href="#为什么不推荐SLECT-FROM" class="headerlink" title="为什么不推荐SLECT * FROM"></a>为什么不推荐SLECT * FROM</h4><h4 id="千万DB数据分页怎么处理"><a href="#千万DB数据分页怎么处理" class="headerlink" title="千万DB数据分页怎么处理"></a>千万DB数据分页怎么处理</h4><h4 id="怎样防止SQL注入"><a href="#怎样防止SQL注入" class="headerlink" title="怎样防止SQL注入"></a>怎样防止SQL注入</h4><h4 id="SQL查询的索引覆盖"><a href="#SQL查询的索引覆盖" class="headerlink" title="SQL查询的索引覆盖"></a>SQL查询的索引覆盖</h4><h4 id="数据库索引的实现，为什么选择这个实现"><a href="#数据库索引的实现，为什么选择这个实现" class="headerlink" title="数据库索引的实现，为什么选择这个实现"></a>数据库索引的实现，为什么选择这个实现</h4><h4 id="MySQL索引数据结构，B-TREE与二叉树对比"><a href="#MySQL索引数据结构，B-TREE与二叉树对比" class="headerlink" title="MySQL索引数据结构，B-TREE与二叉树对比"></a>MySQL索引数据结构，B-TREE与二叉树对比</h4><h4 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h4><ul>
<li>唯一索引保证数据唯一</li>
<li>为业务常用字段建立索引</li>
<li>尽量使用数据内容少的字段作索引</li>
<li>索引尽量5个以内</li>
<li>删除不再使用的索引</li>
</ul>
<h4 id="表设计原则"><a href="#表设计原则" class="headerlink" title="表设计原则"></a>表设计原则</h4><h4 id="联合索引什么时候使用"><a href="#联合索引什么时候使用" class="headerlink" title="联合索引什么时候使用"></a>联合索引什么时候使用</h4><h4 id="Sql语句执行关键字顺序"><a href="#Sql语句执行关键字顺序" class="headerlink" title="Sql语句执行关键字顺序"></a>Sql语句执行关键字顺序</h4><h4 id="JOIN的实现原理"><a href="#JOIN的实现原理" class="headerlink" title="JOIN的实现原理"></a>JOIN的实现原理</h4><h4 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h4><h4 id="MySQL-区间查询原理"><a href="#MySQL-区间查询原理" class="headerlink" title="MySQL 区间查询原理"></a>MySQL 区间查询原理</h4><h4 id="MySQL存储引擎？MyISAM与InnoDB区别？"><a href="#MySQL存储引擎？MyISAM与InnoDB区别？" class="headerlink" title="MySQL存储引擎？MyISAM与InnoDB区别？"></a>MySQL存储引擎？MyISAM与InnoDB区别？</h4><ul>
<li>InnoDB</li>
<li>MyISAM 表锁，查询快，指针数据分离</li>
<li>InnoDB 行锁 B+ Tree，事务，指针数据聚合</li>
</ul>
<h4 id="你知道B树和B-树的区别吗？MySQL为什么使用B-树而不是B树？"><a href="#你知道B树和B-树的区别吗？MySQL为什么使用B-树而不是B树？" class="headerlink" title="你知道B树和B+树的区别吗？MySQL为什么使用B+树而不是B树？"></a>你知道B树和B+树的区别吗？MySQL为什么使用B+树而不是B树？</h4><h4 id="只用主键ID查找时-B-Tree和B-Tree哪个快"><a href="#只用主键ID查找时-B-Tree和B-Tree哪个快" class="headerlink" title="只用主键ID查找时 B+Tree和B-Tree哪个快"></a>只用主键ID查找时 B+Tree和B-Tree哪个快</h4><ul>
<li>B+Tree与B-Tree都是树结构，都只需要进行节点的查找和比较操作，查询速度较为接近</li>
<li>但是B+Tree叶子节点更稠密，因此B+Tree可能更快</li>
</ul>
<h4 id="Mysql中innoDB中的索引有什么特点"><a href="#Mysql中innoDB中的索引有什么特点" class="headerlink" title="Mysql中innoDB中的索引有什么特点"></a>Mysql中innoDB中的索引有什么特点</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366972218">https://zhuanlan.zhihu.com/p/366972218</a></p>
<h4 id="Mysql中聚簇索引和非聚簇索引的区别"><a href="#Mysql中聚簇索引和非聚簇索引的区别" class="headerlink" title="Mysql中聚簇索引和非聚簇索引的区别"></a>Mysql中聚簇索引和非聚簇索引的区别</h4><h4 id="数据库设计三大范式？开发中应该遵守吗？"><a href="#数据库设计三大范式？开发中应该遵守吗？" class="headerlink" title="数据库设计三大范式？开发中应该遵守吗？"></a>数据库设计三大范式？开发中应该遵守吗？</h4><ul>
<li>第一范式：数据库表的每一列都是不可分割的基本数据项</li>
<li>第二范式：<strong>确保表中的每列都和主键相关【符合1NF，同时非主属性完全依赖于主键】</strong>一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>
<li>第三范式：<strong>确保每列都和主键列直接相关,而不是间接相关【符合2NF，并且消除传递依赖】主键关联，没有其他数据相同，减少冗余</strong></li>
<li>尽量满足，空间换时间（JSON查询等）</li>
</ul>
<h4 id="MySQL表锁、页面锁、行锁的作用及优缺点？"><a href="#MySQL表锁、页面锁、行锁的作用及优缺点？" class="headerlink" title="MySQL表锁、页面锁、行锁的作用及优缺点？"></a>MySQL表锁、页面锁、行锁的作用及优缺点？</h4><h4 id="MySQL为什么添加索引或字段时会造成锁表"><a href="#MySQL为什么添加索引或字段时会造成锁表" class="headerlink" title="MySQL为什么添加索引或字段时会造成锁表"></a>MySQL为什么添加索引或字段时会造成锁表</h4><h4 id="你知道MySQL中redo-log、binlog、undo-log-区别与作用？"><a href="#你知道MySQL中redo-log、binlog、undo-log-区别与作用？" class="headerlink" title="你知道MySQL中redo log、binlog、undo log 区别与作用？"></a>你知道MySQL中redo log、binlog、undo log 区别与作用？</h4><h4 id="SQL优化有哪些着手点？组合索引的最左前缀原则的含义？"><a href="#SQL优化有哪些着手点？组合索引的最左前缀原则的含义？" class="headerlink" title="SQL优化有哪些着手点？组合索引的最左前缀原则的含义？"></a>SQL优化有哪些着手点？组合索引的最左前缀原则的含义？</h4><ul>
<li>慢查询日志，Explain，业务常用Key索引</li>
<li></li>
</ul>
<h4 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h4><h4 id="千万数据量的表每日ETL定时同步，如何优化查询"><a href="#千万数据量的表每日ETL定时同步，如何优化查询" class="headerlink" title="千万数据量的表每日ETL定时同步，如何优化查询"></a>千万数据量的表每日ETL定时同步，如何优化查询</h4><h4 id="说说你了解的数据库的隔离级别、MVCC"><a href="#说说你了解的数据库的隔离级别、MVCC" class="headerlink" title="说说你了解的数据库的隔离级别、MVCC"></a>说说你了解的数据库的隔离级别、MVCC</h4><h4 id="如何实现-MySQL-的读写分离？MySQL-主从复制原理是啥？如何解决-MySQL-主从同步"><a href="#如何实现-MySQL-的读写分离？MySQL-主从复制原理是啥？如何解决-MySQL-主从同步" class="headerlink" title="如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步"></a>如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步</h4><h4 id="为什么要设计事务隔离级别"><a href="#为什么要设计事务隔离级别" class="headerlink" title="为什么要设计事务隔离级别"></a>为什么要设计事务隔离级别</h4><h4 id="text-x2F-bold如何索引"><a href="#text-x2F-bold如何索引" class="headerlink" title="text&#x2F;bold如何索引"></a>text&#x2F;bold如何索引</h4><ul>
<li>存储过程促发器</li>
</ul>
<h4 id="数据宕机如何解决"><a href="#数据宕机如何解决" class="headerlink" title="数据宕机如何解决"></a>数据宕机如何解决</h4><ul>
<li><p>运维侧</p>
<ul>
<li><p>设备宕机无响应</p>
<p>主从切换&#x2F;灾备环境切换。宕机期间的数据根据redolog恢复</p>
</li>
<li><p>设备未宕机但响应慢</p>
<p>临时增大最大连接数</p>
</li>
</ul>
</li>
<li><p>开发测</p>
<ul>
<li><p>新模块新功能异常导致的DB宕机</p>
<p>回滚旧版本</p>
</li>
<li><p>根据日志查看是否由于慢查询多导致响应异常</p>
<p>待业务过高峰期进行SQL语句</p>
</li>
</ul>
</li>
</ul>
<h3 id="分布式-amp-amp-拆表"><a href="#分布式-amp-amp-拆表" class="headerlink" title="分布式 &amp;&amp; 拆表"></a>分布式 &amp;&amp; 拆表</h3><h4 id="旧服务单表，如何改造新服务多表，且新旧服务同时运行"><a href="#旧服务单表，如何改造新服务多表，且新旧服务同时运行" class="headerlink" title="旧服务单表，如何改造新服务多表，且新旧服务同时运行"></a>旧服务单表，如何改造新服务多表，且新旧服务同时运行</h4><h4 id="分表分错了后如何排查"><a href="#分表分错了后如何排查" class="headerlink" title="分表分错了后如何排查"></a>分表分错了后如何排查</h4><h4 id="如何拆表，优缺点"><a href="#如何拆表，优缺点" class="headerlink" title="如何拆表，优缺点"></a>如何拆表，优缺点</h4><h4 id="我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）"><a href="#我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）" class="headerlink" title="我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）"></a>我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）</h4><h4 id="分库分表之后，id-主键如何处理？"><a href="#分库分表之后，id-主键如何处理？" class="headerlink" title="分库分表之后，id 主键如何处理？"></a>分库分表之后，id 主键如何处理？</h4><ul>
<li>继续使用原主键简单场景，设置步长</li>
<li>低频场景，UUID</li>
<li>高频场景，雪花算法</li>
</ul>
<h4 id="表拆分后如何查询"><a href="#表拆分后如何查询" class="headerlink" title="表拆分后如何查询"></a>表拆分后如何查询</h4><h4 id="为什么分布式不推荐JOIN"><a href="#为什么分布式不推荐JOIN" class="headerlink" title="为什么分布式不推荐JOIN"></a>为什么分布式不推荐JOIN</h4><h3 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h3><h2 id="ElasticSearch相关"><a href="#ElasticSearch相关" class="headerlink" title="ElasticSearch相关"></a>ElasticSearch相关</h2><h4 id="如何瞬间完成海量数据检索"><a href="#如何瞬间完成海量数据检索" class="headerlink" title="如何瞬间完成海量数据检索"></a>如何瞬间完成海量数据检索</h4><ul>
<li>ES，倒排索引</li>
</ul>
<h4 id="ES如何加快分词搜索速度，倒排索引原理"><a href="#ES如何加快分词搜索速度，倒排索引原理" class="headerlink" title="ES如何加快分词搜索速度，倒排索引原理"></a>ES如何加快分词搜索速度，倒排索引原理</h4><h4 id="ES脑裂问题"><a href="#ES脑裂问题" class="headerlink" title="ES脑裂问题"></a>ES脑裂问题</h4><h3 id="Click-House"><a href="#Click-House" class="headerlink" title="Click House"></a>Click House</h3><h2 id="Network相关"><a href="#Network相关" class="headerlink" title="Network相关"></a>Network相关</h2><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><h4 id="TCP协议头多少字节"><a href="#TCP协议头多少字节" class="headerlink" title="TCP协议头多少字节"></a>TCP协议头多少字节</h4><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><h4 id="TCP四次挥手，挥手从服务端发起会怎么样"><a href="#TCP四次挥手，挥手从服务端发起会怎么样" class="headerlink" title="TCP四次挥手，挥手从服务端发起会怎么样"></a>TCP四次挥手，挥手从服务端发起会怎么样</h4><h4 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP UDP区别"></a>TCP UDP区别</h4><h4 id="列举几个网络通信协议"><a href="#列举几个网络通信协议" class="headerlink" title="列举几个网络通信协议"></a>列举几个网络通信协议</h4><h4 id="HTTP和HTTPS的主要区别"><a href="#HTTP和HTTPS的主要区别" class="headerlink" title="HTTP和HTTPS的主要区别"></a>HTTP和HTTPS的主要区别</h4><ul>
<li>HTTP明文传输</li>
<li>HTTPS 使用TLS (SSL) 来加密普通的HTTP 请求和响应，并对这些请求和响应进行数字签名</li>
</ul>
<h4 id="HTTPS交互过程"><a href="#HTTPS交互过程" class="headerlink" title="HTTPS交互过程"></a>HTTPS交互过程</h4><h4 id="什么是TLS"><a href="#什么是TLS" class="headerlink" title="什么是TLS"></a>什么是TLS</h4><h4 id="网络收到很多的TIME-WAIT状态包，原因以及解决方案"><a href="#网络收到很多的TIME-WAIT状态包，原因以及解决方案" class="headerlink" title="网络收到很多的TIME_WAIT状态包，原因以及解决方案"></a>网络收到很多的TIME_WAIT状态包，原因以及解决方案</h4><ul>
<li><p>原因</p>
<p>主动关闭TCP一方发送最后一个ACK后等待对方回应FIN，一般最长等待2MSL。</p>
<p>如果不等待，接收方可能因网络原因延迟，导致重传FIN包。</p>
<p>如果直接关闭，可能导致接收方获取延迟的ACK包后，旧TCP连接丢失，只能返回RST包。新TCP连接建立后，延迟包可能干扰新连接</p>
</li>
<li><p>解决方案</p>
<p>服务器tcp_tw_recycle设置为1</p>
</li>
</ul>
<h4 id="服务端出现大量CLOSE-WAIT原因及解决方案"><a href="#服务端出现大量CLOSE-WAIT原因及解决方案" class="headerlink" title="服务端出现大量CLOSE_WAIT原因及解决方案"></a>服务端出现大量CLOSE_WAIT原因及解决方案</h4><ul>
<li><p>原因</p>
<p>被建立连接服务器没有进行第三次挥手。</p>
<p>网络连接未释放，通常是服务端发生异常后未关闭或者服务器参数配置时间过长。即服务端耗时超时，客户端发起FIN请求，服务器回应ACK，此时服务器端就是CLOSE_WAITss</p>
<p>MySQL可能存在事务没有正确commit或rollback可能</p>
</li>
<li><p>解决方案</p>
<p>JAVA开发查看应用ThreadDump，查看大量线程在哪里Blocked</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1839592">https://cloud.tencent.com/developer/article/1839592</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grey-wolf/p/10936657.html">https://www.cnblogs.com/grey-wolf/p/10936657.html</a></p>
</li>
</ul>
<h4 id="RPC-HTTP区别？"><a href="#RPC-HTTP区别？" class="headerlink" title="RPC HTTP区别？"></a>RPC HTTP区别？</h4><ul>
<li>不是相同类型，HTTP是通用协议，RPC是远程调用思想，主要是对底层协议封装</li>
<li>RPC内部实现可以多种协议进行（如TCP、DUBBO），HTTP某种意义上也是RPC调用。自定义的RPC可以更高效</li>
</ul>
<h4 id="IO多路复用是否是异步"><a href="#IO多路复用是否是异步" class="headerlink" title="IO多路复用是否是异步"></a>IO多路复用是否是异步</h4><ul>
<li>处理IO时，不论是否阻塞都是同步IO</li>
<li>epoll内部每个通知等待都是异步的，都是对外部而言是同步的，底层使用epoll的框架后，可以做成异步的，只需暴露给外部的接口无需等待返回值即可</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59975081">https://www.zhihu.com/question/59975081</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473">https://www.zhihu.com/question/19732473</a></li>
</ul>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p><a target="_blank" rel="noopener" href="https://it-blog-cn.com/blogs/interview/netty.html">https://it-blog-cn.com/blogs/interview/netty.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999225355374428168">https://juejin.cn/post/6999225355374428168</a></p>
<h3 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h3><h4 id="路由器和交换机的工作原理"><a href="#路由器和交换机的工作原理" class="headerlink" title="路由器和交换机的工作原理"></a>路由器和交换机的工作原理</h4><h2 id="Middleware-相关"><a href="#Middleware-相关" class="headerlink" title="Middleware 相关"></a>Middleware 相关</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="Nginx负载均衡策略，相关场景"><a href="#Nginx负载均衡策略，相关场景" class="headerlink" title="Nginx负载均衡策略，相关场景"></a>Nginx负载均衡策略，相关场景</h4><h4 id="Nginx如何识别移动端PC端"><a href="#Nginx如何识别移动端PC端" class="headerlink" title="Nginx如何识别移动端PC端"></a>Nginx如何识别移动端PC端</h4><h4 id="Nginx动静分离如何实现"><a href="#Nginx动静分离如何实现" class="headerlink" title="Nginx动静分离如何实现"></a>Nginx动静分离如何实现</h4><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><h4 id="大文件怎么读取分割记录并保持顺序"><a href="#大文件怎么读取分割记录并保持顺序" class="headerlink" title="大文件怎么读取分割记录并保持顺序"></a>大文件怎么读取分割记录并保持顺序</h4><h2 id="Tools-相关"><a href="#Tools-相关" class="headerlink" title="Tools 相关"></a>Tools 相关</h2><h4 id="分布式锁在项目上的使用"><a href="#分布式锁在项目上的使用" class="headerlink" title="分布式锁在项目上的使用"></a>分布式锁在项目上的使用</h4><ul>
<li>redission</li>
<li>数据库根据数据增删</li>
</ul>
<h2 id="Theory-相关"><a href="#Theory-相关" class="headerlink" title="Theory 相关"></a>Theory 相关</h2><h4 id="CAP定理和BASE理论"><a href="#CAP定理和BASE理论" class="headerlink" title="CAP定理和BASE理论"></a>CAP定理和BASE理论</h4><ul>
<li><p>CAP</p>
<ul>
<li>Consistency 一致性 （节点中所有可用数据）<ul>
<li>分布式系统下，一致性指的是数据在多个副本中保证一致性</li>
</ul>
</li>
<li>Availability 可用性 （每个请求都能在有限时间内得到回应）<ul>
<li>服务需要一直处于可用状态，对于每一个用户操作都能在有限时间内响应结果</li>
</ul>
</li>
<li>Partition Tolerance 分区容错性 （保证分散的数据之间能够联通）<ul>
<li>不同分区数据不能因故障无法联通，提高容错性就是增加节点将数据复制到这部分节点上。</li>
<li>提高数据节点存在越多，容忍性越高，但要复制的数据就越多，一致性就越难保证。保证一致性需要等待所有节点写入成功，但会带来可用性问题。</li>
<li>为了保证一致性，更新数据节点时间就会延长，可用性就会降低。</li>
</ul>
</li>
<li><strong>同时只能满足其中两项</strong><ul>
<li>集群主机分散，节点、网络故障是常态，因此一般需要保证P和A，舍弃C</li>
</ul>
</li>
</ul>
</li>
<li><p>BASE</p>
<ul>
<li>BA - <strong>B</strong>asically <strong>A</strong>vailable<ul>
<li>出现不可预知故障时，允许部分节点失效，但要保证整个系统仍处于基本可用状态</li>
</ul>
</li>
<li>Soft state <ul>
<li>允许数据在不同副本上有一定延迟同步。mysql replication的异步复制也是一种体现。</li>
</ul>
</li>
<li>Eventually consistent<ul>
<li>存储在数据没有新的更新状态下，系统所有副本在到达某个时间节点后，数据达到同步状态。</li>
</ul>
</li>
<li><strong>最终一致性是弱一致性的一种特殊情况</strong></li>
</ul>
</li>
<li><p>弱一致性与最终一致性区别</p>
<p>弱一致性即使过了不一致时间窗口，后续的读取也不一定能保证一致，而最终一致过了不一致窗口后，后续的读取一定一致，才能说清楚弱一致和最终一致的区别</p>
</li>
<li><p>CAP与BASE关系</p>
<ul>
<li>在分布式的数据系统中，你能保证下面三个要求中的两个：一致性，可用性，以及分区容错性。在此模型上构建的系统将称作 BASE(基本上可用软状态最终一致)架构，不满足 ACID 性质。</li>
</ul>
</li>
<li><p>ACID</p>
<ul>
<li>Automicity 原子性<ul>
<li>一个事务必须被视为不可被分割的最小工作单元</li>
</ul>
</li>
<li>Consistency 一致性<ul>
<li>数据库总是从一个一致性状态切换到另一个一致性状态</li>
</ul>
</li>
<li>Isolation 隔离性<ul>
<li>一个事务中对数据的变更在提交之前，对于其他事务是不可见的</li>
</ul>
</li>
<li>Durablity 持久性<ul>
<li>一旦提交事务，则所做的修改永久写入磁盘</li>
</ul>
</li>
<li><strong>强一致性</strong></li>
</ul>
</li>
</ul>
<h4 id="什么是Serverless"><a href="#什么是Serverless" class="headerlink" title="什么是Serverless"></a>什么是Serverless</h4><ul>
<li>无状态，即方法执行结束后，不改变类的状态，不变更全局参数</li>
</ul>
<h4 id="如何向面试官证明你做的系统是高可用的？"><a href="#如何向面试官证明你做的系统是高可用的？" class="headerlink" title="如何向面试官证明你做的系统是高可用的？"></a>如何向面试官证明你做的系统是高可用的？</h4><ul>
<li>SLA 服务等级协议（Service-Level Agreement，SLA）</li>
<li>服务监控措施<ul>
<li>系统要素指标：主要有 CPU、内存，和磁盘。</li>
<li>网络要素指标：主要有带宽、网络 I&#x2F;O、CDN、DNS、安全策略、和负载策略。</li>
</ul>
</li>
<li>监控报警策略</li>
<li>系统应用策略</li>
</ul>
<h4 id="UV-x2F-PV"><a href="#UV-x2F-PV" class="headerlink" title="UV&#x2F;PV"></a>UV&#x2F;PV</h4><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><h2 id="Other-1"><a href="#Other-1" class="headerlink" title="Other"></a>Other</h2><h4 id="估算某城市的便利店数量"><a href="#估算某城市的便利店数量" class="headerlink" title="估算某城市的便利店数量"></a>估算某城市的便利店数量</h4><ul>
<li>品牌连锁</li>
<li>自营根据人口密度估算</li>
</ul>
<h4 id="CPU占用突然升高该怎么分析"><a href="#CPU占用突然升高该怎么分析" class="headerlink" title="CPU占用突然升高该怎么分析"></a>CPU占用突然升高该怎么分析</h4><ul>
<li>如果是业务量突然增加，考虑扩容问题</li>
<li>如果业务量没变，则查看当前运行程序是否有出现死锁等问题，可以打ThreadDump等查看</li>
</ul>
<h4 id="常用的高可用方案"><a href="#常用的高可用方案" class="headerlink" title="常用的高可用方案"></a>常用的高可用方案</h4><h4 id="有哪些MHA结构的方案"><a href="#有哪些MHA结构的方案" class="headerlink" title="有哪些MHA结构的方案"></a>有哪些MHA结构的方案</h4><h4 id="怎样表达滑动窗口限流"><a href="#怎样表达滑动窗口限流" class="headerlink" title="怎样表达滑动窗口限流"></a>怎样表达滑动窗口限流</h4><h4 id="查询接口调优，不用缓存且要求实时性，如何调优"><a href="#查询接口调优，不用缓存且要求实时性，如何调优" class="headerlink" title="查询接口调优，不用缓存且要求实时性，如何调优"></a>查询接口调优，不用缓存且要求实时性，如何调优</h4>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/09/Spring-Transaction/" rel="prev" title="Spring 事务">
      <i class="fa fa-chevron-left"></i> Spring 事务
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/16/Garbage-Cllection-Algorithms-And-Implementations-P1/" rel="next" title="垃圾回收的算法与实现 笔记 Part1">
      垃圾回收的算法与实现 笔记 Part1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">Java面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.</span> <span class="nav-text">编程思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">设计模式有哪些原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">设计模式理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">编程规范理解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="nav-number">1.2.</span> <span class="nav-text">算法相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Easy"><span class="nav-number">1.2.1.</span> <span class="nav-text">Easy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88leecode121%EF%BC%89"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">买卖股票的最佳时机（leecode121）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-LeetCode-21"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">合并两个有序链表(LeetCode 21)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC-LeetCode-206"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">单链表反转(LeetCode 206)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Middle"><span class="nav-number">1.2.2.</span> <span class="nav-text">Middle</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%95%B0-LeetCode179"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">最大数(LeetCode179)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-LeetCode-165"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">版本号比较(LeetCode 165)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%E5%92%8C%E5%85%B6%E4%BB%96%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">什么是红黑树？和其他树有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">计算机内存管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.</span> <span class="nav-text">Java 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Java基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#float%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">float如何判断是否为0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%90%86%E8%A7%A3"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Java包装类型理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">Java面向对象特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">接口能不能实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E7%B1%BB%E4%B9%88%EF%BC%8C%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88-%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99Equals%E4%B8%80%E5%AE%9A%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99HashCode"><span class="nav-number">1.4.1.7.</span> <span class="nav-text">为什么重写Equals一定也要重写HashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E5%BC%82%E6%88%96%E4%B8%A4%E6%AC%A1%E7%AD%89%E4%BA%8E%E6%B2%A1%E6%9C%89%E5%BC%82%E6%88%96"><span class="nav-number">1.4.1.8.</span> <span class="nav-text">对一个数异或两次等于没有异或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#float%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%80%8E%E4%B9%88%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.4.1.9.</span> <span class="nav-text">float在内存中怎么表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.1.10.</span> <span class="nav-text">数组动态分配内存如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.11.</span> <span class="nav-text">如何防止非原子操作的冲突问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.4.1.12.</span> <span class="nav-text">什么是哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%A7%E8%87%B4%E5%90%AB%E4%B9%89"><span class="nav-number">1.4.1.13.</span> <span class="nav-text">Object 常用方法及每个方法的大致含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8JDK1-5%E4%B8%AD%E5%BC%95%E5%85%A5%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%98%E5%9C%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.14.</span> <span class="nav-text">在JDK1.5中引入了泛型，泛型的存在是用来解决什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD2%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="nav-number">1.4.1.15.</span> <span class="nav-text">有没有可能2个不相等的对象有相同的hashcode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E5%87%A0%E4%B8%AA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.16.</span> <span class="nav-text">举例几个树形结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.17.</span> <span class="nav-text">Error和Exception的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-number">1.4.1.18.</span> <span class="nav-text">你知道什么是指令重排序？为什么要重排序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%9C%A8Java%E4%B8%AD%E5%AE%83%E8%B7%9Fsynchronized%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">1.4.1.19.</span> <span class="nav-text">Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Overload%E3%80%81Override%E3%80%81Overwrite%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.20.</span> <span class="nav-text">Overload、Override、Overwrite的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.4.1.21.</span> <span class="nav-text">什么是浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%83%E5%AF%B9%E5%86%99%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%B8%AE%E5%8A%A9"><span class="nav-number">1.4.1.22.</span> <span class="nav-text">什么是不可变对象，它对写并发应用有什么帮助</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.4.1.23.</span> <span class="nav-text">如何创建不可变的类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E8%83%BD%E4%B8%8D%E8%83%BD%E6%9C%89%E5%AD%90%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E8%A2%AB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.1.24.</span> <span class="nav-text">String能不能有子类，为什么 String 被设计为是不可变的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.4.1.25.</span> <span class="nav-text">描述动态代理的几种实现方式，分别说出相应的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">1.4.1.26.</span> <span class="nav-text">JAVA实现反射的两种方式？为什么要这样设计？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.1.27.</span> <span class="nav-text">JAVA的反射机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89"><span class="nav-number">1.4.1.28.</span> <span class="nav-text">怎么保证幂等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%8CJava%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.1.29.</span> <span class="nav-text">什么是原子操作，Java中的原子操作是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.1.30.</span> <span class="nav-text">如何同步一个原子操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-amp-amp-Map-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.2.</span> <span class="nav-text">List &amp;&amp; Map 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E7%90%86%E8%A7%A3%EF%BC%8CMap%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8CHashMap%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Java集合理解，Map的理解，HashMap关键属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMap%E7%B1%BB%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CHashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">用过哪些Map类，都有什么区别，HashMap是线程安全的吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F1W%EF%BC%8C%E5%AD%981W%E4%B8%AA%E6%98%AF%E5%90%A6%E4%BC%9A%E6%89%A9%E5%AE%B9"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">HashMap初始化容量1W，存1W个是否会扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">解决Hash冲突的办法有哪些？HashMap用的哪种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87K-V%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">HashMap如何通过K-V管理数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A92%E7%9A%84%E5%80%8D%E6%95%B0%E5%BD%93%E4%BD%9C%E5%AE%B9%E9%87%8F"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">HashMap为什么选择2的倍数当作容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%88%9D%E5%A7%8B%E4%B8%BA%E4%BB%80%E4%B9%8816"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">HashMap初始为什么16</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF0-75"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">HashMap因子为什么是0.75</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E6%89%A9%E5%AE%B9%E5%90%8E%E5%A6%82%E4%BD%95%E5%86%8D%E6%95%A3%E5%88%97"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">HashMap扩容后如何再散列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%9C%A8Java-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%BF%9B%E5%85%A5%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.4.2.10.</span> <span class="nav-text">HashMap在Java 7 为什么会进入死循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%9C%A8Java%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">1.4.2.11.</span> <span class="nav-text">HashMap在Java内部是如何工作的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%AD%98%E5%82%A8%E9%87%8F%E5%8F%98%E6%9B%B4%E6%97%B6%E5%88%87%E6%8D%A2%E7%BB%93%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2"><span class="nav-number">1.4.2.12.</span> <span class="nav-text">HashMap为什么要在存储量变更时切换结构，如何切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.13.</span> <span class="nav-text">ConcurrentHashMap如何解决安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Java-8%E6%94%BE%E5%BC%83%E4%BA%86%E5%88%86%E6%AE%B5%E9%94%81"><span class="nav-number">1.4.2.14.</span> <span class="nav-text">ConcurrentHashMap为什么在Java 8放弃了分段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E5%9C%A8Java-7%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.15.</span> <span class="nav-text">ConcurrentHashMap在Java 7性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F%E4%BD%A0%E7%9F%A5%E9%81%93Java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.2.16.</span> <span class="nav-text">什么是阻塞队列？你知道Java中有哪些阻塞队列吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">1.4.2.17.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8Java%E5%86%99%E4%BB%A3%E7%A0%81%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.18.</span> <span class="nav-text">用Java写代码来解决生产者——消费者问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-amp-amp-Lock-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.3.</span> <span class="nav-text">Thread &amp;&amp; Lock 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E8%83%BD%E8%8A%82%E7%9C%81%E6%97%B6%E9%97%B4%E5%90%97"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">进程和线程的区别，使用线程真的能节省时间吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">线程实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">线程有几种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%9F%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%8F%91%E7%8E%B0%E5%92%8C%E8%A7%A3%E5%86%B3%E7%AB%9E%E4%BA%89"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">什么是竞争条件？你怎样发现和解决竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%ADCyclicBarrier%E5%92%8CCountdownLatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">在Java中CyclicBarrier和CountdownLatch有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">你知道哪几种锁？分别有什么特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronize%E9%94%81%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">synchronize锁有几种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9Fsynchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FLock%E6%8E%A5%E5%8F%A3%E6%AF%94synchronized%E5%9D%97%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JUC%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%E4%BA%8Esynchronized%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.9.</span> <span class="nav-text">JUC提供的锁于synchronized有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java-11%E5%8F%96%E6%B6%88synchronized%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">1.4.3.10.</span> <span class="nav-text">为什么Java 11取消synchronized锁升级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E6%98%AF%E5%90%A6%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.4.3.11.</span> <span class="nav-text">volatile是否能保证线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3"><span class="nav-number">1.4.3.12.</span> <span class="nav-text">伪共享怎么理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%8C%E5%AE%83%E5%85%81%E8%AE%B8%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E8%AF%BB%EF%BC%8C%E4%BD%86%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%86%99%EF%BC%8C%E4%BB%A5%E6%AD%A4%E6%9D%A5%E4%BF%9D%E6%8C%81%E5%AE%83%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E6%A0%B7%E5%8E%BB%E5%AE%9E%E7%8E%B0%E5%AE%83%EF%BC%9F"><span class="nav-number">1.4.3.13.</span> <span class="nav-text">你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%B8%A6%E6%9D%A5%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.14.</span> <span class="nav-text">为什么多线程会带来性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-sleep-Object-wait-LockSupport-park-Condition-await-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.15.</span> <span class="nav-text">Thread.sleep(), Object.wait(), LockSupport.park(),Condition.await()区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E6%80%8E%E6%A0%B7%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.3.16.</span> <span class="nav-text">Java中怎样唤醒一个阻塞的线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait%E4%B8%8Eawait%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.17.</span> <span class="nav-text">wait与await区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-sleep-0-%E7%9B%AE%E7%9A%84"><span class="nav-number">1.4.3.18.</span> <span class="nav-text">Thread.sleep(0)目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-yield"><span class="nav-number">1.4.3.19.</span> <span class="nav-text">Thread.yield()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.3.20.</span> <span class="nav-text">在Java中线程间有哪些通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88AtomicInteger%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A5%BD"><span class="nav-number">1.4.3.21.</span> <span class="nav-text">为什么AtomicInteger在高并发下性能不好</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.3.22.</span> <span class="nav-text">有哪些解决死锁问题的策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.23.</span> <span class="nav-text">有哪些线程安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.3.24.</span> <span class="nav-text">线程池有哪几种拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start-%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5"><span class="nav-number">1.4.3.25.</span> <span class="nav-text">一个线程两次调用start()方法会出现什么情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD"><span class="nav-number">1.4.3.26.</span> <span class="nav-text">线程如何中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="nav-number">1.4.3.27.</span> <span class="nav-text">线程如何停止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E8%B5%84%E6%BA%90%EF%BC%8C%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%AB%98%E6%95%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.3.28.</span> <span class="nav-text">线程读写资源，在不使用锁的情况下高效实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%94%A8%E5%88%B0%E8%BF%87ThreadLocal%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.3.29.</span> <span class="nav-text">ThreadLocal是什么？你在工作中用到过ThreadLocal吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.4.3.30.</span> <span class="nav-text">ThreadLocal怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="nav-number">1.4.3.31.</span> <span class="nav-text">ThreadLocal 内存泄露是怎么回事</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.3.32.</span> <span class="nav-text">ThreadLocalMap的结构了解吗？扩容机制了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">1.4.3.33.</span> <span class="nav-text">ThreadLocal父子线程怎么共享数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%8E%82%E8%A7%84%E5%AE%9A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8Executors%E5%8E%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.4.3.34.</span> <span class="nav-text">为什么大厂规定不能使用Executors去创建线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E9%9C%80%E8%A6%81%EF%BC%8C%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.4.3.35.</span> <span class="nav-text">如何根据实际需要，定制自己的线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-AQS%EF%BC%9FAQS-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E9%87%8D%E8%A6%81%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.3.36.</span> <span class="nav-text">你知道为什么需要 AQS？AQS 的作用和重要性是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.4.3.37.</span> <span class="nav-text">CAS是一种什么样的同步机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.3.38.</span> <span class="nav-text">你知道CAS 有什么缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E2%80%9D%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.3.39.</span> <span class="nav-text">你知道线程池实现“线程复用”的原理吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.3.40.</span> <span class="nav-text">阻塞和非阻塞队列的并发安全原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9%E2%80%9C%E5%85%AC%E5%B9%B3%E9%94%81%E2%80%9D%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E2%80%9C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E2%80%9D%EF%BC%9F"><span class="nav-number">1.4.3.41.</span> <span class="nav-text">你对“公平锁”了解吗？为什么会有“非公平锁”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9%E2%80%9C%E8%87%AA%E6%97%8B%E9%94%81%E2%80%9D%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.3.42.</span> <span class="nav-text">你对“自旋锁”了解吗？优缺点分别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E9%80%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9FCPU-%E6%A0%B8%E5%BF%83%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.4.3.43.</span> <span class="nav-text">合适的线程数量是多少？CPU 核心数和线程数的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%AE%83%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.3.44.</span> <span class="nav-text">你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8java%E4%B8%AD%E7%BB%BF%E8%89%B2%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.45.</span> <span class="nav-text">在java中绿色线程和本地线程区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.46.</span> <span class="nav-text">死锁与活锁的区别，死锁与饥饿的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.3.47.</span> <span class="nav-text">Java中用到的线程调度算法是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.3.48.</span> <span class="nav-text">在线程中怎么处理不可捕捉异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%BB%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Java%E4%B8%AD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.3.49.</span> <span class="nav-text">什么是线程组，为什么在Java中不推荐使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Executor%E6%A1%86%E6%9E%B6%E6%AF%94%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B%E5%A5%BD"><span class="nav-number">1.4.3.50.</span> <span class="nav-text">为什么使用Executor框架比使用应用创建和管理线程好</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%ADExecutor%E5%92%8CExecutors%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.3.51.</span> <span class="nav-text">在Java中Executor和Executors的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E5%92%8CLinux%E4%B8%8A%E6%9F%A5%E6%89%BE%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84CPU%E6%97%B6%E9%97%B4%E6%9C%80%E9%95%BF"><span class="nav-number">1.4.3.52.</span> <span class="nav-text">如何在Windows和Linux上查找哪个线程使用的CPU时间最长</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other"><span class="nav-number">1.4.4.</span> <span class="nav-text">Other</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A810%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">如何用10行代码实现一个负载均衡服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BE%E4%B8%87%E6%96%87%E4%BB%B6%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E6%9C%89%E5%BE%88%E5%A4%9A%E6%B1%89%E5%AD%97%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%90%8C%E3%80%82%E5%81%87%E8%AE%BE1000%E4%B8%AA%E6%B1%89%E5%AD%97%EF%BC%8C%E9%97%AE%E6%80%8E%E6%A0%B7%E7%BB%9F%E8%AE%A1%E5%87%BA%E8%BF%99%E4%BA%9B%E6%96%87%E4%BB%B6%E9%87%8C%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B1%89%E5%AD%97"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA-LIST%E6%9F%A5%E8%AF%A2%E8%BF%87%E5%A4%A7%E5%AE%B9%E6%98%93OOM%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">JAVA LIST查询过大容易OOM解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8Java%E7%BC%96%E7%A8%8B%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%A0%E5%B0%86%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">用Java编程一个会导致死锁的程序，你将怎么解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.5.</span> <span class="nav-text">IO相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%87%A0%E7%A7%8DCopy%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%93%AA%E7%A7%8D%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Java几种Copy方式，哪种效率最高</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.5.</span> <span class="nav-text">JMM 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">JMM模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E2%80%9D%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">什么是“内存可见性”问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">你知道主内存和工作内存的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF-happens-before-%E5%8E%9F%E5%88%99%E5%90%97%EF%BC%9F"><span class="nav-number">1.5.0.4.</span> <span class="nav-text">你知道什么是 happens-before 原则吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%AA%97%E5%8F%A3%E6%9C%9F"><span class="nav-number">1.5.0.5.</span> <span class="nav-text">JAVA创建对象时是否存在窗口期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.</span> <span class="nav-text">JVM 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-GCRoots%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">JVM GCRoots对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%BE%BE"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">什么是不可达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A%E3%80%81B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%9B%9E%E6%94%B6%EF%BC%8C%E4%B8%80%E5%AE%9A%E5%B0%B1%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">A、B对象可回收，一定就会被回收吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.0.4.</span> <span class="nav-text">JVM结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.6.0.5.</span> <span class="nav-text">为什么要分新生代老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E6%8D%A2%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="nav-number">1.6.0.6.</span> <span class="nav-text">为什么用元空间替换永久代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.1.</span> <span class="nav-text">ClassLoader相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">简单说说你了解的类加载器，可以打破双亲委派么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAjava-lang-String%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">如果创建一个java.lang.String类，这个类是否可以被类加载器加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">JVM是如何处理异常的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finnal%E3%80%81finnally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">finnal、finnally、finalize的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Garbage-Collection"><span class="nav-number">1.6.2.</span> <span class="nav-text">Garbage Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%90%AF%E5%8A%A8"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">GC什么时候启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutator"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Mutator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">基本算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">垃圾收集器有哪几种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%AE%80%E8%BF%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">CMS是什么，简述工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E7%BC%BA%E9%99%B7"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">CMS缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%85%8D%E7%BD%AE%E4%BA%86CMS-GC%E4%BB%8D%E7%84%B6%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">为什么配置了CMS GC仍然会触发Full GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1"><span class="nav-number">1.6.2.8.</span> <span class="nav-text">G1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E8%B0%83%E4%BC%98"><span class="nav-number">1.6.2.9.</span> <span class="nav-text">GC调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.10.</span> <span class="nav-text">内存溢出和内存泄漏区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%91%E7%B9%81Young-GC%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.6.2.11.</span> <span class="nav-text">频繁Young GC原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.7.</span> <span class="nav-text">Spring 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RestController%E4%B8%8EController%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">RestController与Controller区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestBody%E4%B8%8EResponseBody%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">RequestBody与ResponseBody区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">Spring底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.7.0.4.</span> <span class="nav-text">Spring事务底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.0.5.</span> <span class="nav-text">IOC理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC%E4%B8%BB%E8%A6%81%E5%AE%B9%E5%99%A8"><span class="nav-number">1.7.0.6.</span> <span class="nav-text">IOC主要容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.7.0.7.</span> <span class="nav-text">Spring生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Bean%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.0.8.</span> <span class="nav-text">Spring Bean加载初始化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.0.9.</span> <span class="nav-text">AOP原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory%E4%B8%8EFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.0.10.</span> <span class="nav-text">BeanFactory与FactoryBean的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E4%B8%ADBean%E9%BB%98%E8%AE%A4%E6%98%AFSingleton%E8%BF%98%E6%98%AF%E5%A4%9A%E6%80%81%E7%9A%84"><span class="nav-number">1.7.0.11.</span> <span class="nav-text">Spring中Bean默认是Singleton还是多态的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4Singleton"><span class="nav-number">1.7.0.12.</span> <span class="nav-text">为什么默认Singleton</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC"><span class="nav-number">1.7.1.</span> <span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">SpringMVC工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">SpringMVC组件工作流程，如果不这么设计会有什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%93%BE%E8%B7%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%B9%E6%B3%95%E6%AF%94%E5%AF%B9"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">检查拦截器的执行链路在哪个方法比对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">Spring有几种依赖注入方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">Spring有几种异步调用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.7.1.6.</span> <span class="nav-text">如何解决跨域，原理是什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.7.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%EF%BC%8C%E8%A2%AB%E8%B0%83%E7%94%A8%E7%B1%BB%E5%B7%B2Catch%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%BA%E4%BD%95-Transactional%E4%BB%8D%E7%84%B6%E5%9B%9E%E6%BB%9A"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">Service相互调用，被调用类已Catch异常，为何@Transactional仍然回滚</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%89%B4%E6%9D%83"><span class="nav-number">1.7.3.</span> <span class="nav-text">鉴权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SSO%E4%B8%8EOAuth2%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">SSO与OAuth2有什么不同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.8.</span> <span class="nav-text">SpringBoot 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">SpringBoot 生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%9F%E6%8E%A8%E8%8D%90%E5%92%8C%E9%BB%98%E8%AE%A4%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-Starter%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.0.4.</span> <span class="nav-text">SpringBoot Starter的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.0.5.</span> <span class="nav-text">SpringBoot事务的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.8.0.6.</span> <span class="nav-text">声明式事务失效原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Async%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.0.7.</span> <span class="nav-text">Async异步调用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Spring-Boot-%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%90%E8%A1%8C%E4%B8%80%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="nav-number">1.8.0.8.</span> <span class="nav-text">如何在 Spring Boot 启动的时候运行一些特定的代码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.8.0.9.</span> <span class="nav-text">Spring Boot 有哪几种读取配置的方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bootstrap-properties-%E5%92%8C-application-properties-%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="nav-number">1.8.0.10.</span> <span class="nav-text">bootstrap.properties 和 application.properties 有何异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.0.11.</span> <span class="nav-text">跨域问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.8.0.12.</span> <span class="nav-text">SpringBoot异常处理相关注解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E9%85%8D%E7%BD%AE%E7%9B%91%E6%8E%A7"><span class="nav-number">1.8.0.13.</span> <span class="nav-text">SpringBoot配置监控?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Cloud-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.9.</span> <span class="nav-text">Spring Cloud 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%EF%BC%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%EF%BC%9F"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">为什么要进行系统拆分？如何进行系统拆分？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E9%80%9A%E8%AE%AF%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">什么是微服务？微服务之间是如何独立通讯的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.9.0.3.</span> <span class="nav-text">微服务架构优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%80%9A%E4%BF%A1"><span class="nav-number">1.9.0.4.</span> <span class="nav-text">服务之间如何快速通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenFeign%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.0.5.</span> <span class="nav-text">OpenFeign底层调用原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E5%92%8C-Spring-Cloud%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.9.0.6.</span> <span class="nav-text">Spring Boot 和 Spring Cloud，谈谈你对它们的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%AF%94%E5%A6%82%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E6%89%A3%E6%AC%BE%EF%BC%89%EF%BC%9F"><span class="nav-number">1.9.0.7.</span> <span class="nav-text">分布式服务接口的幂等性如何设计（比如不能重复扣款）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E6%B5%81%EF%BC%9F%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.9.0.8.</span> <span class="nav-text">如何限流？在工作中是怎么做的？说一下具体的实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F-Session-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.9.0.9.</span> <span class="nav-text">集群分布式 Session 如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.9.0.10.</span> <span class="nav-text">如何设计一个高并发的系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFC10K%E9%97%AE%E9%A2%98%EF%BC%8C%E5%90%8E%E6%9D%A5%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="nav-number">1.9.0.11.</span> <span class="nav-text">请解释一下什么是C10K问题，后来是怎么解决的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E9%99%A4%E4%BA%86%E5%8A%A0%E9%94%81%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.9.0.12.</span> <span class="nav-text">高并发除了加锁还有什么解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Cloud-%E5%92%8C-Dubbo-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.9.0.13.</span> <span class="nav-text">Spring Cloud 和 Dubbo 有哪些区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Eureka%E5%92%8Czookeeper%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%B8%A4%E4%B8%AA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.9.0.14.</span> <span class="nav-text">Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E4%BD%9C%E7%94%A8"><span class="nav-number">1.9.0.15.</span> <span class="nav-text">Nacos作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.9.0.16.</span> <span class="nav-text">Nacos优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E5%92%8CZookeeper%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.0.17.</span> <span class="nav-text">Nacos和Zookeeper区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringCloud%E5%87%A0%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">1.9.0.18.</span> <span class="nav-text">SpringCloud几个组件主要功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo"><span class="nav-number">1.9.1.</span> <span class="nav-text">Dubbo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">Dubbo 负载均衡策略都有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">Dubbo 的工作原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E3%80%81%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E4%BB%A5%E5%8F%8A%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%EF%BC%9F"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E8%B6%85%E6%97%B6%E5%86%85%E9%83%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%B0%83%E7%94%A8%E6%96%B9%E5%B7%B2%E7%BB%8F%E8%B6%85%E6%97%B6%E4%BA%A7%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BA%86%EF%BC%8C%E6%8F%90%E4%BE%9B%E8%80%85%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E8%BF%98%E4%BC%9A%E5%90%91%E8%B0%83%E7%94%A8%E6%96%B9%E5%86%99%E8%BF%94%E5%9B%9E%E5%80%BC%E5%90%97"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E7%9A%84-SPI-%E5%92%8C-Java-%E7%9A%84-SPI-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.9.1.5.</span> <span class="nav-text">Dubbo 的 SPI 和 Java 的 SPI 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E6%80%A7"><span class="nav-number">1.9.1.6.</span> <span class="nav-text">Dubbo组件之间的关联性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC-Dubbo-%E7%9A%84-RPC-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="nav-number">1.9.1.7.</span> <span class="nav-text">如何自己设计一个类似 Dubbo 的 RPC 框架？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.9.2.</span> <span class="nav-text">分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E6%8C%81"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">分布式事务，缓存和数据库的一致性保持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1Linerizebility%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B8%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Seata%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">Seata模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.10.</span> <span class="nav-text">MQ 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.10.1.</span> <span class="nav-text">通用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E9%80%89%E5%9E%8B"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">MQ选型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Product-A%E3%80%81C%EF%BC%8CFollower-B%E3%80%81D%EF%BC%8CBind-AC-amp-amp-BD-Exchange%EF%BC%89"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">手写生产者消费者（Product A、C，Follower B、D，Bind AC &amp;&amp; BD + Exchange）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%94%A8%E8%BF%87%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%BD%93%E5%88%9D%E9%80%89%E5%9E%8B%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E8%80%83%E8%99%91%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E9%83%A8%E7%BD%B2%E6%98%AF%E5%8D%95%E6%9C%BA%E8%BF%98%E6%98%AF%E9%9B%86%E7%BE%A4%E5%91%A2%EF%BC%9F%E4%BD%A0%E4%BB%AC%E9%AB%98%E5%8F%AF%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.10.1.6.</span> <span class="nav-text">MQ有遇到过重复消费的问题吗？怎么解决的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%91%A2%EF%BC%9F"><span class="nav-number">1.10.1.7.</span> <span class="nav-text">MQ有遇到过消息丢失吗？可靠性怎么保证呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%BB%A5%E5%90%8E%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.10.1.8.</span> <span class="nav-text">如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka%E7%9B%B8%E5%85%B3"><span class="nav-number">1.10.2.</span> <span class="nav-text">Kafka相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">Kafka底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%9C%BA%E5%88%B6"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">Kafka机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">Kafka事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">如何处理消息堆积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">1.10.2.5.</span> <span class="nav-text">Kafka消息顺序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%8C%81%E4%B9%85%E5%8C%96%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E9%99%A4%E4%BA%86%E8%BF%81%E7%A7%BB%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.10.2.6.</span> <span class="nav-text">Kafka持久化内存满了除了迁移还能怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.10.2.7.</span> <span class="nav-text">零拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RocketMQ%E7%9B%B8%E5%85%B3"><span class="nav-number">1.10.3.</span> <span class="nav-text">RocketMQ相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rocketMQ%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%A6%81%E5%9C%A8broker%E7%AB%AF%E9%94%81%E5%AE%9A%E8%AF%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E4%BF%9D%E8%AF%81%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E4%BC%9A%E8%8E%B7%E5%BE%97%E8%AF%A5%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">rocketMQ保证顺序消费，为何要在broker端锁定该消息队列，保证只有一个消费者会获得该消费队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ%E7%9B%B8%E5%85%B3"><span class="nav-number">1.10.4.</span> <span class="nav-text">RabbitMQ相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.11.</span> <span class="nav-text">Cache 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">1.11.1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5%E5%92%8C%E9%9B%86%E7%BE%A4%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">Redis主从、哨兵和集群区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">Redis为什么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1Redis-Slot%E7%BB%93%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">为什么要设计Redis Slot结构，如何查找数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BARedis%E4%B8%AD%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">如何找出Redis中的慢查询记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-List%E8%BF%87%E5%A4%A7%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">1.11.1.5.</span> <span class="nav-text">Redis List过大如何优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9Redis%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84"><span class="nav-number">1.11.1.6.</span> <span class="nav-text">你们是如何对Redis进行性能优化的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-%E4%BD%BF%E7%94%A8-Redis-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8-Memcached"><span class="nav-number">1.11.1.7.</span> <span class="nav-text">为什么 使用 Redis 而不是用 Memcached</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.11.1.8.</span> <span class="nav-text">ZSet数据结构以及空间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8%E5%8E%9F%E7%90%86%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.11.1.9.</span> <span class="nav-text">跳跃列表原理怎么实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#quickList%E5%92%8CzipList%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.1.10.</span> <span class="nav-text">quickList和zipList原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.11.1.11.</span> <span class="nav-text">Redis异步消息怎么处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-5-0-%E6%96%B0%E5%A2%9EStream%E5%AF%B9%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3"><span class="nav-number">1.11.1.12.</span> <span class="nav-text">Redis 5.0 新增Stream对它有什么理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88redis7%E7%94%A8listpack%E5%8F%96%E4%BB%A3ziplist"><span class="nav-number">1.11.1.13.</span> <span class="nav-text">为什么redis7用listpack取代ziplist</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4Redis-key%E5%AF%BC%E8%87%B4Redis%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.11.1.14.</span> <span class="nav-text">大批量删除Redis key导致Redis不稳定如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">1.11.1.15.</span> <span class="nav-text">如何保证Redis高并发、高可用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.11.1.16.</span> <span class="nav-text">Redis持久化机制，以及优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.11.1.17.</span> <span class="nav-text">雪崩、穿透、击穿问题怎么解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.11.1.18.</span> <span class="nav-text">Redis的内存用完了会发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E7%BC%93%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="nav-number">1.11.1.19.</span> <span class="nav-text">在项目里面缓存是怎么用的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%88%90%E7%BB%A9%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.11.1.20.</span> <span class="nav-text">用Redis实现一个成绩的排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%EF%BC%8Credis%E5%92%8Cmysql%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="nav-number">1.11.1.21.</span> <span class="nav-text">高并发下，redis和mysql双写一致性如何保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Cluster%EF%BC%8C%E5%9C%A8Master%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%BF%94%E5%9B%9E%E5%90%8E%EF%BC%8C%E5%90%91%E8%8A%82%E7%82%B9%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%89%8DMaster%E6%8C%82%E4%BA%86%EF%BC%8C%E5%AD%90%E8%8A%82%E7%82%B9%E5%8D%87%E7%BA%A7%E5%90%8E%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4"><span class="nav-number">1.11.1.22.</span> <span class="nav-text">Redis Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">1.11.1.23.</span> <span class="nav-text">Redis 存在线程安全问题吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.1.24.</span> <span class="nav-text">Redis主从复制原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%A4%A7%E9%87%8FKey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%97%B6%E8%AE%BF%E9%97%AERedis%E5%85%B6%E4%BB%96Key%E6%9C%89%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.11.1.25.</span> <span class="nav-text">Redis 大量Key集中过期，为什么这时访问Redis其他Key有延迟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E9%94%81%E5%BC%8A%E7%AB%AF"><span class="nav-number">1.11.1.26.</span> <span class="nav-text">Redis锁弊端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redission"><span class="nav-number">1.11.2.</span> <span class="nav-text">Redission</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RedLock%E7%BA%A2%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">RedLock红锁算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redission%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">Redission细节源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">分布式锁超时问题怎么解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataBase%E7%9B%B8%E5%85%B3"><span class="nav-number">1.12.</span> <span class="nav-text">DataBase相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.12.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OLTP%E4%B8%8EOLAP%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">OLTP与OLAP联系与区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis%E7%9B%B8%E5%85%B3"><span class="nav-number">1.12.2.</span> <span class="nav-text">MyBatis相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E7%BC%93%E5%AD%98"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">MyBatis缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-number">1.12.3.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">IP地址如何在数据库中存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4MySQL%E4%B8%ADSQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">说说MySQL中SQL语句执行过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%9F%A5%E8%AF%A2%E7%AA%81%E7%84%B6%E5%8F%98%E6%85%A2%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90"><span class="nav-number">1.12.3.3.</span> <span class="nav-text">SQL查询突然变慢如何分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90SLECT-FROM"><span class="nav-number">1.12.3.4.</span> <span class="nav-text">为什么不推荐SLECT * FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%83%E4%B8%87DB%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.12.3.5.</span> <span class="nav-text">千万DB数据分页怎么处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">1.12.3.6.</span> <span class="nav-text">怎样防止SQL注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="nav-number">1.12.3.7.</span> <span class="nav-text">SQL查询的索引覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E8%BF%99%E4%B8%AA%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.3.8.</span> <span class="nav-text">数据库索引的实现，为什么选择这个实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8CB-TREE%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E6%AF%94"><span class="nav-number">1.12.3.9.</span> <span class="nav-text">MySQL索引数据结构，B-TREE与二叉树对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">1.12.3.10.</span> <span class="nav-text">创建索引的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.12.3.11.</span> <span class="nav-text">表设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8"><span class="nav-number">1.12.3.12.</span> <span class="nav-text">联合索引什么时候使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.12.3.13.</span> <span class="nav-text">Sql语句执行关键字顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JOIN%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.3.14.</span> <span class="nav-text">JOIN的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.3.15.</span> <span class="nav-text">MySQL体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.3.16.</span> <span class="nav-text">MySQL 区间查询原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9FMyISAM%E4%B8%8EInnoDB%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.12.3.17.</span> <span class="nav-text">MySQL存储引擎？MyISAM与InnoDB区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9FMySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%9F"><span class="nav-number">1.12.3.18.</span> <span class="nav-text">你知道B树和B+树的区别吗？MySQL为什么使用B+树而不是B树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E7%94%A8%E4%B8%BB%E9%94%AEID%E6%9F%A5%E6%89%BE%E6%97%B6-B-Tree%E5%92%8CB-Tree%E5%93%AA%E4%B8%AA%E5%BF%AB"><span class="nav-number">1.12.3.19.</span> <span class="nav-text">只用主键ID查找时 B+Tree和B-Tree哪个快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%ADinnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">1.12.3.20.</span> <span class="nav-text">Mysql中innoDB中的索引有什么特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%AD%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.3.21.</span> <span class="nav-text">Mysql中聚簇索引和非聚簇索引的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BA%94%E8%AF%A5%E9%81%B5%E5%AE%88%E5%90%97%EF%BC%9F"><span class="nav-number">1.12.3.22.</span> <span class="nav-text">数据库设计三大范式？开发中应该遵守吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E8%A1%A8%E9%94%81%E3%80%81%E9%A1%B5%E9%9D%A2%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.12.3.23.</span> <span class="nav-text">MySQL表锁、页面锁、行锁的作用及优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E6%88%96%E5%AD%97%E6%AE%B5%E6%97%B6%E4%BC%9A%E9%80%A0%E6%88%90%E9%94%81%E8%A1%A8"><span class="nav-number">1.12.3.24.</span> <span class="nav-text">MySQL为什么添加索引或字段时会造成锁表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93MySQL%E4%B8%ADredo-log%E3%80%81binlog%E3%80%81undo-log-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.12.3.25.</span> <span class="nav-text">你知道MySQL中redo log、binlog、undo log 区别与作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E7%9D%80%E6%89%8B%E7%82%B9%EF%BC%9F%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="nav-number">1.12.3.26.</span> <span class="nav-text">SQL优化有哪些着手点？组合索引的最左前缀原则的含义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">1.12.3.27.</span> <span class="nav-text">索引失效场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%83%E4%B8%87%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E8%A1%A8%E6%AF%8F%E6%97%A5ETL%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.12.3.28.</span> <span class="nav-text">千万数据量的表每日ETL定时同步，如何优化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81MVCC"><span class="nav-number">1.12.3.29.</span> <span class="nav-text">说说你了解的数据库的隔离级别、MVCC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-MySQL-%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9FMySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E6%98%AF%E5%95%A5%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-MySQL-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">1.12.3.30.</span> <span class="nav-text">如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.12.3.31.</span> <span class="nav-text">为什么要设计事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#text-x2F-bold%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95"><span class="nav-number">1.12.3.32.</span> <span class="nav-text">text&#x2F;bold如何索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%95%E6%9C%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.12.3.33.</span> <span class="nav-text">数据宕机如何解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-amp-amp-%E6%8B%86%E8%A1%A8"><span class="nav-number">1.12.4.</span> <span class="nav-text">分布式 &amp;&amp; 拆表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7%E6%9C%8D%E5%8A%A1%E5%8D%95%E8%A1%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%A4%9A%E8%A1%A8%EF%BC%8C%E4%B8%94%E6%96%B0%E6%97%A7%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C"><span class="nav-number">1.12.4.1.</span> <span class="nav-text">旧服务单表，如何改造新服务多表，且新旧服务同时运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A1%A8%E5%88%86%E9%94%99%E4%BA%86%E5%90%8E%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="nav-number">1.12.4.2.</span> <span class="nav-text">分表分错了后如何排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8B%86%E8%A1%A8%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.12.4.3.</span> <span class="nav-text">如何拆表，优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%88%E4%B8%9A%E5%8A%A1%E4%BE%A7%EF%BC%89%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%88%E6%95%B0%E6%8D%AE%E4%BE%A7%EF%BC%89"><span class="nav-number">1.12.4.4.</span> <span class="nav-text">我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.12.4.5.</span> <span class="nav-text">分库分表之后，id 主键如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E6%8B%86%E5%88%86%E5%90%8E%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.12.4.6.</span> <span class="nav-text">表拆分后如何查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8D%E6%8E%A8%E8%8D%90JOIN"><span class="nav-number">1.12.4.7.</span> <span class="nav-text">为什么分布式不推荐JOIN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TiDB"><span class="nav-number">1.12.5.</span> <span class="nav-text">TiDB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch%E7%9B%B8%E5%85%B3"><span class="nav-number">1.13.</span> <span class="nav-text">ElasticSearch相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9E%AC%E9%97%B4%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2"><span class="nav-number">1.13.0.1.</span> <span class="nav-text">如何瞬间完成海量数据检索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB%E5%88%86%E8%AF%8D%E6%90%9C%E7%B4%A2%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.0.2.</span> <span class="nav-text">ES如何加快分词搜索速度，倒排索引原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98"><span class="nav-number">1.13.0.3.</span> <span class="nav-text">ES脑裂问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Click-House"><span class="nav-number">1.13.1.</span> <span class="nav-text">Click House</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network%E7%9B%B8%E5%85%B3"><span class="nav-number">1.14.</span> <span class="nav-text">Network相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.14.0.1.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="nav-number">1.14.0.2.</span> <span class="nav-text">TCP协议头多少字节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.14.0.3.</span> <span class="nav-text">TCP三次握手四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E6%8C%A5%E6%89%8B%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E8%B5%B7%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">1.14.0.4.</span> <span class="nav-text">TCP四次挥手，挥手从服务端发起会怎么样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.0.5.</span> <span class="nav-text">TCP UDP区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.14.0.6.</span> <span class="nav-text">列举几个网络通信协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.0.7.</span> <span class="nav-text">HTTP和HTTPS的主要区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B"><span class="nav-number">1.14.0.8.</span> <span class="nav-text">HTTPS交互过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTLS"><span class="nav-number">1.14.0.9.</span> <span class="nav-text">什么是TLS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%94%B6%E5%88%B0%E5%BE%88%E5%A4%9A%E7%9A%84TIME-WAIT%E7%8A%B6%E6%80%81%E5%8C%85%EF%BC%8C%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.14.0.10.</span> <span class="nav-text">网络收到很多的TIME_WAIT状态包，原因以及解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8FCLOSE-WAIT%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.14.0.11.</span> <span class="nav-text">服务端出现大量CLOSE_WAIT原因及解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-HTTP%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.14.0.12.</span> <span class="nav-text">RPC HTTP区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%98%AF%E5%90%A6%E6%98%AF%E5%BC%82%E6%AD%A5"><span class="nav-number">1.14.0.13.</span> <span class="nav-text">IO多路复用是否是异步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty"><span class="nav-number">1.14.1.</span> <span class="nav-text">Netty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hardware"><span class="nav-number">1.14.2.</span> <span class="nav-text">Hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">路由器和交换机的工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Middleware-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.15.</span> <span class="nav-text">Middleware 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx"><span class="nav-number">1.15.1.</span> <span class="nav-text">Nginx</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8C%E7%9B%B8%E5%85%B3%E5%9C%BA%E6%99%AF"><span class="nav-number">1.15.1.1.</span> <span class="nav-text">Nginx负载均衡策略，相关场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E7%A7%BB%E5%8A%A8%E7%AB%AFPC%E7%AB%AF"><span class="nav-number">1.15.1.2.</span> <span class="nav-text">Nginx如何识别移动端PC端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.15.1.3.</span> <span class="nav-text">Nginx动静分离如何实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat"><span class="nav-number">1.15.2.</span> <span class="nav-text">Tomcat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="nav-number">1.15.3.</span> <span class="nav-text">链路追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%AF%BB%E5%8F%96%E5%88%86%E5%89%B2%E8%AE%B0%E5%BD%95%E5%B9%B6%E4%BF%9D%E6%8C%81%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">大文件怎么读取分割记录并保持顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tools-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.16.</span> <span class="nav-text">Tools 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.16.0.1.</span> <span class="nav-text">分布式锁在项目上的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Theory-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.17.</span> <span class="nav-text">Theory 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAP%E5%AE%9A%E7%90%86%E5%92%8CBASE%E7%90%86%E8%AE%BA"><span class="nav-number">1.17.0.1.</span> <span class="nav-text">CAP定理和BASE理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFServerless"><span class="nav-number">1.17.0.2.</span> <span class="nav-text">什么是Serverless</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%91%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%81%E6%98%8E%E4%BD%A0%E5%81%9A%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">1.17.0.3.</span> <span class="nav-text">如何向面试官证明你做的系统是高可用的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UV-x2F-PV"><span class="nav-number">1.17.0.4.</span> <span class="nav-text">UV&#x2F;PV</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD"><span class="nav-number">1.18.</span> <span class="nav-text">DDD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Other-1"><span class="nav-number">1.19.</span> <span class="nav-text">Other</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%B0%E7%AE%97%E6%9F%90%E5%9F%8E%E5%B8%82%E7%9A%84%E4%BE%BF%E5%88%A9%E5%BA%97%E6%95%B0%E9%87%8F"><span class="nav-number">1.19.0.1.</span> <span class="nav-text">估算某城市的便利店数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E5%8D%A0%E7%94%A8%E7%AA%81%E7%84%B6%E5%8D%87%E9%AB%98%E8%AF%A5%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90"><span class="nav-number">1.19.0.2.</span> <span class="nav-text">CPU占用突然升高该怎么分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88"><span class="nav-number">1.19.0.3.</span> <span class="nav-text">常用的高可用方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9BMHA%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">1.19.0.4.</span> <span class="nav-text">有哪些MHA结构的方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E8%A1%A8%E8%BE%BE%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81"><span class="nav-number">1.19.0.5.</span> <span class="nav-text">怎样表达滑动窗口限流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3%E8%B0%83%E4%BC%98%EF%BC%8C%E4%B8%8D%E7%94%A8%E7%BC%93%E5%AD%98%E4%B8%94%E8%A6%81%E6%B1%82%E5%AE%9E%E6%97%B6%E6%80%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98"><span class="nav-number">1.19.0.6.</span> <span class="nav-text">查询接口调优，不用缓存且要求实时性，如何调优</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">193</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '713a28a3ad93f2aa2323',
      clientSecret: '39dc40bb09b422ca4c99a748b5984a4d205e91be',
      repo        : 'swzxsyh.github.io',
      owner       : 'swzxsyh',
      admin       : ['swzxsyh'],
      id          : 'a575401425808f5fa284c37e7200c0cd',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
