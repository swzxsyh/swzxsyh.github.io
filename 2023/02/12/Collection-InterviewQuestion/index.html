<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java面试题 Specification Java Spring MQ Cache Database ES Network Tools Theory">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题收集">
<meta property="og:url" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:description" content="Java面试题 Specification Java Spring MQ Cache Database ES Network Tools Theory">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png">
<meta property="article:published_time" content="2023-02-11T22:05:05.000Z">
<meta property="article:modified_time" content="2023-05-15T22:48:01.838Z">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png">

<link rel="canonical" href="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试题收集 | swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2023/02/12/Collection-InterviewQuestion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题收集
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-12 06:05:05" itemprop="dateCreated datePublished" datetime="2023-02-12T06:05:05+08:00">2023-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 06:48:01" itemprop="dateModified" datetime="2023-05-16T06:48:01+08:00">2023-05-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><ul>
<li>Specification</li>
<li>Java</li>
<li>Spring</li>
<li>MQ</li>
<li>Cache</li>
<li>Database</li>
<li>ES</li>
<li>Network</li>
<li>Tools</li>
<li>Theory</li>
</ul>
<span id="more"></span>


<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h4 id="设计模式有哪些原则"><a href="#设计模式有哪些原则" class="headerlink" title="设计模式有哪些原则"></a>设计模式有哪些原则</h4><ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转(倒置)原则</li>
<li>里氏替换原则</li>
<li>开闭原则（OCP）</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ul>
<h4 id="设计模式理解"><a href="#设计模式理解" class="headerlink" title="设计模式理解"></a>设计模式理解</h4><ul>
<li>对软件设计的解决方案</li>
<li>提高拓展性</li>
<li>通过模式名称快速沟通相关问题</li>
</ul>
<h4 id="什么是设计模式中的回调模式"><a href="#什么是设计模式中的回调模式" class="headerlink" title="什么是设计模式中的回调模式"></a>什么是设计模式中的回调模式</h4><ul>
<li>可以看作简化版的观察者模式，在方法某个阶段执行完毕时，观察者模式有多个主题和多个可调用方法，回调模式只有一个主题和一个callBack调用方法</li>
</ul>
<h4 id="饿汉式和懒汉式的区别"><a href="#饿汉式和懒汉式的区别" class="headerlink" title="饿汉式和懒汉式的区别"></a>饿汉式和懒汉式的区别</h4><ul>
<li><p>饿汉式</p>
<p>初始化时即加载，不会有线程安全问题，但会启动时就占用资源</p>
</li>
<li><p>懒汉式</p>
<p>使用时才加载，需双重锁才解决线程安全问题，节约资源</p>
</li>
<li><p>Spring框架的状态</p>
<p>Spring框架下，如果没有加@Lazy注解，又使用了@Component注解希望被Spring管理Bean，即使是双锁检查懒汉式，也其实在Spring加载时就被调用了getInstance()方法，无法实现资源懒加载。</p>
<p>同时意味着，即使使用基本懒汉单例模式，只要被Spring管理，它就是线程安全的。</p>
</li>
</ul>
<h4 id="编程规范理解"><a href="#编程规范理解" class="headerlink" title="编程规范理解"></a>编程规范理解</h4><ul>
<li>利于共同开发</li>
<li>降低Bug与维护成本</li>
<li>利于Code Review</li>
</ul>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><p><a href="https://swzxsyh.github.io/2023/03/03/LeetCode-Record/">相关内容见：LeetCode 记录</a></p>
<h4 id="大顶堆小顶堆怎么删除跟节点"><a href="#大顶堆小顶堆怎么删除跟节点" class="headerlink" title="大顶堆小顶堆怎么删除跟节点"></a>大顶堆小顶堆怎么删除跟节点</h4><p>TODO</p>
<h4 id="字典树序列化问题"><a href="#字典树序列化问题" class="headerlink" title="字典树序列化问题"></a>字典树序列化问题</h4><p>TODO</p>
<h4 id="IPv4转数字，只能用int类型"><a href="#IPv4转数字，只能用int类型" class="headerlink" title="IPv4转数字，只能用int类型"></a>IPv4转数字，只能用int类型</h4><ul>
<li><p>IPv4地址是由四个8位二进制数组成，可以将它们转换成一个32位的无符号整数来表示。IPv4地址的每个分量都可以用8位二进制数表示，这个二进制数转换为10进制整数即为IPv4地址分量的值。可以将每个分量的值左移位运算8、16、24位后相加，得到一个32位整数表示IPv4地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ipv4ToIntTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ipAddr</span> <span class="operator">=</span> <span class="string">&quot;192.168.50.236&quot;</span>;</span><br><span class="line">    String[] ip = ipAddr.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (Integer.parseInt(ip[<span class="number">0</span>]) &lt;&lt; <span class="number">24</span>) | (Integer.parseInt(ip[<span class="number">1</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">            (Integer.parseInt(ip[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) | Integer.parseInt(ip[<span class="number">3</span>]);</span><br><span class="line">    log.info(<span class="string">&quot;result: &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="如何快速判断一个数是奇数还是偶数，除开对2取余"><a href="#如何快速判断一个数是奇数还是偶数，除开对2取余" class="headerlink" title="如何快速判断一个数是奇数还是偶数，除开对2取余"></a>如何快速判断一个数是奇数还是偶数，除开对2取余</h4><ul>
<li><p>位运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//even</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//odd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="快速排序和优先级队列处理数据复杂度比较"><a href="#快速排序和优先级队列处理数据复杂度比较" class="headerlink" title="快速排序和优先级队列处理数据复杂度比较"></a>快速排序和优先级队列处理数据复杂度比较</h4><p>TODO</p>
<h4 id="多线程按顺序输出ABC若干次"><a href="#多线程按顺序输出ABC若干次" class="headerlink" title="多线程按顺序输出ABC若干次"></a>多线程按顺序输出ABC若干次</h4><p>TODO</p>
<h4 id="一亿个数中找到最大数"><a href="#一亿个数中找到最大数" class="headerlink" title="一亿个数中找到最大数"></a>一亿个数中找到最大数</h4><p>TODO</p>
<h4 id="一个数组每K个一行，存到一个二维数组中，不满补零"><a href="#一个数组每K个一行，存到一个二维数组中，不满补零" class="headerlink" title="一个数组每K个一行，存到一个二维数组中，不满补零"></a>一个数组每K个一行，存到一个二维数组中，不满补零</h4><p>TODO</p>
<h4 id="快速排序思路"><a href="#快速排序思路" class="headerlink" title="快速排序思路"></a>快速排序思路</h4><p>TODO</p>
<h4 id="一个数组，求最大和，要求组成最大和的元素不是连续的，至少间隔一个元素"><a href="#一个数组，求最大和，要求组成最大和的元素不是连续的，至少间隔一个元素" class="headerlink" title="一个数组，求最大和，要求组成最大和的元素不是连续的，至少间隔一个元素"></a>一个数组，求最大和，要求组成最大和的元素不是连续的，至少间隔一个元素</h4><p>TODO</p>
<h4 id="任意字符串去除’-‘返回字符串中’-‘的个数和去除’-‘的字符串，函数可以重载，时间复杂度为O-（n）"><a href="#任意字符串去除’-‘返回字符串中’-‘的个数和去除’-‘的字符串，函数可以重载，时间复杂度为O-（n）" class="headerlink" title="任意字符串去除’ ‘返回字符串中’ ‘的个数和去除’ ‘的字符串，函数可以重载，时间复杂度为O （n）"></a>任意字符串去除’ ‘返回字符串中’ ‘的个数和去除’ ‘的字符串，函数可以重载，时间复杂度为O （n）</h4><p>递归的方式、循环的方式实现了</p>
<p>TODO</p>
<h4 id="2D接雨水"><a href="#2D接雨水" class="headerlink" title="2D接雨水"></a>2D接雨水</h4><p>TODO</p>
<h4 id="合并多个有序数组"><a href="#合并多个有序数组" class="headerlink" title="合并多个有序数组"></a>合并多个有序数组</h4><p>TODO</p>
<h4 id="深度为5的满二叉树中叶子结点的个数"><a href="#深度为5的满二叉树中叶子结点的个数" class="headerlink" title="深度为5的满二叉树中叶子结点的个数"></a>深度为5的满二叉树中叶子结点的个数</h4><p>TODO</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://swzxsyh.github.io/2022/08/04/Data-Structure/">部分内容见：数据结构 Data Structure</a></p>
<h4 id="什么是红黑树？和其他树有什么区别？"><a href="#什么是红黑树？和其他树有什么区别？" class="headerlink" title="什么是红黑树？和其他树有什么区别？"></a>什么是红黑树？和其他树有什么区别？</h4><ul>
<li><p>什么是红黑树</p>
<p>自平衡二叉查找说，在插入或删除时自动调整树结构，保持树的平衡状态，从而保证树的高度较低，提高查找、插入和删除的效率</p>
</li>
<li><p>和其他树有什么区别</p>
<ul>
<li><p>主要是其自平衡特性</p>
</li>
<li><p>BST</p>
<p>红黑树属于它，但它不一定是红黑树，它不能自平衡，因此可能高度O(n),时间复杂度也是O(n)</p>
</li>
<li><p>AVL</p>
<p>也是一种自平衡树，但AVL要求左右子树高度差不能超过1，因此插入和删除时需要更多旋转操作，实现更复杂，查找效率更高，但插入&#x2F;删除效率更低。</p>
</li>
<li><p>B-Tree&#x2F;B+Tree</p>
<p>多路查找树，查询效率更高，但实现更复杂</p>
</li>
</ul>
</li>
</ul>
<h4 id="堆结构与树结构的区别"><a href="#堆结构与树结构的区别" class="headerlink" title="堆结构与树结构的区别"></a>堆结构与树结构的区别</h4><p>TODO</p>
<h4 id="搜索二叉树怎么遍历"><a href="#搜索二叉树怎么遍历" class="headerlink" title="搜索二叉树怎么遍历"></a>搜索二叉树怎么遍历</h4><p>TODO</p>
<p>左小右大</p>
<h4 id="CPU-L1-L2-L3哪些共享"><a href="#CPU-L1-L2-L3哪些共享" class="headerlink" title="CPU L1 L2 L3哪些共享"></a>CPU L1 L2 L3哪些共享</h4><p>TODO</p>
<h4 id="HashMap-的红黑树、红黑树上的红节点主要是干什么的"><a href="#HashMap-的红黑树、红黑树上的红节点主要是干什么的" class="headerlink" title="HashMap 的红黑树、红黑树上的红节点主要是干什么的"></a>HashMap 的红黑树、红黑树上的红节点主要是干什么的</h4><ul>
<li><p>红黑树中的红色节点用作平衡机制以确保树保持平衡。红黑树是一种自平衡二叉搜索树，这意味着它们会自动调整其结构以保持对数高度和高效的搜索和插入操作。</p>
<p>在红黑树中，每个节点要么是红色的，要么是黑色的。根节点和所有叶节点（即树底部的空节点）始终为黑色。红色节点可以有黑色或红色孩子，但黑色节点只能有黑色孩子。这种安排确保从根节点到任何叶节点的最长路径不超过最短路径的两倍。</p>
<p>当一个节点被插入到红黑树中时，它最初是红色的。然后调整树以保持红黑属性，其中包括：</p>
<ol>
<li>每个节点要么是红色要么是黑色。</li>
<li>根节点始终为黑色。</li>
<li>如果一个节点是红色的，那么它的两个孩子都必须是黑色的。</li>
<li>从节点到其后代空节点的每条路径都包含相同数量的黑色节点。</li>
</ol>
<p>为了保持这些属性，树可能需要执行节点的旋转和重新着色。红色节点在此过程中起着至关重要的作用，因为它们允许树执行旋转以保持树的平衡，同时避免过高。</p>
<p>总之，红黑树中的红色节点充当平衡机制，以确保树保持平衡并保持其高效的搜索和插入操作。</p>
</li>
</ul>
<h4 id="十几亿个数据，实现黑白名单，标出黑名单的几个人"><a href="#十几亿个数据，实现黑白名单，标出黑名单的几个人" class="headerlink" title="十几亿个数据，实现黑白名单，标出黑名单的几个人"></a>十几亿个数据，实现黑白名单，标出黑名单的几个人</h4><ul>
<li><p>Bloom过滤器</p>
<ul>
<li><p>优势</p>
<p>空间效率：布隆过滤器使用紧凑的位数组来表示集合，这意味着它们比散列表等传统数据结构需要更少的内存。<br>快速成员资格测试：布隆过滤器可以通过执行一些简单的按位运算快速检查元素是否是集合的成员。<br>可扩展性：布隆过滤器可以扩展到非常大的数据集，使其适用于拥有超过 10 亿数据的用例。<br>低漏报率：Bloom 过滤器返回漏报率的可能性很低（即表明某个元素实际上不在集合中）。</p>
</li>
<li><p>缺陷</p>
<p>误报：Bloom 过滤器可以返回误报（即，表明一个元素在集合中，而实际上它不在集合中），尽管这种情况发生的概率可以通过调整过滤器的参数来控制。<br>单向：布隆过滤器是一种单向数据结构，这意味着一旦添加了元素，您就无法从过滤器中检索原始元素。<br>有限的功能：布隆过滤器只能测试成员资格，不能执行删除或交集等操作。<br>总而言之，如果您需要一种节省空间、可扩展且快速的方式来实现包含超过 10 亿条数据的黑白名单并在黑名单中标记少数人，布隆过滤器可能是一个不错的选择。但是，您还应该考虑在特定用例中使用布隆过滤器的限制和权衡。</p>
</li>
</ul>
</li>
</ul>
<h4 id="计算机内存管理"><a href="#计算机内存管理" class="headerlink" title="计算机内存管理"></a>计算机内存管理</h4><ul>
<li><p>内存的物理结构</p>
<p>内存由许多个存储单元组成，每个存储单元都有一个唯一的地址，通过地址来访问内存中的数据。</p>
</li>
<li><p>内存的逻辑结构</p>
<p>内存被操作系统分成多个逻辑块，如页、段或区域等，操作系统可以对这些逻辑块进行分配、回收和管理。</p>
</li>
<li><p>内存的分配</p>
<p>在运行程序时，操作系统需要为程序分配内存空间，内存分配可以采用静态分配或动态分配。静态分配指在程序编译时就已经确定了程序需要的内存空间大小，动态分配则是在程序运行时根据实际需要来动态地分配内存空间。</p>
</li>
<li><p>内存的回收</p>
<p>在程序运行结束后，操作系统需要回收程序使用的内存空间，以便让其他程序可以使用这些内存空间。</p>
</li>
<li><p>内存的保护</p>
<p>为了保护操作系统和其他程序的正常运行，操作系统需要对内存进行保护，以防止程序越界访问、恶意代码修改内存等安全问题。</p>
</li>
<li><p>内存的共享</p>
<p>在多个进程间共享内存可以提高系统的性能和效率，但同时也带来了一些安全和同步问题，操作系统需要对内存共享进行管理和控制。</p>
</li>
</ul>
<h4 id="上下文无关文法和正则文法的区别"><a href="#上下文无关文法和正则文法的区别" class="headerlink" title="上下文无关文法和正则文法的区别"></a>上下文无关文法和正则文法的区别</h4><ul>
<li><p>正则定义与上下文无关文法的重要区别在于，在正则定义中是不允许递归定义的，例如A → aA|b不是一个正则定义，为其左边的A必须是一个新的符号，也就是说不能在其他地方定义过，但是其右边要求每一个符号都是定义过的，因此这个定义无法满足。而上下文无关文法则没有这个约束，因此A → aA|b是一个上下文无关文法的产生式，但不是正则定义的定义式。</p>
<p>正则表达式在编译器构建中一般用来进行词法分析，通过NFA、DFA就可以识别，而更复杂的文法就需要以来其他算法了。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/575add9b80c3">https://www.jianshu.com/p/575add9b80c3</a></p>
</li>
</ul>
<h4 id="定义一个数据结构，包含insert和queryMedium两个方法，查询高频操作，插入低频操作，要求查询效率最优"><a href="#定义一个数据结构，包含insert和queryMedium两个方法，查询高频操作，插入低频操作，要求查询效率最优" class="headerlink" title="定义一个数据结构，包含insert和queryMedium两个方法，查询高频操作，插入低频操作，要求查询效率最优"></a>定义一个数据结构，包含insert和queryMedium两个方法，查询高频操作，插入低频操作，要求查询效率最优</h4><p>TODO</p>
<h2 id="Java-相关"><a href="#Java-相关" class="headerlink" title="Java 相关"></a>Java 相关</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h4><ul>
<li>long short int double float char byte boolean</li>
</ul>
<h4 id="float如何判断是否为0"><a href="#float如何判断是否为0" class="headerlink" title="float如何判断是否为0"></a>float如何判断是否为0</h4><ul>
<li>IEEE754 ，0.00000f&lt;1e-6</li>
</ul>
<h4 id="对象创建到销毁的流程"><a href="#对象创建到销毁的流程" class="headerlink" title="对象创建到销毁的流程"></a>对象创建到销毁的流程</h4><p>TODO</p>
<h4 id="abstract应用范围"><a href="#abstract应用范围" class="headerlink" title="abstract应用范围"></a>abstract应用范围</h4><p>TODO</p>
<h4 id="interface默认修饰符"><a href="#interface默认修饰符" class="headerlink" title="interface默认修饰符"></a>interface默认修饰符</h4><ul>
<li>public abstract</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>TODO</p>
<h4 id="super-this怎么用"><a href="#super-this怎么用" class="headerlink" title="super this怎么用"></a>super this怎么用</h4><p>TODO</p>
<h4 id="switch如何实现"><a href="#switch如何实现" class="headerlink" title="switch如何实现"></a>switch如何实现</h4><ul>
<li><p>比较</p>
<ul>
<li>字符串使用hash &amp;&amp; equals 比较</li>
<li>枚举类使用ordinal方法转int比较</li>
</ul>
</li>
<li><p>字节码产生一条goto语句</p>
</li>
<li><p>注意，Java虚拟机特性使switch不支持long类型</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904118134259725">https://juejin.cn/post/6844904118134259725</a></p>
</li>
</ul>
<h4 id="Java包装类型理解"><a href="#Java包装类型理解" class="headerlink" title="Java包装类型理解"></a>Java包装类型理解</h4><ul>
<li>对于基本类型的包装</li>
<li>存储位置不同<ul>
<li>包装类型存储于堆，通过地址引用</li>
<li>基本类型根据不同方法存放不同位置<ul>
<li>方法-栈帧局部变量表</li>
<li>类成员变量-栈</li>
<li>静态变量&#x2F;常量-方法区</li>
</ul>
</li>
</ul>
</li>
<li>包装类默认值为Null值，基本类型不能为null</li>
<li>OOP思想</li>
</ul>
<h4 id="Java面向对象特征"><a href="#Java面向对象特征" class="headerlink" title="Java面向对象特征"></a>Java面向对象特征</h4><ul>
<li>封装，继承，多态</li>
</ul>
<h4 id="值类型和引用类型分别在JVM哪个区域"><a href="#值类型和引用类型分别在JVM哪个区域" class="headerlink" title="值类型和引用类型分别在JVM哪个区域"></a>值类型和引用类型分别在JVM哪个区域</h4><ul>
<li><p>值类型</p>
<p>栈</p>
</li>
<li><p>引用类型</p>
<p>堆</p>
</li>
</ul>
<h4 id="String是值类型吗"><a href="#String是值类型吗" class="headerlink" title="String是值类型吗"></a>String是值类型吗</h4><ul>
<li><p>否，引用类型</p>
<p>每当创建一个字符串时，如果该字符串的值已经存在于字符串常量池中，那么将返回常量池中的这个字符串对象的引用，否则将会在常量池中新建一个字符串并返回这个字符串对象的引用</p>
</li>
</ul>
<h4 id="接口能不能实现接口"><a href="#接口能不能实现接口" class="headerlink" title="接口能不能实现接口"></a>接口能不能实现接口</h4><ul>
<li>不能，只能继承</li>
</ul>
<h4 id="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么？"><a href="#抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么？" class="headerlink" title="抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？"></a>抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？</h4><ul>
<li><p>抽象类和接口的区别</p>
<ul>
<li>一个类只能继承一个抽象类（单继承），却能实现多接口（多实现）</li>
<li>抽象类可以有定义和实现，接口原本只有定义，JDK1.8后可以default实现</li>
<li>接口强调特定功能实现，抽象类强调所属关系</li>
<li>接口成员变量默认public static final，必须赋值且不能修改，所有成员方法都是public、abstract的。抽象类变量默认default，可在自类被重新定义，也可以被重新赋值。</li>
</ul>
</li>
<li><p>类可以继承多个类么</p>
<p>不可以</p>
</li>
<li><p>接口可以继承多个接口么</p>
<p>可以</p>
</li>
<li><p>类可以实现多个接口么</p>
<p>可以</p>
</li>
</ul>
<h4 id="父类静态方法能否被子类重写"><a href="#父类静态方法能否被子类重写" class="headerlink" title="父类静态方法能否被子类重写"></a>父类静态方法能否被子类重写</h4><ul>
<li>不能，只能继承，不能重写</li>
</ul>
<h4 id="静态属性和静态方法是否可以被继承"><a href="#静态属性和静态方法是否可以被继承" class="headerlink" title="静态属性和静态方法是否可以被继承"></a>静态属性和静态方法是否可以被继承</h4><ul>
<li>可以，且可以覆盖，如果想用父类的属性和变量，则需使用父类</li>
</ul>
<h4 id="为什么重写Equals一定也要重写HashCode"><a href="#为什么重写Equals一定也要重写HashCode" class="headerlink" title="为什么重写Equals一定也要重写HashCode"></a>为什么重写Equals一定也要重写HashCode</h4><ul>
<li>自定义对象要比较时，先比较hashCode再比较equals，hashCode保证性能，equals保证可靠性</li>
<li>从Object继承的这两个方法都是<code>比较内存地址</code>，如果不重写HashCode，自定义的两个对象内存地址肯定不一样导致比较失效，Equals比较同理，Object比较也是<code>内存地址</code>，也会导致比较失效。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61307537">https://zhuanlan.zhihu.com/p/61307537</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024478811">https://segmentfault.com/a/1190000024478811</a></li>
</ul>
<h4 id="HashCode相同，是否Equals，反之是否相同"><a href="#HashCode相同，是否Equals，反之是否相同" class="headerlink" title="HashCode相同，是否Equals，反之是否相同"></a>HashCode相同，是否Equals，反之是否相同</h4><ul>
<li><p>否</p>
<p>两个对象equals，hashcode一定相同，因此比较时会先比较hashCode，如果不同则直接返回false</p>
<p>hashcode相同，不一定equles</p>
</li>
</ul>
<h4 id="对一个数异或两次等于没有异或"><a href="#对一个数异或两次等于没有异或" class="headerlink" title="对一个数异或两次等于没有异或"></a>对一个数异或两次等于没有异或</h4><ul>
<li><p>异或是一种按位逻辑韵味，规则为：两个二进制位相同则结果为0，不同则为1</p>
</li>
<li><p>异或满足交换律和结合律，因此对一个数异或异或两次没有异或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = x ^ y <span class="comment">// (a ^ b, b)</span></span><br><span class="line">y = x ^ y <span class="comment">// (a ^ b, a ^ b ^ b) =&gt; (a ^ b, a)</span></span><br><span class="line">x = x ^ y <span class="comment">// (a ^ b ^ a, a) =&gt; (b, a)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="float在内存中怎么表示"><a href="#float在内存中怎么表示" class="headerlink" title="float在内存中怎么表示"></a>float在内存中怎么表示</h4><ul>
<li>s | eeeeeeee | mmm mmmm mmmm mmmm mmmm mmmm</li>
<li>符号位：31位，符号0为负，1为正</li>
<li>指数位：23-30位，用8位存储指数部分</li>
<li>尾数位：0-22位，存储小数部分</li>
</ul>
<h4 id="数组动态分配内存如何实现"><a href="#数组动态分配内存如何实现" class="headerlink" title="数组动态分配内存如何实现"></a>数组动态分配内存如何实现</h4><ul>
<li>Java中动态数组分配内存是通过JVM中的Heap实现的。</li>
<li>Java数组是一种固定长度的数据结构，因此分配动态数组的实现方式是创建一个新的更大的数组，将原数组数据复制System.arraycopy()，并释放原数组空间。</li>
<li>频繁操作会导致性能问题，应尽量避免数组扩容</li>
</ul>
<h4 id="如何防止非原子操作的冲突问题"><a href="#如何防止非原子操作的冲突问题" class="headerlink" title="如何防止非原子操作的冲突问题"></a>如何防止非原子操作的冲突问题</h4><ul>
<li>使用synchronized关键字，避免并发到这数据冲突</li>
<li>使用ReentrantLock</li>
<li>使用Atomic包</li>
<li>使用ThreadLocal</li>
<li>使用JUC并发容器</li>
</ul>
<h4 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h4><ul>
<li>最优二叉树，是一种带权路径长度最短的树，常用于数据压缩中的编码和解码</li>
<li>每个叶子节点对应着一个权值，而每个非叶子节点对应着一个权值之和。哈夫曼编码则是将字符映射为哈夫曼树中对应的叶子节点的路径，路径的方向为从根节点到叶子节点的方向。由于哈夫曼树的带权路径长度最短，所以哈夫曼编码也是一种最优编码方式，能够实现高效的数据压缩。</li>
</ul>
<h4 id="Object-常用方法及每个方法的大致含义"><a href="#Object-常用方法及每个方法的大致含义" class="headerlink" title="Object 常用方法及每个方法的大致含义"></a>Object 常用方法及每个方法的大致含义</h4><ul>
<li><p>Object.equals()</p>
<p>判断对象hashCode是否相同</p>
</li>
<li><p>Object.wait()</p>
<p>线程停止</p>
</li>
<li><p>Object.toString()</p>
<p>将对象转换为字符串</p>
</li>
</ul>
<h4 id="在JDK1-5中引入了泛型，泛型的存在是用来解决什么问题"><a href="#在JDK1-5中引入了泛型，泛型的存在是用来解决什么问题" class="headerlink" title="在JDK1.5中引入了泛型，泛型的存在是用来解决什么问题"></a>在JDK1.5中引入了泛型，泛型的存在是用来解决什么问题</h4><ul>
<li><strong>泛型主要针对向下转型时所带来的安全隐患，其核心组成是在声明类或接口时，不设置参数或属性的类型</strong></li>
<li><strong>第一是泛化。</strong>可以用T代表任意类型Java语言中引入泛型是一个较大的功能增强不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了，这带来了很多好处。</li>
<li><strong>第二是类型安全。</strong>泛型的一个主要目标就是提高ava程序的类型安全，使用泛型可以使编译器知道变量的类型限制，进而可以在更高程度上验证类型假设。如果不用泛型，则必须使用强制类型转换，而强制类型转换不安全，在运行期可能发生ClassCast Exception异常，如果使用泛型，则会在编译期就能发现该错误。<strong>第三是消除强制类型转换。</strong>泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错</li>
<li>的机会。</li>
<li><strong>第四是向后兼容。</strong>支持泛型的Java编译器（例如JDK1.5中的Javac）可以用来编译经过泛型扩充的Java程序（Generics Java程序），但是现有的没有使用泛型扩充的Java程序仍然可以用这些编译器来编译。</li>
<li>JAVA 泛型只存在于编译时期，在运行时期会被擦除</li>
</ul>
<h4 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h4><ul>
<li>extends 表示包括T在内的任何T的子类</li>
<li>super 表示包括T在哪的任何T的父类</li>
</ul>
<h4 id="有没有可能2个不相等的对象有相同的hashcode"><a href="#有没有可能2个不相等的对象有相同的hashcode" class="headerlink" title="有没有可能2个不相等的对象有相同的hashcode"></a>有没有可能2个不相等的对象有相同的hashcode</h4><ul>
<li><p>有，Hash冲突</p>
</li>
<li><p>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入</p>
</li>
<li><p>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突.</p>
</li>
</ul>
<h4 id="举例几个树形结构"><a href="#举例几个树形结构" class="headerlink" title="举例几个树形结构"></a>举例几个树形结构</h4><ul>
<li>B+Tree，MySQL</li>
<li>红黑树，HashMap</li>
</ul>
<h4 id="Java异常类体系共同祖先"><a href="#Java异常类体系共同祖先" class="headerlink" title="Java异常类体系共同祖先"></a>Java异常类体系共同祖先</h4><ul>
<li><p>Throwable</p>
<p>内部包含Error和Exception</p>
</li>
</ul>
<h4 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h4><ul>
<li>Error 一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。仅靠程序本身无法恢复</li>
<li>Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</li>
</ul>
<h4 id="Java异常框架有哪些"><a href="#Java异常框架有哪些" class="headerlink" title="Java异常框架有哪些"></a>Java异常框架有哪些</h4><ul>
<li><p>原生</p>
<p><code>Exception</code>、<code>RuntimeException</code>、<code>NullPointerException</code>、<code>IOException</code>等</p>
</li>
<li><p>Spring框架</p>
<p>Spring自定义的异常类、Spring AOP中的异常处理、Spring MVC中的异常处理等。</p>
</li>
<li><p>Log4j2</p>
<p>提供了<code>ThrowableProxy</code>用于封装异常信息，包括堆栈跟踪、异常类型、异常信息等</p>
</li>
</ul>
<h4 id="你知道什么是指令重排序？为什么要重排序？"><a href="#你知道什么是指令重排序？为什么要重排序？" class="headerlink" title="你知道什么是指令重排序？为什么要重排序？"></a>你知道什么是指令重排序？为什么要重排序？</h4><ul>
<li>指令重排序是指源码顺序和程序顺序不一样，或者说程序顺序和执行的顺序不一致，重排序的对象是指令。 指令重排序是编译器处于性能考虑，在不影响程序（单线程程序） 指令重排序不是必然发生的，指令重排序会导致线程安全问题。</li>
<li>volatile（引申Singleton Pattern为什么使用）</li>
</ul>
<h4 id="Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同"><a href="#Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同" class="headerlink" title="Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同"></a>Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同</h4><ul>
<li><p>Java中的volatile关键是什么作用</p>
<p>多线程环境下，保证共享变量的可见性，当一个线程修改共享变量的值，其他线程可以立即看到，其他线程回去主内存重新读取该变量的值，避免数据不一致问题。</p>
<p>禁止指令重排序，保证多线程环境下，共享变量的读写是有序的</p>
</li>
<li><p>在Java中它跟synchronized方法有什么不同</p>
<p>volatile可以保证可见性和有序性，不能保证原子性。</p>
<p>synchronized可以保证可见效，有序性和原子性</p>
</li>
</ul>
<h4 id="Overload、Override、Overwrite的区别"><a href="#Overload、Override、Overwrite的区别" class="headerlink" title="Overload、Override、Overwrite的区别"></a>Overload、Override、Overwrite的区别</h4><ul>
<li>overload意为重载，同一个类中，存在多个方法名相同的函数，但是他们拥有不同的参数</li>
<li>override意为覆盖，针对父类，实现类而言，参数名称相同，方法不同</li>
<li>overwrite意为重写，Java没有</li>
</ul>
<h4 id="什么是浅拷贝和深拷贝"><a href="#什么是浅拷贝和深拷贝" class="headerlink" title="什么是浅拷贝和深拷贝"></a>什么是浅拷贝和深拷贝</h4><ul>
<li>浅拷贝只是增加了一个指针指向已经存在的内存</li>
<li>深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。</li>
<li>浅拷贝更改数据会变更原数据</li>
</ul>
<h4 id="什么是不可变对象，它对写并发应用有什么帮助"><a href="#什么是不可变对象，它对写并发应用有什么帮助" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助"></a>什么是不可变对象，它对写并发应用有什么帮助</h4><ul>
<li>一旦创建及无法被修改的对象称为不可变对象。</li>
<li>并发应用的帮助<ul>
<li>多线程下不会出现线程同步问题，不需要担心数据被其他线程修改</li>
<li>可以作为Map的Key 和Set元素</li>
<li>但由于不可变，因此每次创建一个不同的对象都会产生一个新对象</li>
</ul>
</li>
</ul>
<h4 id="如何创建不可变的类？"><a href="#如何创建不可变的类？" class="headerlink" title="如何创建不可变的类？"></a>如何创建不可变的类？</h4><ul>
<li>private + final修饰</li>
<li>不暴露改变成员变量的方法，如setter</li>
<li>通过构造器初始化所有成员，进行深拷贝(this.myArray &#x3D; array.clone())</li>
<li>getter方法中，不要返回对象本身，而是返回clone对象</li>
</ul>
<h4 id="String能不能有子类，为什么-String-被设计为是不可变的？"><a href="#String能不能有子类，为什么-String-被设计为是不可变的？" class="headerlink" title="String能不能有子类，为什么 String 被设计为是不可变的？"></a>String能不能有子类，为什么 String 被设计为是不可变的？</h4><ul>
<li><p>String能不能有子类</p>
<p>不能，public final class String</p>
<p>JDK 1.8 本质是final char value[]，JDK 1.9 本质是 final byte[] value;</p>
<p>实际可以通过反射变更array</p>
</li>
<li><p>为什么 String 被设计为是不可变的</p>
<p>线程安全，不可变对象一定是线程安全的</p>
<p>字符串常量池，节约空间</p>
<p>Hash Code 唯一性，JVM直接缓存HashCode，对于HashMap类引用查找速度快</p>
</li>
</ul>
<h4 id="String转Integer的方式和原理"><a href="#String转Integer的方式和原理" class="headerlink" title="String转Integer的方式和原理"></a>String转Integer的方式和原理</h4><ul>
<li><p>方式</p>
<p>Integer.parseInt();</p>
<p>Integer.valueOf();</p>
</li>
<li><p>原理</p>
<p>先判断是否有符号，再循环字符，Character.digit(char ch, int radix)转换</p>
</li>
</ul>
<h4 id="描述动态代理的几种实现方式，分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式，分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式，分别说出相应的优缺点"></a>描述动态代理的几种实现方式，分别说出相应的优缺点</h4><ul>
<li>JDKProxy<ul>
<li>JDK自带</li>
<li>只能代理接口</li>
<li>保持原类存在下，生成一个继承Proxy.class的新类</li>
</ul>
</li>
<li>CGLibProxy<ul>
<li>第三方类，通过继承的方法进行代理</li>
<li>可以代理类和方法，不能代理final类和final方法</li>
<li>直接生成Proxy代理类，字节码方式替换原始类</li>
</ul>
</li>
<li><a href="https://swzxsyh.github.io/2022/07/05/Spring-AOP/">Spring-AOP | swzxsyh</a></li>
</ul>
<h4 id="JAVA实现反射的两种方式？为什么要这样设计？"><a href="#JAVA实现反射的两种方式？为什么要这样设计？" class="headerlink" title="JAVA实现反射的两种方式？为什么要这样设计？"></a>JAVA实现反射的两种方式？为什么要这样设计？</h4><ul>
<li><pre><code class="java">Class.forName();
Object.getClass();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 增强程序的灵活性和可扩展性。</span><br><span class="line"></span><br><span class="line">#### JAVA的反射机制</span><br><span class="line"></span><br><span class="line">- 反射机制</span><br><span class="line"></span><br><span class="line">  - 在运行时动态获取类的信息，以及动态创建对象、调用方法、访问熟悉。</span><br><span class="line"></span><br><span class="line">    反射机制允许运行时获取类的方法、字段、注解等信息，并可以动态操作类的实例，为程序提供灵活性。</span><br><span class="line"></span><br><span class="line">- 主要接口</span><br><span class="line"></span><br><span class="line">  - Class 类：代表一个类的字节码对象，可以获取类的名称、修饰符、构造方法、方法、字段、注解等信息。</span><br><span class="line">  - Constructor 类：代表一个类的构造方法，可以通过 Constructor 类动态地创建类的实例。</span><br><span class="line">  - Method 类：代表一个类的方法，可以通过 Method 类动态地调用类的方法。</span><br><span class="line">  - Field 类：代表一个类的字段，可以通过 Field 类动态地访问和修改类的字段值。</span><br><span class="line">  - Annotation 接口：代表一个类或方法的注解，可以通过 Annotation 接口获取类或方法的注解信息。</span><br><span class="line"></span><br><span class="line">- 应用场景</span><br><span class="line"></span><br><span class="line">  - 动态代理、框架开发、对象序列化、注解处理、模块化编程等。但是由于反射机制在运行时动态地创建对象和调用方法，因此可能会影响程序的性能，需要在使用时慎重考虑。</span><br><span class="line"></span><br><span class="line">#### Java 静态代理和动态代理区别</span><br><span class="line"></span><br><span class="line">- Static Proxy 中，代理类是在编译时创建的，并指定了一组固定的接口</span><br><span class="line"></span><br><span class="line">  Java Static Proxy 涉及创建一个实现与原始对象相同接口的代理类，并且对原始对象的所有方法调用都被转发到代理对象。然后，代理对象可以在调用原始对象的方法之前或之后执行其他操作。静态代理在目标对象是固定的并且在编译时已知的场景中很有用。</span><br><span class="line"></span><br><span class="line">- Dynamic Proxy 中，代理类是在运行时创建的，可以添加接口动态地。</span><br><span class="line"></span><br><span class="line">  Java 动态代理使用内置的 java.lang.reflect.Proxy 类在运行时创建代理实例。动态代理允许更大的灵活性，因为代理实现的接口可以在运行时动态确定。当编译时不知道目标对象或需要代理大量对象时，动态代理很有用。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  Static Proxy 和 Dynamic Proxy 的另一个区别是 Static Proxy 可以为接口和具体类创建，而 Dynamic Proxy 只能为接口创建。</span><br><span class="line"></span><br><span class="line">  总体而言，静态代理和动态代理都用于在不更改对象代码的情况下向对象添加附加功能，两者之间的选择取决于用例的具体要求。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### CAS原理</span><br><span class="line"></span><br><span class="line">- CAS存在3个参数</span><br><span class="line"></span><br><span class="line">  内存地址V，期望值A，新值B。</span><br><span class="line"></span><br><span class="line">- 当多个线程试图修改同一个变量时，只有一个线程能够成功修改，其他线程失败。如果内存地址V的值与期望值A相等，则判断没修改过，替换为B则成功，否则失败。</span><br><span class="line"></span><br><span class="line">- CAS算法的实现通常依赖于CPU的底层指令，比如x86架构中的CMPXCHG指令</span><br><span class="line"></span><br><span class="line">#### 怎么保证幂等</span><br><span class="line"></span><br><span class="line">- 幂等性是指同一个操作无论请求多少次，其结果都相同</span><br><span class="line">- 保证方式</span><br><span class="line">  - 唯一性约束：数据库使用唯一性约束保证数据唯一性</span><br><span class="line">  - 乐观锁机制： 使用版本号标记，如果版本号错误，则失败</span><br><span class="line">  - 请求去重：在前端生成一个唯一key，后端检查是否已接受过该请求</span><br><span class="line">  - 幂等性接口设计：如在更新数据时，只更新发生变化的字段</span><br><span class="line"></span><br><span class="line">#### 什么是原子操作，Java中的原子操作是什么</span><br><span class="line"></span><br><span class="line">- 原子操作</span><br><span class="line">  - 不可被中断的一个或一系列操作，要么全部完成，要么全部不完成</span><br><span class="line">- Java原子操作</span><br><span class="line">  - Atomic类提供原子方法，保证原子性</span><br><span class="line"></span><br><span class="line">#### AtomicInteger set方法是线程安全的吗</span><br><span class="line"></span><br><span class="line">- 是线程安全的。Java赋值是原子操作，且同时读写才关注原子性，只写入是原子的</span><br><span class="line"></span><br><span class="line">#### 如何同步一个原子操作</span><br><span class="line"></span><br><span class="line">- 使用Atomic原子类中的方法</span><br><span class="line"></span><br><span class="line">  - get(): 获取当前值</span><br><span class="line">  - set(value): 设置当前值</span><br><span class="line">  - getAndSet(value):获取当前并设置为指定值</span><br><span class="line">  - compareAndSet(expect,update): 比较当前值如果是expect则设定为update</span><br><span class="line"></span><br><span class="line">- 使用`compareAndSet()`方法可以实现同步一个原子操作的效果</span><br><span class="line"></span><br><span class="line">  - 将需要同步的原子操作放入一个循环，每次循环尝试使用compareAndSet()方法更新原子变量的值</span><br><span class="line"></span><br><span class="line">  - compareAndSet() 返回true表示成功，跳出循环</span><br><span class="line"></span><br><span class="line">  - compareAndSet() 返回false表示失败，当前值已被修改，需重新获取原子变量的最新值再进行操作，进入下一次循环</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">      /**</span><br><span class="line">       * CompareAndSet() Test</span><br><span class="line">       */</span><br><span class="line">      @Test</span><br><span class="line">      public void compareAndSetTest() &#123;</span><br><span class="line">          AtomicInteger counter = new AtomicInteger(0);</span><br><span class="line">          int i = 0;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              int oldValue = counter.get();</span><br><span class="line">              int newValue = oldValue++;</span><br><span class="line">              if (counter.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              i++;</span><br><span class="line">              System.out.println(&quot;current i:&quot; + i);</span><br><span class="line">              if (i == 15) &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h4><ul>
<li><p>初始化阶段</p>
<p>当Servlet容器接收到一个Servlet的请求时，它首先会检查是否已经加载了该Servlet的实例。如果没有，则会根据web.xml配置文件中的&lt;servlet&gt;和&lt;servlet-mapping&gt;元素来创建和初始化一个新的Servlet实例。在初始化过程中，容器会调用Servlet的init()方法来初始化Servlet实例，并传递一个ServletConfig对象，该对象包含了Servlet的初始化参数</p>
</li>
<li><p>服务阶段</p>
<p>在Servlet实例初始化完成后，容器会将客户端的请求分派给对应的Servlet实例，并调用该实例的<code>service()</code>方法来<strong>处理请求</strong>。在<code>service()</code>方法中，Servlet可以使用一些内置的对象，如ServletRequest和ServletResponse来访问请求和响应的信息，并通过这些对象与客户端进行交互</p>
</li>
<li><p>销毁阶段</p>
<p>清理一些资源，如关闭数据库连接、释放文件句柄等等</p>
</li>
</ul>
<h4 id="SimpleWebServer支持HTTPS吗"><a href="#SimpleWebServer支持HTTPS吗" class="headerlink" title="SimpleWebServer支持HTTPS吗"></a>SimpleWebServer支持HTTPS吗</h4><ul>
<li>不支持。如果不能替换为Tomcat等Web服务器，可以使用Nginx反向代理</li>
</ul>
<h4 id="static-和final-static的区别"><a href="#static-和final-static的区别" class="headerlink" title="static 和final static的区别"></a>static 和final static的区别</h4><ul>
<li>final static变量不可改，且必须在声明时初始化</li>
<li>普通static可以变更，在任何时候初始化</li>
</ul>
<h4 id="Java内存池提供的接口，实现方式"><a href="#Java内存池提供的接口，实现方式" class="headerlink" title="Java内存池提供的接口，实现方式"></a>Java内存池提供的接口，实现方式</h4><ul>
<li><p>内存池提供的接口</p>
<p><code>ByteBuffer allocate(int capacity)</code>: 分配一个具有指定容量的新的<code>ByteBuffer</code>实例。</p>
<p><code>ByteBuffer allocateDirect(int capacity)</code>: 分配一个具有指定容量的新的直接<code>ByteBuffer</code>实例。</p>
<p><code>ByteBuffer wrap(byte[] array)</code>: 包装一个字节数组为<code>ByteBuffer</code>实例。</p>
<p><code>ByteBuffer wrap(byte[] array, int offset, int length)</code>: 从指定的偏移量开始，使用指定长度包装一个字节数组为<code>ByteBuffer</code>实例。</p>
</li>
<li><p>实现方式</p>
<p>Java内存池的实现方式通常是基于对象池的方式，对象池是一种可以重用已经创建的对象的模式。在Java中，内存池就是一种对象池，它维护了一个对象列表，可以在需要时为请求对象的线程提供对象，并将使用后的对象返回给池。</p>
</li>
</ul>
<h4 id="空闲链表法中每个节点管理的内存大小"><a href="#空闲链表法中每个节点管理的内存大小" class="headerlink" title="空闲链表法中每个节点管理的内存大小"></a>空闲链表法中每个节点管理的内存大小</h4><ul>
<li>常用的空闲链表法中，每个节点管理的内存大小可以是一个定值，例如64字节、128字节等等，也可以是一个区间，例如64-128字节、128-256字节等等，具体大小根据不同的应用场景而定。</li>
<li>当需要申请内存时，可以根据内存大小在对应的节点上进行申请。在释放内存时，可以将内存块重新加入到对应的节点中，以便后续可以被重复利用</li>
</ul>
<h4 id="EJB是什么"><a href="#EJB是什么" class="headerlink" title="EJB是什么"></a>EJB是什么</h4><p>TODO</p>
<h4 id="Java读取配置文件方法-xml或properties"><a href="#Java读取配置文件方法-xml或properties" class="headerlink" title="Java读取配置文件方法 xml或properties"></a>Java读取配置文件方法 xml或properties</h4><p>TODO</p>
<p>反射实例化对象</p>
<h3 id="List-Map-相关"><a href="#List-Map-相关" class="headerlink" title="List &amp;&amp; Map 相关"></a>List &amp;&amp; Map 相关</h3><h4 id="Java集合理解，Map的理解，HashMap关键属性"><a href="#Java集合理解，Map的理解，HashMap关键属性" class="headerlink" title="Java集合理解，Map的理解，HashMap关键属性"></a>Java集合理解，Map的理解，HashMap关键属性</h4><ul>
<li><p>Java集合</p>
<ul>
<li><p>即容器，一个是Collection接口，存放单一元素，另一个是Map接口，存储键值对。</p>
</li>
<li><p>Collection接口下存在Set、List、Queue三大子接口</p>
<ul>
<li><p>List</p>
<ul>
<li><p><code>ArrayList</code>： <code>Object[]</code> 数组</p>
</li>
<li><p><code>Vector</code>：<code>Object[]</code> 数组</p>
</li>
<li><p><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</p>
</li>
<li><p><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</p>
</li>
<li><p><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</p>
</li>
</ul>
</li>
<li><p>Queue</p>
<ul>
<li><p><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</p>
</li>
<li><p><code>ArrayQueue</code>（Dqueue子接口再实现）: <code>Object[]</code> 数组 + 双指针</p>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
</ul>
</li>
<li><p>List: 可存储有序重复的元素</p>
</li>
<li><p>Set: 存储无序不可重复元素</p>
</li>
<li><p>Queue: 按特定规则确定顺序，存储的元素有序可重复</p>
</li>
<li><p>Map: 使用K-V存储，Key无序不可重复，Value无序，可重复，每个Key正常情况下最多映射一个值</p>
</li>
</ul>
</li>
<li><p>HashMap关键属性</p>
<ul>
<li><p>java.util.HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放临界值的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放数组个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"><span class="comment">//临界值，当大小超过时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子，如果增大，空间利用率提高，但是碰撞概率也加大，链表长度增常，降低查找效率</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="用过哪些Map类，都有什么区别，HashMap是线程安全的吗"><a href="#用过哪些Map类，都有什么区别，HashMap是线程安全的吗" class="headerlink" title="用过哪些Map类，都有什么区别，HashMap是线程安全的吗"></a>用过哪些Map类，都有什么区别，HashMap是线程安全的吗</h4><ul>
<li>用过哪些Map类<ul>
<li>ConcurrentHashMap线程安全，K-V 设定为@Nullable。数组+链表+红黑树</li>
<li>LinkedHashMap记录插入顺序</li>
<li>TreeMap根据Key排序</li>
</ul>
</li>
<li>HashMap是线程安全的吗<ul>
<li>不是,HashMap不支持线程的同步</li>
</ul>
</li>
</ul>
<h4 id="Array和List区别"><a href="#Array和List区别" class="headerlink" title="Array和List区别"></a>Array和List区别</h4><ul>
<li>Array大小固定，List动态</li>
<li>Array只能基本类型，List只能保存对象</li>
<li>List有多种实现，提供添加、删除等方法</li>
</ul>
<h4 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h4><p>TODO</p>
<h4 id="为什么ArrayList比LinkedList高效"><a href="#为什么ArrayList比LinkedList高效" class="headerlink" title="为什么ArrayList比LinkedList高效"></a>为什么ArrayList比LinkedList高效</h4><ul>
<li>ArrayList底层是数组，LinkedList底层基于链表。由于数组在内存中是连续的，因此访问元素时间复杂度是O(1),链表需要遍历，时间复杂度是O(n)</li>
</ul>
<h4 id="HashMap比TreeMap更高效吗"><a href="#HashMap比TreeMap更高效吗" class="headerlink" title="HashMap比TreeMap更高效吗"></a>HashMap比TreeMap更高效吗</h4><ul>
<li>HashMap底层是Hash表，TreeMap底层是红黑树。</li>
<li>Hash表查找元素时间复杂度是O(1)，红黑树是O(n log n)，因此少量数据查找方面HashMap更高效</li>
<li>如果是大量数据，当HashMap元素大于MIN_TREEIFY_CAPACITY (默认为64) ，bucket元素达到TREEIFY_THRESHOLD (默认为8) 时，会转换为红黑树。此时TreeMap效率会更高</li>
</ul>
<h4 id="数组链表谁更高效"><a href="#数组链表谁更高效" class="headerlink" title="数组链表谁更高效"></a>数组链表谁更高效</h4><ul>
<li>取决于场景和操作类型，插入删除链表更高效，遍历元素数组更高效</li>
</ul>
<h4 id="如何高效Copy数组"><a href="#如何高效Copy数组" class="headerlink" title="如何高效Copy数组"></a>如何高效Copy数组</h4><ul>
<li>System.copyArray();</li>
<li>Arrays.copyOf();</li>
</ul>
<h4 id="HashMap初始化容量1W，存1W个是否会扩容"><a href="#HashMap初始化容量1W，存1W个是否会扩容" class="headerlink" title="HashMap初始化容量1W，存1W个是否会扩容"></a>HashMap初始化容量1W，存1W个是否会扩容</h4><ul>
<li><p>当数值为1W时，不会扩容，但如果是1000，则会进行扩容</p>
</li>
<li><p>HashMap会调用tableSizeFor方法进行运算，运算 result * 0.75 是初始化的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前方法存在命名不规范问题</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tableSizeFor</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">double</span> <span class="variable">loadFactor</span> <span class="operator">=</span> <span class="number">0.75</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cap_1K</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cap_1W</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Method</span> <span class="variable">tableSizeFor</span> <span class="operator">=</span> HashMap.class.getDeclaredMethod(<span class="string">&quot;tableSizeFor&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">      tableSizeFor.setAccessible(Boolean.TRUE);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result_1K</span> <span class="operator">=</span> (<span class="type">int</span>) tableSizeFor.invoke(<span class="literal">null</span>, cap_1K);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result_1W</span> <span class="operator">=</span> (<span class="type">int</span>) tableSizeFor.invoke(<span class="literal">null</span>, cap_1W);</span><br><span class="line">      System.out.println(<span class="string">&quot;tableSizeFor 1000 result: &quot;</span> + result_1K);</span><br><span class="line">      System.out.println(<span class="string">&quot;tableSizeFor 10000 result: &quot;</span> + result_1W + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">finalSize_1K</span> <span class="operator">=</span> (<span class="type">int</span>) (result_1K * loadFactor);</span><br><span class="line">      <span class="type">int</span> <span class="variable">finalSize_1W</span> <span class="operator">=</span> (<span class="type">int</span>) (result_1W * loadFactor);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;finalSize 1000 result: &quot;</span> + finalSize_1K);</span><br><span class="line">      System.out.println(<span class="string">&quot;finalSize 10000 result: &quot;</span> + finalSize_1W);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor 1000 result: 1024</span></span><br><span class="line"><span class="comment">//tableSizeFor 10000 result: 16384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//finalSize 1000 result: 768</span></span><br><span class="line"><span class="comment">//finalSize 10000 result: 12288</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="解决Hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决Hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决Hash冲突的办法有哪些？HashMap用的哪种？"></a>解决Hash冲突的办法有哪些？HashMap用的哪种？</h4><ul>
<li>解决Hash冲突的办法有哪些<ul>
<li>开放地址法：被占用就找下一个位置。下一个位置的方案有 线性探测再散列，平方探测再散列，随机探测再散列<ul>
<li>线性探测再散列：发生冲突时，顺序查看哈希表下一单元是否可用，直到找到可用的单元</li>
<li>二次探测再散列：发生冲突时，以冲突的位置为中心向左右探测是否有可用单元</li>
<li>伪随机探测再散列：通过一组伪随机数列计算得到对应的单位位置</li>
</ul>
</li>
<li>链地址法：Hash相同的放在一个新的同义词链的链表里，链头指针放到Value位置</li>
<li>再散列：运用多个Hash函数，冲突时使用其他函数运算值</li>
<li>建立公共溢出区：将Hash表分为基本表和溢出表，发生冲突的全放入溢出表</li>
</ul>
</li>
<li>HashMap用的哪种<ul>
<li>链地址法</li>
</ul>
</li>
</ul>
<h4 id="HashMap如何通过K-V管理数据"><a href="#HashMap如何通过K-V管理数据" class="headerlink" title="HashMap如何通过K-V管理数据"></a>HashMap如何通过K-V管理数据</h4><ul>
<li>HashMap是一种机遇哈希表实现Map接口的数据结构，由数组+链表&#x2F;红黑树组成的。HashMap美国元素成为Entry，由Key-Value组成</li>
<li>底层是数组，美国元素是一个链表。当添加一个元素时，先根据Key的HashCode计算出该元素在Array中Bucket的位置，如果没有将元素放入Bucket，如果有，则遍历Bucket中的LinkedList，如果遍历有相同Key则替换Value，如果没有则将元素添加到Linked List 末尾</li>
</ul>
<h4 id="HashMap为什么选择2的倍数当作容量"><a href="#HashMap为什么选择2的倍数当作容量" class="headerlink" title="HashMap为什么选择2的倍数当作容量"></a>HashMap为什么选择2的倍数当作容量</h4><ul>
<li><p>扩容时位运算效率高</p>
</li>
<li><p><code>key.hashCode() &amp;  (length-1)</code>  碰撞概率降低</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/422840340">https://www.zhihu.com/question/422840340</a></p>
</li>
</ul>
<h4 id="HashMap初始为什么16"><a href="#HashMap初始为什么16" class="headerlink" title="HashMap初始为什么16"></a>HashMap初始为什么16</h4><ul>
<li>JDK 没有给出理由，可能是位运算方便，且16更通用于业务</li>
</ul>
<h4 id="HashMap因子为什么是0-75"><a href="#HashMap因子为什么是0-75" class="headerlink" title="HashMap因子为什么是0.75"></a>HashMap因子为什么是0.75</h4><ul>
<li><p>可能与泊松分布相关。过小占有空间大，过大容易增加碰撞概率，0.75属于经验中间值，提高利用率且降低冲突。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023308658">https://segmentfault.com/a/1190000023308658</a></p>
</li>
</ul>
<h4 id="HashMap扩容后如何再散列（rehash）"><a href="#HashMap扩容后如何再散列（rehash）" class="headerlink" title="HashMap扩容后如何再散列（rehash）"></a>HashMap扩容后如何再散列（rehash）</h4><ul>
<li>创建新数组，大小为原来数组大小的2倍</li>
<li>遍历数组中每一个元素，重新hash并放入新数组对应的位置中</li>
<li>如果出现hash冲突，则使用链表或红黑树等数据结构解决</li>
<li>当所有元素rehash完成后，使用新数组体会旧数组</li>
<li>该操作期间需要保证线程安全！</li>
</ul>
<h4 id="HashMap在Java-7-为什么会进入死循环"><a href="#HashMap在Java-7-为什么会进入死循环" class="headerlink" title="HashMap在Java 7 为什么会进入死循环"></a>HashMap在Java 7 为什么会进入死循环</h4><ul>
<li><p>JDK 1.7 使用头插法（bucket index &#x3D; hash &amp; (n-1)，头插法+链表+多线程+HashMap扩容可能导致死循环</p>
</li>
<li><p>问题主要出在头插法时，新元素是插入链表头部的，某些情况下会导致链表倒置，从而导致链表长度变长，进而影响遍历时间，最坏情况下无法遍历到数据，造成死循环</p>
</li>
<li><p>具体而言：头插入新元素时，遇到相同Key，新节点会放到链表头部，原来的节点成为新节点next指针，这样就会出现链表倒置。这种倒置是循序渐进的，一个节点的next指针会指向下一个节点的next指针，这样会倒置整个链表顺序被倒置。</p>
</li>
<li><p>这部分内容与多线程有密切关联。</p>
<p>插入相同Key节点时，Thread-A执行，将节点插入链表头部，链表变为{A-B-C}，此时Thread-B也执行，它看到的仍然是{A-B-C}，插入新节点后变成{B’-A-B-C},其中B’ 是Thread-B新插入的节点，如果另一个线程执行查询操作，从头部查询，发现链表中存在两个相同的Key，导致查询错误。</p>
</li>
<li><p>Java 8 使用尾插法解决该问题，但如果Hash冲突过多，仍会导致链表过长，影响查询效率，因此需尽量避免hash冲突</p>
</li>
</ul>
<h4 id="HashMap为什么要在存储量变更时切换结构，如何切换"><a href="#HashMap为什么要在存储量变更时切换结构，如何切换" class="headerlink" title="HashMap为什么要在存储量变更时切换结构，如何切换"></a>HashMap为什么要在存储量变更时切换结构，如何切换</h4><ul>
<li>当元素超过阈值时（容量*0.75），需要进行扩容操作</li>
<li>扩容会进行rehash操作，这个过程需要保证线程安全。这个扩容可能发生哈希冲突</li>
<li>避免每次判断这个位置是链表还是红黑树，当Hash冲突达到8时，HashMap会将链表转换为红黑树。当红黑树元素小于6时，会退化成链表。</li>
</ul>
<h4 id="HashMap为什么查询时间复杂度为O-1"><a href="#HashMap为什么查询时间复杂度为O-1" class="headerlink" title="HashMap为什么查询时间复杂度为O(1)"></a>HashMap为什么查询时间复杂度为O(1)</h4><p>TODO</p>
<h4 id="ConcurrentHashMap如何解决安全问题"><a href="#ConcurrentHashMap如何解决安全问题" class="headerlink" title="ConcurrentHashMap如何解决安全问题"></a>ConcurrentHashMap如何解决安全问题</h4><ul>
<li><p>JDK 7中，使用分段锁，多线程可以在每个分段操作避免冲突。如果在同一个Segment操作，则由当前Segment提供互斥锁保证线程安全（内部使用volatile、synchronized，CAS机制保障）。遍历数据基于快照查询，保证不会抛出ConcurrentModificationException异常。</p>
</li>
<li><p>JDK 8中，使用CAS操作的无锁并发控制，相比于分段锁，减少锁竞争，提高性能。同样基于分段，但是使用的是基于 CAS 和 Synchronized 的新机制，即使用了一种名为 <code>synchronized-with-capacity</code> 的策略。</p>
<p>线程数量不多时使用CAS，当线程超过某个阈值时转换为synchronized，此时比CAS效率更高。</p>
<p>与JDK7分段锁的区别，降低了锁的颗粒度，将锁整个Map，变更锁Segment对象，减少锁竞争与锁开销，提高并发性能。</p>
</li>
</ul>
<h4 id="ConcurrentHashMap在Java-7性能问题"><a href="#ConcurrentHashMap在Java-7性能问题" class="headerlink" title="ConcurrentHashMap在Java 7性能问题"></a>ConcurrentHashMap在Java 7性能问题</h4><ul>
<li>分段锁锁整个Map，增加开销降低并发性能</li>
</ul>
<h4 id="ConcurrentHashMap为什么在Java-8放弃了分段锁"><a href="#ConcurrentHashMap为什么在Java-8放弃了分段锁" class="headerlink" title="ConcurrentHashMap为什么在Java 8放弃了分段锁"></a>ConcurrentHashMap为什么在Java 8放弃了分段锁</h4><ul>
<li>为了提升性能</li>
</ul>
<h4 id="什么是阻塞队列？你知道Java中有哪些阻塞队列吗？"><a href="#什么是阻塞队列？你知道Java中有哪些阻塞队列吗？" class="headerlink" title="什么是阻塞队列？你知道Java中有哪些阻塞队列吗？"></a>什么是阻塞队列？你知道Java中有哪些阻塞队列吗？</h4><ul>
<li>什么是阻塞队列<ul>
<li>是一种特殊的数据结构，在队列已满或空的情况下，会暂停插入&#x2F;获取操作，直到满足插入&#x2F;获取条件为止，从而有效协调多线程之间的数据交换</li>
</ul>
</li>
<li>阻塞队列举例<ul>
<li>ArrayBlockingQueue：数组有界队列，FIFO</li>
<li>LinkedBlockingQueue：链表有界队列，FIFO。如果列表为空，获取操作会进入阻塞状态</li>
<li>PriorityBlockingQueue：支持优先级排序的无界队列，元素按照自然排序或指定排序，为空时获取操作进入阻塞状态</li>
<li>SynchronousQueue：不存储元素的队列，用于线程之间之间传输，每个插入操作必须等待另一个线程的删除操作，否则插入会一直堵塞。同理，每个删除也必须等待一个插入动作。</li>
<li>DelayQueue： 支持延迟获取元素的无界阻塞队列，元素只有到期才能获取。排序可以FIFO也可以自定义</li>
</ul>
</li>
</ul>
<h4 id="ArrayBlockingQueue原理"><a href="#ArrayBlockingQueue原理" class="headerlink" title="ArrayBlockingQueue原理"></a>ArrayBlockingQueue原理</h4><ul>
<li>实现BlockingQueue接口，容量需指定，且不可变</li>
<li>内部使用一个长数组作为队列的存储结构，队列的头尾分别对应数组的头尾，队列满时抛异常，空时阻塞。</li>
<li>基于经典的”Pub-Sub”模型</li>
<li>内部维护了一个ReentrantLock和2个Condition，分别用于控制生产者线程和消费者线程的等待和唤醒。当队列已满时，生产者线程调用 put() 方法时会被阻塞，直到有其他线程从队列中取出一个元素并调用了 signal() 方法唤醒生产者线程；当队列为空时，消费者线程调用 take() 方法时会被阻塞，直到有其他线程向队列中插入了一个元素并调用了 signal() 方法唤醒消费者线程</li>
</ul>
<h4 id="用Java写代码来解决生产者——消费者问题"><a href="#用Java写代码来解决生产者——消费者问题" class="headerlink" title="用Java写代码来解决生产者——消费者问题"></a>用Java写代码来解决生产者——消费者问题</h4><ul>
<li><pre><code class="java">private static ExecutorService executorService = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(5 * 2), new ThreadPoolExecutor.CallerRunsPolicy());

  // 缓冲区大小
  final int capacity = 5;
  // 缓冲区
  LinkedList&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();


  public static void main(String[] args) &#123;
      //生产者线程
      executorService.execute(()-&gt;new ProducerConsumerExampleTest().publish());
      // 消费者线程
      executorService.execute(()-&gt;new ProducerConsumerExampleTest().subscribe());
  &#125;

  private void publish() &#123;
      int value = 0;
      while (true) &#123;
          synchronized (buffer) &#123;
              while (buffer.size() == capacity) &#123;
                  try &#123;
                      buffer.wait();
                  &#125; catch (InterruptedException e) &#123;
                      e.printStackTrace();
                  &#125;
              &#125;
              //生产数据并加入缓冲区
              buffer.add(value++);
              log.info(&quot;生产者生产了：&#123;&#125;&quot;, value);
              //通知消费者消费
              buffer.notifyAll();
          &#125;
      &#125;
  &#125;

  private void subscribe() &#123;
      while (true) &#123;
          synchronized (buffer) &#123;
              while (buffer.isEmpty()) &#123;
                  try &#123;
                      buffer.wait();
                  &#125; catch (InterruptedException e) &#123;
                      e.printStackTrace();
                  &#125;
              &#125;
              // 从缓冲区中取出数据并消费
              int value = buffer.remove();
              log.info(&quot;生产者消费了：&#123;&#125;&quot;, value);

              //通知生产者生产
              buffer.notifyAll();
          &#125;
      &#125;
  &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Thread &amp;&amp; Lock 相关</span><br><span class="line"></span><br><span class="line">#### 进程和线程的区别，使用线程真的能节省时间吗</span><br><span class="line"></span><br><span class="line">- 进程间数据独立，线程数据共享，一个进程可以包括多个线程</span><br><span class="line">- 不一定，要看设置是否合理，CPU分页调度问题</span><br><span class="line"></span><br><span class="line">#### 线程实现方式</span><br><span class="line"></span><br><span class="line">- 继承Thread</span><br><span class="line">- 实现Runnable/Callable</span><br><span class="line"></span><br><span class="line">#### 线程有几种状态</span><br><span class="line"></span><br><span class="line">- 在JAVA中有六种状态</span><br><span class="line"></span><br><span class="line">  ![Thread_State](./Collection-InterviewQuestion/fa697f963b38ee9ec2fd535a41ad25d9.png)</span><br><span class="line"></span><br><span class="line">- new创建进入初始状态，start方法进入就绪状态。线程只要抢占了CPU时间片就能不获得全部的锁运行，但当运行到需要的锁而仍未获得时，进入阻塞状态。</span><br><span class="line"></span><br><span class="line">- 线程被Sleep后，会先进入超时等待状态，时间结束后会先进入等待阻塞状态，当有锁以后再进入就绪状态</span><br><span class="line"></span><br><span class="line">- java.lang.Thread.State</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">    /**</span><br><span class="line">     * A thread state.  A thread can be in one of the following states:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #NEW&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that has not yet started is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #RUNNABLE&#125;&lt;br&gt;</span><br><span class="line">     *     A thread executing in the Java virtual machine is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #BLOCKED&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is blocked waiting for a monitor lock</span><br><span class="line">     *     is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #WAITING&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is waiting indefinitely for another thread to</span><br><span class="line">     *     perform a particular action is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #TIMED_WAITING&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is waiting for another thread to perform an action</span><br><span class="line">     *     for up to a specified waiting time is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #TERMINATED&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that has exited is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * A thread can be in only one state at a given point in time.</span><br><span class="line">     * These states are virtual machine states which do not reflect</span><br><span class="line">     * any operating system thread states.</span><br><span class="line">     *</span><br><span class="line">     * @since   1.5</span><br><span class="line">     * @see #getState</span><br><span class="line">     */</span><br><span class="line">    public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line">  </span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line">  </span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line">  </span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line">  </span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">  </span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="线程如何设置优先级"><a href="#线程如何设置优先级" class="headerlink" title="线程如何设置优先级"></a>线程如何设置优先级</h4><ul>
<li>给线程设置优先级，最大10，最小1，优先级设置完成后，只是增大了被cpu调度的机会，并不是绝对优先执行</li>
<li>Thread.setPriority(10)</li>
</ul>
<h4 id="什么是竞争条件？你怎样发现和解决竞争"><a href="#什么是竞争条件？你怎样发现和解决竞争" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争"></a>什么是竞争条件？你怎样发现和解决竞争</h4><ul>
<li><p>什么是竞争条件</p>
<ul>
<li>多线程不确定的执行顺序导致不正确的结果，就是竞争条件</li>
</ul>
</li>
<li><p>你怎样发现和解决竞争</p>
<ul>
<li><p>发现</p>
<p>使用Java竞争条件坚持工具，如Facebook开源的RacerD</p>
</li>
<li><p>解决</p>
<p>可以采用加锁的方式使线程串行访问临界区</p>
</li>
</ul>
</li>
</ul>
<h4 id="在Java中CyclicBarrier和CountdownLatch有什么区别"><a href="#在Java中CyclicBarrier和CountdownLatch有什么区别" class="headerlink" title="在Java中CyclicBarrier和CountdownLatch有什么区别"></a>在Java中CyclicBarrier和CountdownLatch有什么区别</h4><table>
<thead>
<tr>
<th>区别</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>计数方式</td>
<td>递减计数</td>
<td>加法计数</td>
</tr>
<tr>
<td>可重复利用性</td>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
<tr>
<td>初始值</td>
<td>初始值为N, N&gt;0</td>
<td>N为0</td>
</tr>
<tr>
<td>计数方式</td>
<td>调用countDown, N-1</td>
<td>调用await, N+1</td>
</tr>
<tr>
<td>阻塞条件</td>
<td>N&gt;0,调用await一直阻塞</td>
<td>N小于指定值</td>
</tr>
<tr>
<td>何时释放等待线程</td>
<td>计数为0时</td>
<td>计数达到指定值N</td>
</tr>
</tbody></table>
<h4 id="你知道哪几种锁？分别有什么特点？"><a href="#你知道哪几种锁？分别有什么特点？" class="headerlink" title="你知道哪几种锁？分别有什么特点？"></a>你知道哪几种锁？分别有什么特点？</h4><ul>
<li><p>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</p>
<p>特指synchronized锁状态，通过对象头中的mark word表明锁状态</p>
<ul>
<li>偏向锁：当线程获取锁时，打上标记，不做其他事</li>
<li>轻量级锁：多线程情况下，并发竞争锁或短时间竞争锁，通过CAS即可获取，当锁被其他线程获取时，自旋等待获取锁，不进行阻塞</li>
<li>重量级锁：自旋达到16次时还未获取到锁，则升级为重锁，线程进入阻塞状态</li>
</ul>
</li>
<li><p>可重入锁&#x2F;非可重入锁</p>
<ul>
<li>可重入锁：当前线程已经持有这把锁，可以不释放这把锁情况下，再次获取这把锁。如ReentrrantLock</li>
<li>不可重入锁：当前线程持有这把锁，需要先释放，才能再次获取这把锁</li>
</ul>
</li>
<li><p>共享锁&#x2F;独占锁</p>
<ul>
<li>共享锁：一把锁可以被多个线程共同持有</li>
<li>独占锁：一把锁只能被一个线程持有</li>
</ul>
</li>
<li><p>公平锁&#x2F;非公平锁</p>
<ul>
<li>公平锁：线程拿不到锁情况下进入等待队列顺序获取锁</li>
<li>非公平锁：线程拿不到锁，在锁释放时争抢锁</li>
</ul>
</li>
<li><p>悲观锁&#x2F;乐观锁</p>
<ul>
<li>悲观锁：获取资源之前必须先拿到锁，其他未能获取锁的线程无法影响当前线程</li>
<li>乐观锁：利用CAS，不独占资源状态下，完成对资源的修改</li>
</ul>
</li>
<li><p>自旋锁&#x2F;非自旋锁</p>
<ul>
<li>自旋锁：线程拿不到锁时，进入循环无限请求锁资源直至获取</li>
<li>非自旋锁：拿不到锁就放弃&#x2F;处理其他逻辑</li>
</ul>
</li>
<li><p>可中断锁&#x2F;不可中断锁</p>
<ul>
<li>可中断锁：获取锁过程中突然要不想获取了，可以中断后做其他事，不需要一直等待获取锁。ReentrantLock就是可中断锁，打断方法为lockInterruptible</li>
<li>不可中断锁：一旦申请锁，只能一直等待直到获取成功，中途不可执行其他事件。Synchronized修饰的锁就锁不可中断锁</li>
</ul>
</li>
</ul>
<h4 id="synchronized为什么是重量级锁，从系统层面讲"><a href="#synchronized为什么是重量级锁，从系统层面讲" class="headerlink" title="synchronized为什么是重量级锁，从系统层面讲"></a>synchronized为什么是重量级锁，从系统层面讲</h4><ul>
<li>synchronized加锁操作底层依赖操作系统的pthread_mutex_lock，多个线程同时调用这个函数时，会让每个线程都切换入内核态，由内核协调哪个线程获取到锁。</li>
<li>线程竞争调用系统底层Mutex互斥语句，存在用户态和内核态的转换，大量消耗系统资源，因此在系统层面称为重量级(Heavyweight)的操作</li>
</ul>
<h4 id="synchronize锁有几种"><a href="#synchronize锁有几种" class="headerlink" title="synchronize锁有几种"></a>synchronize锁有几种</h4><ul>
<li>普通方法（对象级别）</li>
<li>静态方法（全局锁）</li>
<li>代码块（需指定一个对象，this为每个对象加锁，xxx.class使用某个类加锁）</li>
</ul>
<h4 id="synchronize锁是安全的吗"><a href="#synchronize锁是安全的吗" class="headerlink" title="synchronize锁是安全的吗"></a>synchronize锁是安全的吗</h4><p>TODO</p>
<h4 id="线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？"><a href="#线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？" class="headerlink" title="线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？"></a>线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？</h4><ul>
<li>线程加锁有哪些方式<ul>
<li>synchronized keyword</li>
<li>Lock Interface</li>
<li>Semaphore</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>so on</li>
</ul>
</li>
<li>synchronized和lock的区别<ul>
<li>synchronized是JVM内置，Lock是juc实现</li>
<li>synchronized只能使用内置monitor锁，Lock有多种实现</li>
<li>synchronized是非公锁，Lock可公平可非公平</li>
<li>synchronized可以自动释放，Lock需要手动释放</li>
<li>Lock实现了可中断、可重入和定时锁获取功能</li>
</ul>
</li>
<li>Lock接口比synchronized块的优势是什么<ul>
<li>可中断</li>
<li>可定时获取锁</li>
<li>多种实现</li>
<li>可选公平非公</li>
</ul>
</li>
</ul>
<h4 id="JUC提供的锁与synchronized有什么区别"><a href="#JUC提供的锁与synchronized有什么区别" class="headerlink" title="JUC提供的锁与synchronized有什么区别"></a>JUC提供的锁与synchronized有什么区别</h4><ul>
<li>可重入性：JUC和synchronized都支持可重入，但synchronized用的是Monitor，JUC用的是state记录重入次数。JUC的锁需用户主动释放锁</li>
<li>可中断性：JUC可中断，synchronized不可中断</li>
<li>公平锁：synchronized默认非公锁</li>
<li>性能：低并发下synchronized可能更好，高并发JUC可能更好</li>
<li>灵活性：JUC更灵活</li>
</ul>
<h4 id="Java-11-的synchronized锁升级"><a href="#Java-11-的synchronized锁升级" class="headerlink" title="Java 11 的synchronized锁升级"></a>Java 11 的synchronized锁升级</h4><ul>
<li><p>Java 11 用在代码块进入和退出时，手动选择轻量级锁，从而提高性能。</p>
<p>并非取消锁升级，而是优化synchronized性能</p>
</li>
</ul>
<h4 id="synchronized加在多个非静态函数，函数之间什么关系"><a href="#synchronized加在多个非静态函数，函数之间什么关系" class="headerlink" title="synchronized加在多个非静态函数，函数之间什么关系"></a>synchronized加在多个非静态函数，函数之间什么关系</h4><p>TODO</p>
<h4 id="乐观锁和悲观锁的本质区别"><a href="#乐观锁和悲观锁的本质区别" class="headerlink" title="乐观锁和悲观锁的本质区别"></a>乐观锁和悲观锁的本质区别</h4><ul>
<li><p>乐观锁</p>
<p>不锁住对象，使用数据比对确认数据是否被修改，若修改则报错&#x2F;重试</p>
</li>
<li><p>悲观锁</p>
<p>先获取锁，其他线程无法在此时争抢锁</p>
</li>
</ul>
<h4 id="CAS-for循环过于消耗cpu怎么办，如何实现公平队列"><a href="#CAS-for循环过于消耗cpu怎么办，如何实现公平队列" class="headerlink" title="CAS for循环过于消耗cpu怎么办，如何实现公平队列?"></a>CAS for循环过于消耗cpu怎么办，如何实现公平队列?</h4><p>TODO</p>
<p>ReentrantLock# condition </p>
<h4 id="volatile是否能保证线程安全"><a href="#volatile是否能保证线程安全" class="headerlink" title="volatile是否能保证线程安全"></a>volatile是否能保证线程安全</h4><ul>
<li><p>单volatile不可以</p>
<p>它只能保证可见性和有序性，不能保证原子性。它可以保证一个线程变更的数据立即写入主内存，确保其他线程的可见性。同时，可以防止Java语言编译后的指令重排序，保证有序性。</p>
<p>但是，如果需要多个操作同时具有原子性，无法保证，需要用锁或原子类</p>
</li>
<li><p>CAS+volatile+Atomic可以保证</p>
</li>
</ul>
<h4 id="伪共享-False-Sharing-怎么理解"><a href="#伪共享-False-Sharing-怎么理解" class="headerlink" title="伪共享 (False Sharing) 怎么理解"></a>伪共享 (False Sharing) 怎么理解</h4><ul>
<li>多个线程同时访问同一块缓存中不同的变量&#x2F;对象，导致每次更新缓存时，都会使其他线程的缓存行失效，导致不必要的缓存同步，最终导致性能损失</li>
<li>可以通过调整变量的位置或者在变量之间插入padding，使不同变量之间占用不同的缓存行，避免缓存同步（如@Contended 但需测试优化）</li>
</ul>
<h4 id="需要实现一个高效的缓存，该缓存允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现"><a href="#需要实现一个高效的缓存，该缓存允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现" class="headerlink" title="需要实现一个高效的缓存，该缓存允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现"></a>需要实现一个高效的缓存，该缓存允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现</h4><ul>
<li><p>ReentrantReadWriteLock</p>
<p>支持多线程读，单线程写</p>
</li>
</ul>
<h4 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h4><ul>
<li>CPU分页。不合理线程的设置。</li>
</ul>
<h4 id="线程池中的线程调度，负载太大怎么办"><a href="#线程池中的线程调度，负载太大怎么办" class="headerlink" title="线程池中的线程调度，负载太大怎么办"></a>线程池中的线程调度，负载太大怎么办</h4><ul>
<li><p>优化线程池参数</p>
<p>减少核心树降低开销等</p>
</li>
<li><p>负载均衡策略</p>
<p>将同一线程池任务分配到多个线程池执行或者中间件扩容</p>
</li>
<li><p>优化任务处理</p>
<p>优化调用的任务减少线程负载</p>
</li>
</ul>
<h4 id="线程池基本原理、使用场景、注意事项、关联的连接池"><a href="#线程池基本原理、使用场景、注意事项、关联的连接池" class="headerlink" title="线程池基本原理、使用场景、注意事项、关联的连接池"></a>线程池基本原理、使用场景、注意事项、关联的连接池</h4><p>TODO</p>
<h4 id="线程池线程管理AQS"><a href="#线程池线程管理AQS" class="headerlink" title="线程池线程管理AQS"></a>线程池线程管理AQS</h4><p>TODO</p>
<h4 id="线程池阻塞非阻塞"><a href="#线程池阻塞非阻塞" class="headerlink" title="线程池阻塞非阻塞"></a>线程池阻塞非阻塞</h4><ul>
<li><p>阻塞</p>
<p>遇到IO将发生阻塞，程序遇到阻塞操作就停在原地，立即释放CPU资源</p>
</li>
<li><p>非阻塞</p>
<p>没有遇到IO操作，或者通过某种手段让程序即使遇到IO操作也不会停在原地执行其他操作，力求尽可能多占CPU</p>
</li>
</ul>
<h4 id="线程池Cancel策略"><a href="#线程池Cancel策略" class="headerlink" title="线程池Cancel策略"></a>线程池Cancel策略</h4><p>TODO</p>
<h4 id="线程池的背压"><a href="#线程池的背压" class="headerlink" title="线程池的背压"></a>线程池的背压</h4><ul>
<li>有界队列满时抛出异常，及时给上游反馈</li>
</ul>
<h4 id="Java线程池与Tomcat线程池异同"><a href="#Java线程池与Tomcat线程池异同" class="headerlink" title="Java线程池与Tomcat线程池异同"></a>Java线程池与Tomcat线程池异同</h4><ul>
<li><p>Java线程池</p>
<p>当线程池中线程数量小于corePoolSize，每来一个任务，就会创建一个线程执行这个任务。</p>
<p>当前线程池线程数量大于等于corePoolSize，则每来一个任务。会尝试将其添加到任务缓存队列中，若是添加成功，则该任务会等待线程将其取出去执行；若添加失败（一般来说任务缓存队列已满），则会尝试创建新的线程执行。</p>
<p>当前线程池线程数量等于maximumPoolSize，则会采取任务拒绝策略进行处理。</p>
</li>
<li><p>Tomcat线程池</p>
<p>当前线程数小于corePoolSize，则去创建工作线程；</p>
<p>当前线程数大于corePoolSize，但小于maximumPoolSize，则去创建工作线程；</p>
<p>当前线程数大于maximumPoolSize，则将任务放入到阻塞队列中，当阻塞队列满了之后，则调用拒绝策略丢弃任务；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/63bfba7c66c7">https://www.jianshu.com/p/63bfba7c66c7</a></p>
</li>
</ul>
<h4 id="Thread-sleep-Object-wait-LockSupport-park-Condition-await-区别"><a href="#Thread-sleep-Object-wait-LockSupport-park-Condition-await-区别" class="headerlink" title="Thread.sleep(), Object.wait(), LockSupport.park(),Condition.await()区别"></a>Thread.sleep(), Object.wait(), LockSupport.park(),Condition.await()区别</h4><ul>
<li>Thread.sleep()<ul>
<li>必须指定休眠时间</li>
<li>休眠时线程状态为TIME_WAITING</li>
<li>需要捕获InterruptedException异常</li>
<li>不会释放持有的锁</li>
<li>只能等待自己到时间后醒来，唤醒后一定执行后续代码</li>
<li>本身是一个Native方法</li>
<li>通常被用于暂停</li>
</ul>
</li>
<li>Object.wait()<ul>
<li>不带时间的重载可以通过Thread.notify()唤醒，也可以等待超时唤醒。notify()必须在wait()之后执行，否则会丢失唤醒信号</li>
<li>唤醒后不一定执行后续代码</li>
<li>休眠时线程状态为WAITTING</li>
<li>需要捕获InterruptedException异常</li>
<li>会释放持有的锁<ul>
<li>调用Object.wait()时需先上锁，JVM底层会进行检查是否上锁，没持有则抛出IllegalMonitorStateException异常   synchronized (waitObject){waitObject.wait()}</li>
<li>调用Object.notify()时也需要上锁，否则如果当前线程不是对象锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</li>
</ul>
</li>
<li>wait(TimeOut)是一个Native方法</li>
<li>通常被用于线程间交互</li>
</ul>
</li>
<li>LockSupport.park()<ul>
<li>通过二元信号量实现的阻塞</li>
<li>底层调用的是UnSafe的Native方法park()</li>
<li>休眠时线程状态为WAITING</li>
<li>无需捕获InterruptedException异常，但也会响应中断</li>
<li>不会释放持有的锁</li>
<li>可以通过unpark()唤醒， unpack()方法可以比 park() 先执行，不会丢失唤醒信号</li>
<li>唤醒后一定执行后续代码</li>
</ul>
</li>
<li>Condition.await()<ul>
<li>不带时间的重载只能通过另一个的Condition.single()唤醒，唤醒后不一定执行后续代码</li>
<li>await还是single都必须先ReentreentLock的lock()块中执行，否则IllegalMonitorStateException异常</li>
<li>single不能在其之前执行</li>
<li>需要捕获InterruptedException异常</li>
<li>会释放锁资源</li>
<li>底层调用LockSupport.park()实现</li>
</ul>
</li>
</ul>
<h4 id="Java中怎样唤醒一个阻塞的线程"><a href="#Java中怎样唤醒一个阻塞的线程" class="headerlink" title="Java中怎样唤醒一个阻塞的线程"></a>Java中怎样唤醒一个阻塞的线程</h4><ul>
<li>Object.wait()使用Object.notify()唤醒。必须配合synchronized使用</li>
<li>Condition.await()使用Condition.singal()唤醒。需搭配ReentrantLock使用</li>
<li>LockSupport.park()使用LockSupport.unpark()唤醒。</li>
</ul>
<h4 id="wait与await区别"><a href="#wait与await区别" class="headerlink" title="wait与await区别"></a>wait与await区别</h4><ul>
<li>wait与notify必须配合synchronized使用，因为调用之前必须持有锁，wait会立即释放锁，notify则是同步块执行完了才释放</li>
<li>因为Lock没有使用synchronized机制，故无法使用wait方法区操作多线程，所以使用了Condition的await来操作</li>
<li>Lock实现主要是基于AQS，而AQS实现则是基于LockSupport，所以说LockSupport更底层，所以使用park效率会高一些</li>
</ul>
<h4 id="Thread-sleep-0-目的"><a href="#Thread-sleep-0-目的" class="headerlink" title="Thread.sleep(0)目的"></a>Thread.sleep(0)目的</h4><ul>
<li>让GC线程有机会被操作系统选中，从而进行垃圾清理工作。但可能导致频繁GC问题</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012060033/article/details/126781986">https://blog.csdn.net/u012060033/article/details/126781986</a></li>
</ul>
<h4 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h4><ul>
<li>使线程让出当前被调度机会</li>
<li>但是与Thread.sleep()不考虑线程优先级问题，谁都有机会抢到下一次机会。yield()只会给同等优先级或更高的线程运行</li>
<li>调用sleep()进入阻塞状态，yield()进入就绪状态，yield可能会再运行一小会儿才交出机会</li>
<li>sleep抛出InterruptedException，yield无异常。</li>
</ul>
<h4 id="在Java进程中的通信方式有哪些"><a href="#在Java进程中的通信方式有哪些" class="headerlink" title="在Java进程中的通信方式有哪些"></a>在Java进程中的通信方式有哪些</h4><p>TODO</p>
<h4 id="在Java中线程间有哪些通信方式"><a href="#在Java中线程间有哪些通信方式" class="headerlink" title="在Java中线程间有哪些通信方式"></a>在Java中线程间有哪些通信方式</h4><ul>
<li>volatile，synchronized关键字</li>
<li>join() 方法</li>
<li>ThreadLocal</li>
<li>等待&#x2F;通知 Object.wait() Object.notify()&#x2F;notifyAll()</li>
<li>管道输入输出流</li>
</ul>
<h4 id="多进程与多线程的区别"><a href="#多进程与多线程的区别" class="headerlink" title="多进程与多线程的区别"></a>多进程与多线程的区别</h4><p>TODO</p>
<h4 id="为什么AtomicInteger在高并发下性能不好"><a href="#为什么AtomicInteger在高并发下性能不好" class="headerlink" title="为什么AtomicInteger在高并发下性能不好"></a>为什么AtomicInteger在高并发下性能不好</h4><ul>
<li>性能不好原因<ul>
<li>CAS竞争激烈</li>
<li>缓存行伪共享</li>
</ul>
</li>
<li>解决策略<ul>
<li>减少竞争：ThreadLocal或分段锁减少对同一个AtomicInteger对象竞争</li>
<li>避免缓存行伪共享：可以利用 <code>缓存行填充</code> 技巧，在AtomicInteger对象前后填充数据增加缓存行大小</li>
</ul>
</li>
</ul>
<h4 id="有哪些解决死锁问题的策略"><a href="#有哪些解决死锁问题的策略" class="headerlink" title="有哪些解决死锁问题的策略"></a>有哪些解决死锁问题的策略</h4><ul>
<li>死锁必要条件<ul>
<li>互斥：一个资源每次只能被一个进程使用</li>
<li>请求与保持：一个进程因请求资源而被阻塞时，对已获得的资源保存不放</li>
<li>不剥夺：进程已获得的资源，在未使用完前，不能强行剥夺</li>
<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
</li>
<li>死锁解决策略<ul>
<li>预防死锁：设计算法或协议避免死锁发生，如顺序申请锁，避免嵌套、限制资源分配</li>
<li>检测死锁：使用死锁检测算法（如银行家算法）检测死锁</li>
<li>避免死锁</li>
<li>解除死锁</li>
</ul>
</li>
</ul>
<h4 id="有哪些线程安全问题"><a href="#有哪些线程安全问题" class="headerlink" title="有哪些线程安全问题"></a>有哪些线程安全问题</h4><ul>
<li><p>竞态条件 (Race Condition)</p>
<p>执行顺序不确定或时间差原因，导致结果出现不同情况</p>
<ul>
<li>使用Atomic类解决</li>
</ul>
</li>
<li><p>死锁(Deadlock)</p>
<p>多线程互相等待对方释放锁</p>
</li>
<li><p>数据不一致(Inconsistent Data)</p>
<p>多个线程同时对共享资源进行修改，最终导致结果不一致</p>
<ul>
<li>volatile配合Lock解决</li>
</ul>
</li>
<li><p>内存泄漏(Memory Leak)</p>
<p>某个对象被多个线程引用，其中一个线程将对象引用设置为null，导致其他线程无法访问，但该对象无法被垃圾回收</p>
<ul>
<li>与ThreadLocal不同，由于某些原因无法释放内存，而ThreadLocal的K为null且V未被其他引用时，最终仍可回收，V被引用且线程一直存在才无法回收</li>
</ul>
</li>
<li><p>Double Check Lock问题</p>
<p>volatile解决</p>
</li>
<li><p>并发修改异常 (ConcurrentModificationException)</p>
<p>迭代集合时，若有其他线程修改了集合，则抛出异常</p>
</li>
<li><p>重排序问题</p>
<p>volatile解决</p>
</li>
</ul>
<h4 id="线程池有哪几种拒绝策略"><a href="#线程池有哪几种拒绝策略" class="headerlink" title="线程池有哪几种拒绝策略"></a>线程池有哪几种拒绝策略</h4><ul>
<li>AbortPolicy：中止策略，线程池会<strong>抛出异常</strong>并中止执行此任务;</li>
<li>CallerRunsPolicy：把任务交给添加此任务的(main)线程来执行;</li>
<li>DiscardPolicy：忽略此任务，忽略最新的一个任务;</li>
<li>DiscardOldestPolicy：忽略最早的任务，最先加入队列的任务。</li>
<li>new RejectedExecutionHandler 自定义</li>
</ul>
<h4 id="一个线程两次调用start-方法会出现什么情况"><a href="#一个线程两次调用start-方法会出现什么情况" class="headerlink" title="一个线程两次调用start()方法会出现什么情况"></a>一个线程两次调用start()方法会出现什么情况</h4><ul>
<li><p>IllegalThreadStateException</p>
</li>
<li><p>原因：start state状态已变更</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(state != <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线程如何中断"><a href="#线程如何中断" class="headerlink" title="线程如何中断"></a>线程如何中断</h4><ul>
<li><p>线程请求中被请求中止或中断。调用Interrupt()方法，它使中断标志位为true</p>
<p>线程可以通过isInterrupted()方法来判断中断标志是否被设置。</p>
<p>此外，还可以通过Thread类的静态方法interrupted()来判断中断标志是否被设置，并且该方法会清除中断标志。</p>
<p>当一个线程调用了一个阻塞方法时（如sleep()、wait()、join()等），如果该线程的中断标志被设置，那么该方法会立即抛出InterruptedException异常，同时清除中断标志。在抛出InterruptedException异常后，线程就可以选择退出或者继续执行。如果线程继续执行，那么它的中断标志仍然会被设置为true。</p>
</li>
</ul>
<h4 id="线程如何停止"><a href="#线程如何停止" class="headerlink" title="线程如何停止"></a>线程如何停止</h4><ul>
<li><p>使用标识位，在线程中不断检测该标志位，如果标志位被设置，则退出线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopThread</span><span class="params">()</span> &#123;</span><br><span class="line">      stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">          <span class="comment">// 线程逻辑</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线程读写资源，在不使用锁的情况下高效实现"><a href="#线程读写资源，在不使用锁的情况下高效实现" class="headerlink" title="线程读写资源，在不使用锁的情况下高效实现"></a>线程读写资源，在不使用锁的情况下高效实现</h4><ul>
<li><p>线程安全数据结构</p>
<p>如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等。这些数据结构本身就是线程安全的，可以直接用来读写共享资源。</p>
</li>
<li><p>原子类操作 共享资源变量</p>
<p>如<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等，它们都提供了一些原子性的操作方法，可以保证对共享变量的读写是线程安全的，不需要加锁。</p>
</li>
<li><p>线程安全的并发数据结构</p>
<p>如<code>BlockingQueue</code>、<code>ConcurrentLinkedQueue</code>等。这些数据结构提供了一些特殊的操作方法，可以用来实现生产者-消费者模式，可以在不使用锁的情况下实现线程间的协作。</p>
</li>
</ul>
<h4 id="ThreadLocal是什么？在工作中用到过ThreadLocal吗？"><a href="#ThreadLocal是什么？在工作中用到过ThreadLocal吗？" class="headerlink" title="ThreadLocal是什么？在工作中用到过ThreadLocal吗？"></a>ThreadLocal是什么？在工作中用到过ThreadLocal吗？</h4><ul>
<li><p>ThreadLocal是什么</p>
<p>关联线程与对象的关系，使线程拥有自己独立的变量副本，避免多线程安全问题</p>
</li>
<li><p>工作中的使用</p>
<p>用于上下文传递信息，如Token，Session等</p>
</li>
</ul>
<h4 id="ThreadLocal怎么实现的"><a href="#ThreadLocal怎么实现的" class="headerlink" title="ThreadLocal怎么实现的"></a>ThreadLocal怎么实现的</h4><ul>
<li>ThreadLocal基于ThreadLocalMap，每个Thread对应一个ThreadLocalMap对象，用于存储ThreadLocal变量和对应的值</li>
<li>当线程调用ThreadLocal的set方法，实际上就是通过当前线程对象的ThreadLocalMap对象将ThreadLocal对象和对应的值存储到了其中。如果需要访问该值，会通过Thread对象获取对应的ThreadLocalMap，再从ThreadLocalMap获取Value，保证线程安全性</li>
<li>ThreadLocal的key是Weak类型的，理论上会被GC，但如果是多线程环境，可能由于线程池化导致数据不GC，或者Value被强引用导致无法GC，最终导致Memory Leak</li>
</ul>
<h4 id="ThreadLocal-内存泄露是怎么回事"><a href="#ThreadLocal-内存泄露是怎么回事" class="headerlink" title="ThreadLocal 内存泄露是怎么回事"></a>ThreadLocal 内存泄露是怎么回事</h4><ul>
<li>多线程环境下，每个线程有一个自己的ThreadLocalMap实例，而ThreadLocalMap中的Entry对象会持有ThreadLocal的强引用，如果线程池化且对应的ThreadLocal对象未被回收，就会一直存在于内存中，导致Memory Leak</li>
<li>如果使用完ThreadLocal后，没有显示调用remove()方法，即使Key是weak类型，但若Value被外部强引用，也会导致数据一直存在，最终导致OOM</li>
</ul>
<h4 id="ThreadLocalMap的结构了解吗？扩容机制了解吗？"><a href="#ThreadLocalMap的结构了解吗？扩容机制了解吗？" class="headerlink" title="ThreadLocalMap的结构了解吗？扩容机制了解吗？"></a>ThreadLocalMap的结构了解吗？扩容机制了解吗？</h4><ul>
<li><p>结构</p>
<p>基于开放地址法的线性探测哈希表，它的实现中使用了一个Entry数组存储K-V。每个Entry包含2个熟悉，Key和Value，分别表示线程本地变量的键和值。</p>
<p>ThreadLocalMap中的键是ThreadLocal对象，值是ThreadLocal对象关联的值，由于ThreadLocalMap是线程私有的，因此每个线程都会持有一个ThreadLocalMap对象</p>
</li>
<li><p>扩容机制</p>
<p>当ThreadLocalMap中的Entry数量达到阈值，会使用resize()方法对数组进行扩容，扩容时需重新计算每个Entry在数组中的索引位置，如果在新数组中该Entry已被占用，则使用线性探测法查找到下一个位置</p>
</li>
</ul>
<h4 id="ThreadLocal父子线程怎么共享数据？"><a href="#ThreadLocal父子线程怎么共享数据？" class="headerlink" title="ThreadLocal父子线程怎么共享数据？"></a>ThreadLocal父子线程怎么共享数据？</h4><ul>
<li><p>当一个线程启动一个新的子线程时，新线程会继承父线程中的ThreadLocalMap对象，并在该Map对象中创建一个新的Entry对象。在新线程中，可以通过ThreadLocal对象来访问该Map对象中的Entry对象，从而获取到父线程中设置的ThreadLocal变量的值。</p>
<p>具体来说，可以通过以下步骤实现父子线程之间的数据传递：</p>
<ol>
<li>在父线程中创建并设置ThreadLocal变量的值。</li>
<li>在子线程中通过ThreadLocal对象访问父线程中的ThreadLocalMap对象，并获取到父线程中设置的ThreadLocal变量的值。</li>
</ol>
</li>
<li><p>hreadLocal对象的作用域仅限于当前线程中。因此，如果想要在子线程中修改父线程中设置的ThreadLocal变量的值，需要在父线程中将该变量设置为可变对象，并使用同一个可变对象的引用来修改其属性值。这样，在子线程中就可以通过ThreadLocal对象获取到该可变对象，并修改其属性值，从而实现父子线程之间的数据共享。</p>
</li>
</ul>
<h4 id="ThreadLocal有JMM内存屏障问题吗"><a href="#ThreadLocal有JMM内存屏障问题吗" class="headerlink" title="ThreadLocal有JMM内存屏障问题吗"></a>ThreadLocal有JMM内存屏障问题吗</h4><ul>
<li>ThreadLocal中每个线程拥有自己私有变量，不需要同步，因此没有JMM内存平常问题</li>
</ul>
<h4 id="为什么大厂规定不能使用Executors去创建线程池？"><a href="#为什么大厂规定不能使用Executors去创建线程池？" class="headerlink" title="为什么大厂规定不能使用Executors去创建线程池？"></a>为什么大厂规定不能使用Executors去创建线程池？</h4><ul>
<li><p>FixedThreadPool</p>
<p>keepAliveTime为0，无限等待，且LinkedBlockingQueue，可能导致OOM</p>
</li>
<li><p>SingleThreadExecutor</p>
<p>keepAliveTime为0，无限等待，且LinkedBlockingQueue，可能导致OOM</p>
</li>
<li><p>CachedThreadPool</p>
<p>最大线程数为Integer.MAX_VALUE，可能导致OOM</p>
</li>
<li><p>ScheduledThreadPool和SingleThreadScheduledExecutor</p>
<p>keepAliveTime为0，DelayedWorkQueue也是无界队列，因此可能OOM</p>
</li>
</ul>
<h4 id="如何根据实际需要，定制自己的线程池？"><a href="#如何根据实际需要，定制自己的线程池？" class="headerlink" title="如何根据实际需要，定制自己的线程池？"></a>如何根据实际需要，定制自己的线程池？</h4><ul>
<li><p>《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pool大小：线程池太小会进入等待对象，太大会占用过多切换资源</p>
</li>
<li><p>WorkQueue：过小无法进入队列，过大导致内存占用大</p>
</li>
<li><p>Reject：过于严格可能线程无法执行，过于宽松可能导致资源占用大</p>
</li>
<li><p>Thread-Factory：根据需求定制工厂，自定义名称、Policy，守护线程以及异常线程处理</p>
</li>
</ul>
<h4 id="为什么需要-AQS？AQS-的作用和重要性是什么？"><a href="#为什么需要-AQS？AQS-的作用和重要性是什么？" class="headerlink" title="为什么需要 AQS？AQS 的作用和重要性是什么？"></a>为什么需要 AQS？AQS 的作用和重要性是什么？</h4><ul>
<li><p>AQS（AbstractQueuedSynchronizer）是 Java 并发包中一个非常重要的组件，它提供了一种实现同步器的基础框架。在 Java 并发包中，Lock、ReentrantLock、Semaphore、CountDownLatch 等同步工具类都是通过 AQS 实现的。</p>
</li>
<li><p>AQS 的作用和重要性可以总结为以下几点：</p>
<ol>
<li>提供了一种实现同步器的基础框架：AQS 通过提供一些同步器的基本方法，如获取锁、释放锁、阻塞等待等，让开发人员能够更方便地实现各种同步器，如锁、信号量、倒计时门栓等。</li>
<li>支持独占锁和共享锁：AQS 支持独占锁和共享锁两种模式，独占锁模式适用于只有一个线程可以获得锁的情况，如 ReentrantLock，而共享锁模式适用于多个线程可以同时获得锁的情况，如 CountDownLatch。</li>
<li>高效的等待&#x2F;唤醒机制：AQS 内部维护了一个同步队列，通过将等待线程加入到同步队列中，并使用 CAS 操作进行等待线程的唤醒和阻塞，实现了高效的等待&#x2F;唤醒机制。</li>
<li>支持条件变量：AQS 提供了 Condition 类，通过 Condition 可以实现更高级别的线程通信机制，如生产者&#x2F;消费者模式。</li>
</ol>
<p>因此，AQS 的作用和重要性在于提供了一种实现同步器的基础框架，并且支持独占锁和共享锁模式，提供了高效的等待&#x2F;唤醒机制和支持条件变量，是 Java 并发包中实现各种同步器的基础。</p>
</li>
</ul>
<h4 id="多线程的信号量如何"><a href="#多线程的信号量如何" class="headerlink" title="多线程的信号量如何"></a>多线程的信号量如何</h4><p>TODO</p>
<h4 id="AQS和ReentrantLock的关系"><a href="#AQS和ReentrantLock的关系" class="headerlink" title="AQS和ReentrantLock的关系"></a>AQS和ReentrantLock的关系</h4><p>TODO</p>
<h4 id="CAS是一种什么样的同步机制？"><a href="#CAS是一种什么样的同步机制？" class="headerlink" title="CAS是一种什么样的同步机制？"></a>CAS是一种什么样的同步机制？</h4><ul>
<li>Compare And Swap</li>
</ul>
<h4 id="你知道CAS-有什么缺点？"><a href="#你知道CAS-有什么缺点？" class="headerlink" title="你知道CAS 有什么缺点？"></a>你知道CAS 有什么缺点？</h4><ul>
<li>ABA问题</li>
<li>循环时间长开销</li>
<li>只能保证一个变量的原子操作<ul>
<li>多个变量操作时，使用互斥锁保证原子性</li>
<li>将多个变量封装成对象，通过AtomicReference保证原子性</li>
</ul>
</li>
</ul>
<h4 id="你知道线程池实现“线程复用”的原理吗？"><a href="#你知道线程池实现“线程复用”的原理吗？" class="headerlink" title="你知道线程池实现“线程复用”的原理吗？"></a>你知道线程池实现“线程复用”的原理吗？</h4><ul>
<li>启动一部分线程，池化保存到线程池中，当需要处理任务时，取出一个空闲线程执行任务，执行完毕后放回线程池并不销毁</li>
</ul>
<h4 id="阻塞和非阻塞队列的并发安全原理是什么？"><a href="#阻塞和非阻塞队列的并发安全原理是什么？" class="headerlink" title="阻塞和非阻塞队列的并发安全原理是什么？"></a>阻塞和非阻塞队列的并发安全原理是什么？</h4><ul>
<li>都是基于原子操作和同步机制实现的</li>
<li>对于阻塞队列，当队列满时，插入操作会被阻塞，直到队列中有空闲位置；当队列为空时，删除操作会被阻塞，直到队列中有元素。阻塞队列通常使用Condition和ReentrantLock来实现，其中Condition是对应于ReentrantLock的等待&#x2F;通知机制，通过await()方法等待信号并释放锁，signal()方法唤醒等待的线程。</li>
<li>对于非阻塞队列，插入操作和删除操作都是非阻塞的，当队列满或者为空时，插入操作和删除操作都会返回失败或者null。因此，非阻塞队列通常采用并发原子操作CAS和volatile变量来实现。</li>
<li>需要注意的是，阻塞队列和非阻塞队列都需要保证并发安全，否则会导致线程安全问题。对于阻塞队列，由于涉及到等待&#x2F;通知机制，因此实现比较复杂；对于非阻塞队列，由于涉及到并发原子操作，因此实现比较高效。</li>
</ul>
<h4 id="你对“公平锁”了解吗？为什么会有“非公平锁”？"><a href="#你对“公平锁”了解吗？为什么会有“非公平锁”？" class="headerlink" title="你对“公平锁”了解吗？为什么会有“非公平锁”？"></a>你对“公平锁”了解吗？为什么会有“非公平锁”？</h4><ul>
<li><p>公平锁</p>
<p>FIFO</p>
</li>
<li><p>原因</p>
<p>业务需求和性能考虑，一些要求需要FIFO场景。但是维护FIFO队列需要性能，如notify()唤醒下一个线程。如果不需要FIFO场景，使用非公锁可以更好抢占资源，提高性能</p>
</li>
</ul>
<h4 id="你对“自旋锁”了解吗？优缺点分别是什么？"><a href="#你对“自旋锁”了解吗？优缺点分别是什么？" class="headerlink" title="你对“自旋锁”了解吗？优缺点分别是什么？"></a>你对“自旋锁”了解吗？优缺点分别是什么？</h4><ul>
<li><p>基于忙等待的锁，利用CAS实现原子操作，不需要加锁和解锁动作，调度延迟低，减少线程切换开销</p>
<p>自旋锁在第一层未获取资源情况下，会开始自旋，直到被释放或自旋一定次数后，才会升级轻量锁或重锁。轻量锁也是基于CAS，通过Object Head上设置标志位和指针实现。重锁使用系统提供的mutex或者spinlock实现</p>
</li>
<li><p>优点</p>
<p>不需要加锁没锁操作，减少锁开销，减少线程切换和调度延迟</p>
</li>
<li><p>缺点</p>
<p>一直自旋会导致CPU资源被消耗</p>
</li>
</ul>
<h4 id="CPU-核心数和线程数的关系？"><a href="#CPU-核心数和线程数的关系？" class="headerlink" title="CPU 核心数和线程数的关系？"></a>CPU 核心数和线程数的关系？</h4><ul>
<li>单核处理器：单核处理器只有一个物理处理单元，只能同时执行一个线程，因此线程数为1。</li>
<li>多核处理器：多核处理器有多个物理处理单元，每个物理处理单元可以同时执行一个线程，因此线程数等于核心数。</li>
</ul>
<h4 id="多线程环境中遇到的常见的问题是什么？怎么解决？"><a href="#多线程环境中遇到的常见的问题是什么？怎么解决？" class="headerlink" title="多线程环境中遇到的常见的问题是什么？怎么解决？"></a>多线程环境中遇到的常见的问题是什么？怎么解决？</h4><ul>
<li>线程安全问题：锁、Atomic类、Concurrent容器</li>
<li>死锁：避免嵌套，按照顺序执行，使用超时机制</li>
<li>性能问题：控制线程新增销毁次数，减少锁竞争，使用非阻塞算法等</li>
<li>内存泄漏问题：如ThreadLocal，显示调用remove()方法</li>
<li>可见性问题：指令重排序和缓存一致性的原因，导致普通变量被修改无法被其他线程看到。使用volatile或synchronized等</li>
<li>阻塞问题：使用非阻塞IO，使用异步模型</li>
</ul>
<h4 id="在Java中绿色线程和本地线程区别"><a href="#在Java中绿色线程和本地线程区别" class="headerlink" title="在Java中绿色线程和本地线程区别"></a>在Java中绿色线程和本地线程区别</h4><ul>
<li>绿色线程为早期无法映射到OS线程而在JVM上建立的用户态线程，需要JVM进行调度</li>
<li>已被取代，目前完全是内核态线程</li>
</ul>
<h4 id="死锁与活锁的区别，死锁与饥饿的区别"><a href="#死锁与活锁的区别，死锁与饥饿的区别" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别"></a>死锁与活锁的区别，死锁与饥饿的区别</h4><ul>
<li>死锁：两个线程互相持有对方需要的资源，一直等待</li>
<li>活锁：没有被阻塞，但因缺少必要条件，一直无限重试，线程状态会一直变更</li>
<li>饥饿锁：高优先级线程一直抢占资源，低优先级线程无法获取资源而饥饿。当高优先级线程结束后可以恢复</li>
</ul>
<h4 id="Java中用到的线程调度算法是什么"><a href="#Java中用到的线程调度算法是什么" class="headerlink" title="Java中用到的线程调度算法是什么"></a>Java中用到的线程调度算法是什么</h4><ul>
<li>分时调度</li>
<li>抢占式调度（Java默认）</li>
</ul>
<h4 id="在线程中怎么处理不可捕捉异常"><a href="#在线程中怎么处理不可捕捉异常" class="headerlink" title="在线程中怎么处理不可捕捉异常"></a>在线程中怎么处理不可捕捉异常</h4><ul>
<li>实现Thread.UncaughtExceptionHandler自定义异常处理器捕获s</li>
</ul>
<h4 id="什么是线程组，为什么在Java中不推荐使用"><a href="#什么是线程组，为什么在Java中不推荐使用" class="headerlink" title="什么是线程组，为什么在Java中不推荐使用"></a>什么是线程组，为什么在Java中不推荐使用</h4><ul>
<li>线程不安全</li>
<li>resume、suspend等方法会导致DeadLock问题，已被官方废弃</li>
</ul>
<h4 id="为什么使用Executor框架比使用应用创建和管理线程好"><a href="#为什么使用Executor框架比使用应用创建和管理线程好" class="headerlink" title="为什么使用Executor框架比使用应用创建和管理线程好"></a>为什么使用Executor框架比使用应用创建和管理线程好</h4><ul>
<li>控制线程总数，控制并发数量</li>
<li>复用线程</li>
</ul>
<h4 id="在Java中Executor和Executors的区别"><a href="#在Java中Executor和Executors的区别" class="headerlink" title="在Java中Executor和Executors的区别"></a>在Java中Executor和Executors的区别</h4><ul>
<li>Executor有子类ExecutorService，可自定义线程池，子类支持Runnable和Callable方法</li>
<li>Executors为官方线程池</li>
</ul>
<h4 id="方法中的参数在内存中的传递过程，详细的"><a href="#方法中的参数在内存中的传递过程，详细的" class="headerlink" title="方法中的参数在内存中的传递过程，详细的"></a>方法中的参数在内存中的传递过程，详细的</h4><p>TODO</p>
<h4 id="从excel表中批量-（10w-）-导入数据。解决方案"><a href="#从excel表中批量-（10w-）-导入数据。解决方案" class="headerlink" title="从excel表中批量 （10w+） 导入数据。解决方案"></a>从excel表中批量 （10w+） 导入数据。解决方案</h4><p>TODO</p>
<h4 id="如何在Windows和Linux上查找哪个线程使用的CPU时间最长"><a href="#如何在Windows和Linux上查找哪个线程使用的CPU时间最长" class="headerlink" title="如何在Windows和Linux上查找哪个线程使用的CPU时间最长"></a>如何在Windows和Linux上查找哪个线程使用的CPU时间最长</h4><ul>
<li>Jstack查询CPU使用最多的PID编号</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h4 id="如何用10行代码实现一个负载均衡服务"><a href="#如何用10行代码实现一个负载均衡服务" class="headerlink" title="如何用10行代码实现一个负载均衡服务"></a>如何用10行代码实现一个负载均衡服务</h4><ul>
<li>Servlet 代码中调用响应重定向方法</li>
</ul>
<h4 id="百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字"><a href="#百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字" class="headerlink" title="百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字"></a>百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字</h4><ul>
<li>Hash笔记，求出每个小文件中重复次数最多的，再整合后统计</li>
<li>BitMap记录</li>
</ul>
<h4 id="JAVA-LIST查询过大容易OOM解决方案"><a href="#JAVA-LIST查询过大容易OOM解决方案" class="headerlink" title="JAVA LIST查询过大容易OOM解决方案"></a>JAVA LIST查询过大容易OOM解决方案</h4><ul>
<li>分页，分Batch处理</li>
<li>调整Heap大小参数</li>
</ul>
<h4 id="用Java编程一个会导致死锁的程序，怎么解决"><a href="#用Java编程一个会导致死锁的程序，怎么解决" class="headerlink" title="用Java编程一个会导致死锁的程序，怎么解决"></a>用Java编程一个会导致死锁的程序，怎么解决</h4><ul>
<li>避免锁嵌套</li>
<li>避免长时间持有锁，使用<code>wait()</code>和<code>notify()</code>等方法进行线程之间的协调。</li>
<li>设置超时时间</li>
</ul>
<h3 id="File-IO相关"><a href="#File-IO相关" class="headerlink" title="File IO相关"></a>File IO相关</h3><h4 id="Java几种Copy方式，哪种效率最高"><a href="#Java几种Copy方式，哪种效率最高" class="headerlink" title="Java几种Copy方式，哪种效率最高"></a>Java几种Copy方式，哪种效率最高</h4><ul>
<li><p>Copy方式</p>
<ul>
<li>字节流 FileInputStream&#x2F;FileOutputStream</li>
<li>字符流 FileReader &#x2F; FileWriter</li>
<li>缓冲流 BufferedInputStream &#x2F; BufferedOutputStream</li>
<li>NIO流 FileInputStream &#x2F; FileOutputStream -&gt;getChannel</li>
</ul>
</li>
<li><p>效率最高</p>
<p>NIO 流</p>
</li>
</ul>
<h2 id="JMM-相关"><a href="#JMM-相关" class="headerlink" title="JMM 相关"></a>JMM 相关</h2><p><a href="https://swzxsyh.github.io/2022/06/30/JAVA-JMM/">JAVA-JMM相关内容</a></p>
<h4 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h4><p>TODO</p>
<h4 id="volatile模型"><a href="#volatile模型" class="headerlink" title="volatile模型"></a>volatile模型</h4><p>TODO</p>
<h4 id="刷写数据synchronized和volatile异同"><a href="#刷写数据synchronized和volatile异同" class="headerlink" title="刷写数据synchronized和volatile异同"></a>刷写数据synchronized和volatile异同</h4><p>TODO</p>
<h4 id="什么是“内存可见性”问题"><a href="#什么是“内存可见性”问题" class="headerlink" title="什么是“内存可见性”问题"></a>什么是“内存可见性”问题</h4><p>TODO</p>
<h4 id="你知道主内存和工作内存的关系？"><a href="#你知道主内存和工作内存的关系？" class="headerlink" title="你知道主内存和工作内存的关系？"></a>你知道主内存和工作内存的关系？</h4><p>TODO</p>
<h4 id="你知道什么是-happens-before-原则吗？"><a href="#你知道什么是-happens-before-原则吗？" class="headerlink" title="你知道什么是 happens-before 原则吗？"></a>你知道什么是 happens-before 原则吗？</h4><p>TODO</p>
<h4 id="JAVA创建对象时是否存在窗口期"><a href="#JAVA创建对象时是否存在窗口期" class="headerlink" title="JAVA创建对象时是否存在窗口期"></a>JAVA创建对象时是否存在窗口期</h4><ul>
<li>Memory Order</li>
</ul>
<h4 id="共享内存在-JAVA中是怎么体现的"><a href="#共享内存在-JAVA中是怎么体现的" class="headerlink" title="共享内存在 JAVA中是怎么体现的"></a>共享内存在 JAVA中是怎么体现的</h4><p>TODO</p>
<h4 id="Java里面的内存模型和操作系统里面的内存模型有什么区别"><a href="#Java里面的内存模型和操作系统里面的内存模型有什么区别" class="headerlink" title="Java里面的内存模型和操作系统里面的内存模型有什么区别"></a>Java里面的内存模型和操作系统里面的内存模型有什么区别</h4><p>TODO</p>
<h2 id="JVM-相关"><a href="#JVM-相关" class="headerlink" title="JVM 相关"></a>JVM 相关</h2><h4 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h4><p>TODO</p>
<h4 id="JVM内存分配的过程"><a href="#JVM内存分配的过程" class="headerlink" title="JVM内存分配的过程"></a>JVM内存分配的过程</h4><p>TODO</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>TODO</p>
<h4 id="Java运行时区域中哪些是线程共享的哪些是线程私有的"><a href="#Java运行时区域中哪些是线程共享的哪些是线程私有的" class="headerlink" title="Java运行时区域中哪些是线程共享的哪些是线程私有的"></a>Java运行时区域中哪些是线程共享的哪些是线程私有的</h4><p>TODO</p>
<h4 id="程序计数器作用"><a href="#程序计数器作用" class="headerlink" title="程序计数器作用"></a>程序计数器作用</h4><p>TODO</p>
<h4 id="虚拟机栈里面是什么"><a href="#虚拟机栈里面是什么" class="headerlink" title="虚拟机栈里面是什么"></a>虚拟机栈里面是什么</h4><p>TODO</p>
<h4 id="方法区存储什么内容"><a href="#方法区存储什么内容" class="headerlink" title="方法区存储什么内容"></a>方法区存储什么内容</h4><p>TODO</p>
<h4 id="Java栈什么时侯会发生内存溢出"><a href="#Java栈什么时侯会发生内存溢出" class="headerlink" title="Java栈什么时侯会发生内存溢出"></a>Java栈什么时侯会发生内存溢出</h4><p>TODO</p>
<h4 id="内存碎片怎么优化"><a href="#内存碎片怎么优化" class="headerlink" title="内存碎片怎么优化"></a>内存碎片怎么优化</h4><p>TODO</p>
<h4 id="JVM-GCRoots对象"><a href="#JVM-GCRoots对象" class="headerlink" title="JVM GCRoots对象"></a>JVM GCRoots对象</h4><ul>
<li>虚拟机栈（栈帧的本地变量表）引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
<li>方法区中类静态属性引用对象</li>
<li>方法区中常量引用对象</li>
<li>被synchronized锁持有的对象</li>
<li>基本数据类型对应的Class对象、常驻对象、类加载器</li>
<li>反映JVM内部情况的JMXBean等</li>
</ul>
<h4 id="什么是不可达"><a href="#什么是不可达" class="headerlink" title="什么是不可达"></a>什么是不可达</h4><ul>
<li><p>通过一系列GC Root对象作为起点向下搜索，搜索时走过的路径称为引用链 (Refrence Chain)，当一个对象到GC Root没有任何引用链相连时，则认为该对象不可达，会被GC回收</p>
<p><img src="/2023/02/12/Collection-InterviewQuestion/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" alt="可达性算法"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">JVM垃圾收集器与内存分配策略 | 一蓑烟雨任平生 (sunliaodong.cn)</a></p>
</li>
</ul>
<h4 id="A、B对象可回收，一定就会被回收吗"><a href="#A、B对象可回收，一定就会被回收吗" class="headerlink" title="A、B对象可回收，一定就会被回收吗"></a>A、B对象可回收，一定就会被回收吗</h4><ul>
<li><p>不一定，要看是否执行过finalize()方法，没执行但有必要执行的对象放入F-Queue，虚拟机建立一个优先级低的Finalizer线程对F-Queue中的对象进行finalize()方法，之后F-Queued对其二次标记，如果没能逃脱则回收</p>
</li>
<li><p><img src="/2023/02/12/Collection-InterviewQuestion/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png" alt="对象已死"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">JVM垃圾收集器与内存分配策略 | 一蓑烟雨任平生 (sunliaodong.cn)</a></p>
</li>
</ul>
<h4 id="为什么要分Young-Gen-and-Old-Gen"><a href="#为什么要分Young-Gen-and-Old-Gen" class="headerlink" title="为什么要分Young Gen and Old Gen"></a>为什么要分Young Gen and Old Gen</h4><ul>
<li>提升回收效率</li>
<li>Heap Space 分为<code>Old Gen</code>和<code>Young Gen</code>，新生代又包含<code>Eden Gen</code>和<code>Survivor Gen</code></li>
<li>新对象正常情况下很快会被回收，因此GC可以主要集中在Young Gen</li>
<li>Eden Space 是创建新对象的空间，如果触发GC，存活的会进入Survivor Space</li>
<li>Suivivor Space空间的对象在一定次数还未被回收后，会进入Old Gen</li>
<li>Old Gen通常比Young Gen大，因为要存放长期生命周期的对象</li>
<li>Old Gen 和 Young Gen比例大概是70%和30%，其中Survivor Space占用 10%-20%，剩下的分配给Eden Space。但需具体问题具体分析</li>
</ul>
<h4 id="为什么用元空间替换永久代"><a href="#为什么用元空间替换永久代" class="headerlink" title="为什么用元空间替换永久代"></a>为什么用元空间替换永久代</h4><ul>
<li>PermGen在堆内，大小不可变，可能出现OOM</li>
<li>MetaSpace在JVM中，大小可自由变化</li>
</ul>
<h4 id="GC会清除方法区数据吗"><a href="#GC会清除方法区数据吗" class="headerlink" title="GC会清除方法区数据吗"></a>GC会清除方法区数据吗</h4><ul>
<li><p>Java7 中，PermGen存放于方法区，是堆空间的一部分，GC会清除。</p>
</li>
<li><p>Java8后</p>
<ul>
<li><p>划分到元空间，是独立于堆的空间，用于存储类元数据、驻留字符串和其他非堆 JVM 数据。</p>
</li>
<li><p>一般来说，它有自己的回收方式，不由Heap GC直接管控。</p>
<p>某些情况下，GC可能间接释放方法区中的空间，如：不再需要某个类，GC可能会回收类实例及其相关元数据的使用内存，从而释放方法区中的空间。</p>
</li>
<li><p>元空间不受固定大学限制，JVM会根据元数据量自动调整大小</p>
</li>
</ul>
</li>
</ul>
<h4 id="最大堆内存和最小堆内存如何配置"><a href="#最大堆内存和最小堆内存如何配置" class="headerlink" title="最大堆内存和最小堆内存如何配置"></a>最大堆内存和最小堆内存如何配置</h4><p>TODO</p>
<h4 id="一个固定的堆内存，当线程数创建很多时，JVM参数如何设置"><a href="#一个固定的堆内存，当线程数创建很多时，JVM参数如何设置" class="headerlink" title="一个固定的堆内存，当线程数创建很多时，JVM参数如何设置"></a>一个固定的堆内存，当线程数创建很多时，JVM参数如何设置</h4><p>TODO</p>
<h4 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h4><p>TODO</p>
<h4 id="Class文件包括哪些"><a href="#Class文件包括哪些" class="headerlink" title="Class文件包括哪些"></a>Class文件包括哪些</h4><p>TODO</p>
<h3 id="ClassLoader相关"><a href="#ClassLoader相关" class="headerlink" title="ClassLoader相关"></a>ClassLoader相关</h3><h4 id="简单说说你了解的类加载器，可以打破双亲委派么？"><a href="#简单说说你了解的类加载器，可以打破双亲委派么？" class="headerlink" title="简单说说你了解的类加载器，可以打破双亲委派么？"></a>简单说说你了解的类加载器，可以打破双亲委派么？</h4><ul>
<li><p>负责在运行时将 Java 类加载到内存中。 Java ClassLoader遵循Parent Delegation Model，即它首先将类加载请求委托给它的父类加载器，如果父类加载器找不到该类，则尝试从自己的资源中加载该类。</p>
<ul>
<li><p>Bootstrap ClassLoader - 从 <JAVA_HOME>&#x2F;lib 目录或 JDK9 及更高版本中的 jrt:&#x2F;&#x2F; 文件系统加载核心 Java 类。</JAVA_HOME></p>
</li>
<li><p>Extension ClassLoader - 从扩展目录（通常是 <JAVA_HOME>&#x2F;lib&#x2F;ext）加载类。</JAVA_HOME></p>
</li>
<li><p>System&#x2F;Application ClassLoader - 从应用程序类路径加载类，这可以通过 -classpath 或 -cp 选项或 CLASSPATH 环境变量进行设置。</p>
<p>每个ClassLoader都有一个parent ClassLoader，除了Bootstrap ClassLoader，它是root ClassLoader。 Parent Delegation Model 确保同一个类不会被不同的 ClassLoader 多次加载，这可能会导致 ClassCastExceptions 和其他运行时错误。</p>
</li>
</ul>
</li>
<li><p>可以，类似Tomcat，为了实现多个内部容器，必须打破双亲委派，可以提升控制颗粒度和灵活度。</p>
</li>
</ul>
<h4 id="双亲委派最终是由父类加载还是子类加载"><a href="#双亲委派最终是由父类加载还是子类加载" class="headerlink" title="双亲委派最终是由父类加载还是子类加载"></a>双亲委派最终是由父类加载还是子类加载</h4><p>TODO</p>
<p>如果打破双亲委派机制，加载了不同系统同名类会有什么问题</p>
<ul>
<li>如果双亲委派机制被破坏，并且加载了来自不同系统的同名类，则可能导致 ClassLoader 冲突和运行时的意外行为。</li>
</ul>
<h4 id="父类加载器和子类加载器在代码上是什么关系"><a href="#父类加载器和子类加载器在代码上是什么关系" class="headerlink" title="父类加载器和子类加载器在代码上是什么关系"></a>父类加载器和子类加载器在代码上是什么关系</h4><p>TODO</p>
<h4 id="如果我想自己控制类加载的时机怎么办"><a href="#如果我想自己控制类加载的时机怎么办" class="headerlink" title="如果我想自己控制类加载的时机怎么办"></a>如果我想自己控制类加载的时机怎么办</h4><p>TODO</p>
<h4 id="如果创建一个java-lang-String类，这个类是否可以被类加载器加载"><a href="#如果创建一个java-lang-String类，这个类是否可以被类加载器加载" class="headerlink" title="如果创建一个java.lang.String类，这个类是否可以被类加载器加载"></a>如果创建一个java.lang.String类，这个类是否可以被类加载器加载</h4><ul>
<li>默认不行，bootstrap默认JVM加载java.*的类（双亲委派机制保护）</li>
<li>可以通过修改父类findClass方法加载，不建议</li>
</ul>
<h4 id="JVM是如何处理异常的"><a href="#JVM是如何处理异常的" class="headerlink" title="JVM是如何处理异常的"></a>JVM是如何处理异常的</h4><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给JVM。该异常对象包含：异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并交给JVM的过程叫做抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM会顺着调用栈去查找是否有可以处理异常的代码，如果有，则调用异常处理代码。如果没有找到，JVM就会将该异常转交给默认的异常处理器（默认处理器是JVM的一部分）默认异常处理器会打印出异常信息并终止程序运行。</p>
<h4 id="finnal、finnally、finalize的区别"><a href="#finnal、finnally、finalize的区别" class="headerlink" title="finnal、finnally、finalize的区别"></a>finnal、finnally、finalize的区别</h4><p>finnal可以修饰类、变量、方法；修饰类，则该类不能被继承；修饰变量，则表示该变量是一个常量，不能被重新赋值；修饰方法，表示该方法不能被重写</p>
<p>finnally一般作用在try-catch代码中，在异常处理的时候，通常代码一定要执行的方法写在finnaly代码块中，通常写在finnally中的代码一定会被执行。一般写关闭资源的代码语句</p>
<p>finalize是一个方法，属于Object类，Object类是所有类的父类，java中允许使用finalize()方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</strong></p>
<h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><h4 id="JDK8-的默认垃圾回收器"><a href="#JDK8-的默认垃圾回收器" class="headerlink" title="JDK8 的默认垃圾回收器"></a>JDK8 的默认垃圾回收器</h4><ul>
<li>Parallel Scavenge(新生代)+ Serial Old(老年代)</li>
</ul>
<p>  CMS需要手动设置</p>
<h4 id="对象是否可-GC"><a href="#对象是否可-GC" class="headerlink" title="对象是否可 GC"></a>对象是否可 GC</h4><ul>
<li>GC Root可达性算法</li>
</ul>
<h4 id="GC什么时候启动"><a href="#GC什么时候启动" class="headerlink" title="GC什么时候启动"></a>GC什么时候启动</h4><ul>
<li>Minor GC在Young Gen中Survivor 区域满时启动</li>
<li>Full GC在 Old Gen 空间满时启动</li>
</ul>
<h4 id="Mutator"><a href="#Mutator" class="headerlink" title="Mutator"></a>Mutator</h4><ul>
<li><p>Mutator是 JVM 的一部分，但不是垃圾收集器的一部分，它负责为对象分配以及更新对象与 GC Roots 的关系。</p>
</li>
<li><p>Mutator记录关系是为了确保它不会改变不应该改变的对象。</p>
<p>例如，如果 Mutator 正在改变对象中的字段，它需要确保它不会同时改变与第一个对象相关的任何其他对象中的字段。如果这样做，可能会导致意想不到的结果。</p>
</li>
<li><p>FullGC 或者 MinorGC发生时，Mutator 会暂停执行</p>
</li>
<li><p>GC自己计算对象与GC Roots的关系并清楚，不使用Mutator记录的数据</p>
</li>
<li><p>Mutator不是必须的，如果对象关系不变更，就不需要使用Mutator</p>
</li>
</ul>
<h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><p><a href="https://swzxsyh.github.io/2022/07/04/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">JVM-垃圾回收算法</a></p>
<ul>
<li><p>引用计数</p>
</li>
<li><p>标记清除</p>
</li>
<li><p>复制收集</p>
</li>
<li><p>标记整理</p>
</li>
<li><p>分代收集</p>
<p>都是各种组合</p>
</li>
</ul>
<h4 id="垃圾收集器有哪几种"><a href="#垃圾收集器有哪几种" class="headerlink" title="垃圾收集器有哪几种"></a>垃圾收集器有哪几种</h4><p><a href="https://swzxsyh.github.io/2022/07/02/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM-垃圾收集器</a></p>
<ul>
<li>Serial<ul>
<li>Serial</li>
<li>Serial Old</li>
</ul>
</li>
<li>Parallel<ul>
<li>ParNew</li>
<li>Parallel Scavenge（CMS）</li>
<li>Parallel Old（CMS）</li>
</ul>
</li>
<li>Concurrent<ul>
<li>CMS</li>
<li>G1</li>
</ul>
</li>
</ul>
<h4 id="标记复制和标记整理算法的对比"><a href="#标记复制和标记整理算法的对比" class="headerlink" title="标记复制和标记整理算法的对比"></a>标记复制和标记整理算法的对比</h4><ul>
<li><p>标记复制</p>
<p>区分3个区域，Eden，S0，S1，建议比例8:1:1</p>
<p>一般用于Young Gen，新对象进入Eden，触发Minor GC，第一次随机进入S0或S1，后续存活对象从Eden进入Survivor区，且S0-S1存活对象相互复制，15次未被GC则进入Old Gen</p>
</li>
<li><p>标记整理</p>
<p>清除垃圾并将数据整理，减少碎片，但会有较长耗时</p>
</li>
</ul>
<h4 id="CMS是什么，简述工作流程"><a href="#CMS是什么，简述工作流程" class="headerlink" title="CMS是什么，简述工作流程"></a>CMS是什么，简述工作流程</h4><ul>
<li><p>CMS是什么</p>
<p>垃圾收集器</p>
</li>
<li><p>简述工作流程</p>
<p>初始标记</p>
<p>并发标记</p>
<p>重新标记</p>
<p>标记清除</p>
</li>
</ul>
<h4 id="CMS新生代老年代算法"><a href="#CMS新生代老年代算法" class="headerlink" title="CMS新生代老年代算法"></a>CMS新生代老年代算法</h4><ul>
<li>Young Gen：Copy</li>
<li>Old Gen：Mark-Sweep</li>
</ul>
<h4 id="为什么要分代回收，分代回收背后的思想"><a href="#为什么要分代回收，分代回收背后的思想" class="headerlink" title="为什么要分代回收，分代回收背后的思想"></a>为什么要分代回收，分代回收背后的思想</h4><ul>
<li><p>为什么要分代回收</p>
<p>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>
<p>强分代假说（Stong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以死亡。</p>
<p>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
</li>
<li><p>分代回收背后的思想</p>
<p>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点来使用不同的回收算法，以提高垃圾回收的效率。</p>
</li>
</ul>
<h4 id="CMS缺陷"><a href="#CMS缺陷" class="headerlink" title="CMS缺陷"></a>CMS缺陷</h4><ul>
<li><p>CPU占用高</p>
</li>
<li><p>Old Gen使用mark-sweep会产生碎片，可用参数解决但会增加GC时间</p>
<p>-XX:+CMSIncrementalPacing 使 CMS GC 以较小的增量收集垃圾</p>
<p>-XX:+CMSFullGCsBeforeCompaction 强制 CMS Full GC多少次数后压缩</p>
</li>
</ul>
<h4 id="CMS回收为什么要停顿两次"><a href="#CMS回收为什么要停顿两次" class="headerlink" title="CMS回收为什么要停顿两次"></a>CMS回收为什么要停顿两次</h4><ul>
<li>初始标记，将所有GC Root连接对象标记，STW</li>
<li>并发标记，与用户线程同时，深度遍历，不暂停</li>
<li>重新标记，避免用户操作过程中变更对象引用关系，需要STW</li>
<li>并发清除</li>
</ul>
<h4 id="Young-GC-的时候，主要操作哪些区块，Eden到S0-还是-S1区的过程是随机还是确定的"><a href="#Young-GC-的时候，主要操作哪些区块，Eden到S0-还是-S1区的过程是随机还是确定的" class="headerlink" title="Young GC 的时候，主要操作哪些区块，Eden到S0 还是 S1区的过程是随机还是确定的"></a>Young GC 的时候，主要操作哪些区块，Eden到S0 还是 S1区的过程是随机还是确定的</h4><ul>
<li>Eden和survivor</li>
<li>第一次随机，后续确定，15次未收集的对象进入Old Gen</li>
</ul>
<h4 id="为什么配置了CMS-GC仍然会触发Full-GC"><a href="#为什么配置了CMS-GC仍然会触发Full-GC" class="headerlink" title="为什么配置了CMS GC仍然会触发Full GC"></a>为什么配置了CMS GC仍然会触发Full GC</h4><ul>
<li>大对象Old Gen和Old Gen都放不下</li>
<li>Old Gen 碎片过多</li>
<li>GC失败</li>
<li>人为执行</li>
</ul>
<h4 id="G1的特性"><a href="#G1的特性" class="headerlink" title="G1的特性"></a>G1的特性</h4><p>TODO</p>
<h4 id="G1的region被回收之后怎么解决内存碎片的"><a href="#G1的region被回收之后怎么解决内存碎片的" class="headerlink" title="G1的region被回收之后怎么解决内存碎片的"></a>G1的region被回收之后怎么解决内存碎片的</h4><p>TODO</p>
<h4 id="G1-GC-写屏障原理"><a href="#G1-GC-写屏障原理" class="headerlink" title="G1 GC 写屏障原理"></a>G1 GC 写屏障原理</h4><p>TODO</p>
<h4 id="G1-GC的Card-Table、Remembered-Set和存活对转移对象原理"><a href="#G1-GC的Card-Table、Remembered-Set和存活对转移对象原理" class="headerlink" title="G1 GC的Card Table、Remembered Set和存活对转移对象原理"></a>G1 GC的Card Table、Remembered Set和存活对转移对象原理</h4><p>TODO</p>
<h4 id="G1垃圾回收器年轻代、老年代回收原理"><a href="#G1垃圾回收器年轻代、老年代回收原理" class="headerlink" title="G1垃圾回收器年轻代、老年代回收原理"></a>G1垃圾回收器年轻代、老年代回收原理</h4><p>TODO</p>
<h4 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h4><p>TODO</p>
<p>-xms，-xmx</p>
<h4 id="内存泄漏和内存溢出区别"><a href="#内存泄漏和内存溢出区别" class="headerlink" title="内存泄漏和内存溢出区别"></a>内存泄漏和内存溢出区别</h4><ul>
<li>内存泄漏是生成的对象不被显示引用后，仍无法回收，Memory Leak</li>
<li>内存溢出是生成对象过多，JVM无法拥有更多空间，导致OOM</li>
</ul>
<h4 id="频繁Young-GC原因"><a href="#频繁Young-GC原因" class="headerlink" title="频繁Young GC原因"></a>频繁Young GC原因</h4><ul>
<li>Survivor Space过小</li>
<li>新对象创建太快，没有有效重用对象</li>
</ul>
<h4 id="如果出程序出现内存溢出，如何排查解决"><a href="#如果出程序出现内存溢出，如何排查解决" class="headerlink" title="如果出程序出现内存溢出，如何排查解决"></a>如果出程序出现内存溢出，如何排查解决</h4><ul>
<li><p>Heap内存使用过多，通过<code>-Xmx</code> 和 <code>-Xms</code>参数控制最大最小堆最小堆</p>
</li>
<li><p>大量创建对象</p>
<p>查看是否有业务大量创建对象，如果出现大量创建和销毁，可能导致GC无法及时回收，内存溢出。尽量复用对象</p>
</li>
<li><p>集合类使用问题</p>
<p>程序中使用大量集合，且存储对象很大，都被引用或未及时回收会造成OOM。</p>
<p>优化队列大小，优化 ArrayList 替换 LinkedList、HashMap 替换 TreeMap 。</p>
</li>
<li><p>递归调用层过多</p>
<p>递归调用层数过多也可能导致内存溢出</p>
</li>
</ul>
<h2 id="Maven相关"><a href="#Maven相关" class="headerlink" title="Maven相关"></a>Maven相关</h2><h4 id="Maven中dependencyManagement作用"><a href="#Maven中dependencyManagement作用" class="headerlink" title="Maven中dependencyManagement作用"></a>Maven中dependencyManagement作用</h4><ul>
<li>负责子模块使用时的引入</li>
</ul>
<h4 id="A模块依赖B模块1-0版本，C模块依赖B模块1-1版本，现在A模块依赖C模块，问依赖B模块多少版本？"><a href="#A模块依赖B模块1-0版本，C模块依赖B模块1-1版本，现在A模块依赖C模块，问依赖B模块多少版本？" class="headerlink" title="A模块依赖B模块1.0版本，C模块依赖B模块1.1版本，现在A模块依赖C模块，问依赖B模块多少版本？"></a>A模块依赖B模块1.0版本，C模块依赖B模块1.1版本，现在A模块依赖C模块，问依赖B模块多少版本？</h4><ul>
<li>根据Maven依赖顺序决定，就近原则</li>
</ul>
<h2 id="Spring-相关"><a href="#Spring-相关" class="headerlink" title="Spring 相关"></a>Spring 相关</h2><h4 id="RestController与Controller区别"><a href="#RestController与Controller区别" class="headerlink" title="RestController与Controller区别"></a>RestController与Controller区别</h4><ul>
<li>@RestController &#x3D; @ResponseBody ＋ @Controller，无法返回指定页面</li>
<li>@Controller可以返回指定页面，如果需要返回数据需要+ @ResponseBody辅助</li>
</ul>
<h4 id="RequestBody与ResponseBody区别"><a href="#RequestBody与ResponseBody区别" class="headerlink" title="RequestBody与ResponseBody区别"></a>RequestBody与ResponseBody区别</h4><ul>
<li>RequestBody 入参</li>
<li>ResponseBody 出参，将数据转化为JSON等格式返回</li>
</ul>
<h4 id="Spring底层实现"><a href="#Spring底层实现" class="headerlink" title="Spring底层实现"></a>Spring底层实现</h4><p>TODO</p>
<h4 id="Spring事务底层实现"><a href="#Spring事务底层实现" class="headerlink" title="Spring事务底层实现"></a>Spring事务底层实现</h4><p>TODO</p>
<h4 id="IOC理解"><a href="#IOC理解" class="headerlink" title="IOC理解"></a>IOC理解</h4><p>TODO</p>
<h4 id="IOC主要容器"><a href="#IOC主要容器" class="headerlink" title="IOC主要容器"></a>IOC主要容器</h4><p>TODO</p>
<h4 id="Spring生命周期"><a href="#Spring生命周期" class="headerlink" title="Spring生命周期"></a>Spring生命周期</h4><p>TODO</p>
<h4 id="Spring-Bean加载初始化过程"><a href="#Spring-Bean加载初始化过程" class="headerlink" title="Spring Bean加载初始化过程"></a>Spring Bean加载初始化过程</h4><p>TODO</p>
<h4 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h4><p>TODO</p>
<h4 id="注解底层实现流程"><a href="#注解底层实现流程" class="headerlink" title="注解底层实现流程"></a>注解底层实现流程</h4><p>TODO</p>
<h4 id="BeanFactory与FactoryBean的区别"><a href="#BeanFactory与FactoryBean的区别" class="headerlink" title="BeanFactory与FactoryBean的区别"></a>BeanFactory与FactoryBean的区别</h4><p>TODO</p>
<h4 id="Beanfactory和ApplicationContext是什么关系，使用有什么区别"><a href="#Beanfactory和ApplicationContext是什么关系，使用有什么区别" class="headerlink" title="Beanfactory和ApplicationContext是什么关系，使用有什么区别"></a>Beanfactory和ApplicationContext是什么关系，使用有什么区别</h4><p>TODO</p>
<h4 id="Spring-中如何让A和B两个bean按顺序加载"><a href="#Spring-中如何让A和B两个bean按顺序加载" class="headerlink" title="Spring 中如何让A和B两个bean按顺序加载"></a>Spring 中如何让A和B两个bean按顺序加载</h4><ul>
<li>@DependsOn() 注解</li>
<li>实现BeanFactoryPostProcessor，提前调用 init方法</li>
</ul>
<h4 id="Spring中Bean默认是Singleton还是多态的"><a href="#Spring中Bean默认是Singleton还是多态的" class="headerlink" title="Spring中Bean默认是Singleton还是多态的"></a>Spring中Bean默认是Singleton还是多态的</h4><ul>
<li>Singleton</li>
</ul>
<h4 id="为什么默认Singleton"><a href="#为什么默认Singleton" class="headerlink" title="为什么默认Singleton"></a>为什么默认Singleton</h4><ul>
<li>serverless</li>
<li>方法执行结束后，不改变类的状态，不变更全局参数</li>
</ul>
<h4 id="为什么-Scope提供prototype类型"><a href="#为什么-Scope提供prototype类型" class="headerlink" title="为什么@Scope提供prototype类型"></a>为什么@Scope提供prototype类型</h4><p>TODO</p>
<h4 id="Spring如何自定义注解"><a href="#Spring如何自定义注解" class="headerlink" title="Spring如何自定义注解"></a>Spring如何自定义注解</h4><p>TODO</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h4><p>TODO</p>
<h4 id="SpringMVC组件工作流程，如果不这么设计会有什么问题"><a href="#SpringMVC组件工作流程，如果不这么设计会有什么问题" class="headerlink" title="SpringMVC组件工作流程，如果不这么设计会有什么问题"></a>SpringMVC组件工作流程，如果不这么设计会有什么问题</h4><p>TODO</p>
<h4 id="检查拦截器的执行链路在哪个方法比对"><a href="#检查拦截器的执行链路在哪个方法比对" class="headerlink" title="检查拦截器的执行链路在哪个方法比对"></a>检查拦截器的执行链路在哪个方法比对</h4><p>TODO</p>
<h4 id="Spring有几种依赖注入方式"><a href="#Spring有几种依赖注入方式" class="headerlink" title="Spring有几种依赖注入方式"></a>Spring有几种依赖注入方式</h4><ul>
<li>@Autowired</li>
<li>Set</li>
<li>Constructor</li>
</ul>
<h4 id="Spring有几种异步调用方式"><a href="#Spring有几种异步调用方式" class="headerlink" title="Spring有几种异步调用方式"></a>Spring有几种异步调用方式</h4><p>TODO</p>
<h4 id="JDK中的SPI机制是怎么实现的？Spring-实现的SPI了解过吗？"><a href="#JDK中的SPI机制是怎么实现的？Spring-实现的SPI了解过吗？" class="headerlink" title="JDK中的SPI机制是怎么实现的？Spring 实现的SPI了解过吗？"></a>JDK中的SPI机制是怎么实现的？Spring 实现的SPI了解过吗？</h4><p>TODO</p>
<h4 id="如果在一个类内部，我想用某个方法-A调用另一个方法B，想对被调用的方法B进行一个切面，怎么处理？"><a href="#如果在一个类内部，我想用某个方法-A调用另一个方法B，想对被调用的方法B进行一个切面，怎么处理？" class="headerlink" title="如果在一个类内部，我想用某个方法 A调用另一个方法B，想对被调用的方法B进行一个切面，怎么处理？"></a>如果在一个类内部，我想用某个方法 A调用另一个方法B，想对被调用的方法B进行一个切面，怎么处理？</h4><p>TODO</p>
<h4 id="CSRF攻击是什么，原理以及如何防御"><a href="#CSRF攻击是什么，原理以及如何防御" class="headerlink" title="CSRF攻击是什么，原理以及如何防御"></a>CSRF攻击是什么，原理以及如何防御</h4><p>TODO</p>
<h4 id="如何解决跨域，原理是什么"><a href="#如何解决跨域，原理是什么" class="headerlink" title="如何解决跨域，原理是什么"></a>如何解决跨域，原理是什么</h4><p>TODO</p>
<h4 id="RPC进程通信方式有哪些方式"><a href="#RPC进程通信方式有哪些方式" class="headerlink" title="RPC进程通信方式有哪些方式"></a>RPC进程通信方式有哪些方式</h4><p>TODO</p>
<h4 id="SpringMVC的跳转与重定向区别"><a href="#SpringMVC的跳转与重定向区别" class="headerlink" title="SpringMVC的跳转与重定向区别"></a>SpringMVC的跳转与重定向区别</h4><p>TODO</p>
<h4 id="Spring-RestTemplate的具体实现"><a href="#Spring-RestTemplate的具体实现" class="headerlink" title="Spring RestTemplate的具体实现"></a>Spring RestTemplate的具体实现</h4><p>TODO</p>
<h4 id="为什么-JDBC步骤mysql数据存储格式-spring-相关"><a href="#为什么-JDBC步骤mysql数据存储格式-spring-相关" class="headerlink" title="为什么 JDBC步骤mysql数据存储格式 spring 相关"></a>为什么 JDBC步骤mysql数据存储格式 spring 相关</h4><p>TODO</p>
<h4 id="JDBC-源码如何实现的"><a href="#JDBC-源码如何实现的" class="headerlink" title="JDBC 源码如何实现的"></a>JDBC 源码如何实现的</h4><p>TODO</p>
<ol>
<li>调用Class.forName()方法加载相应的数据库驱动程序；</li>
<li>定义要连接数据库的地址URL，要注意不同数据库的连接地址不同;</li>
<li>使用适当的驱动程序类建立与数据库的连接，调用DriverManager对象的getConnection方法，获得一个Connection对象，它表示一个打开的连接</li>
<li>创建语句对象；</li>
<li>执行语句；<br>Statement接口提供了3个方法执行sql语句，分别是executeQuery, executeUpdate和execute<br>executeQuery方法用于执行SELECT查询语句，并返回单个结果集，保存在Resultset对象中;</li>
<li>对返回的结果集ResultSet对象进行处理；</li>
<li>关闭连接。</li>
</ol>
<h4 id="SpringMVC中的session如何拿到的"><a href="#SpringMVC中的session如何拿到的" class="headerlink" title="SpringMVC中的session如何拿到的"></a>SpringMVC中的session如何拿到的</h4><ul>
<li>RequestContextHolder获取Request，间接获取session</li>
<li>HttpServletRequest获取session</li>
</ul>
<h4 id="不使用xml不使用注解如何动态注入Bean"><a href="#不使用xml不使用注解如何动态注入Bean" class="headerlink" title="不使用xml不使用注解如何动态注入Bean"></a>不使用xml不使用注解如何动态注入Bean</h4><ul>
<li><p>Annotation</p>
<p>@Component</p>
<p>@Configuration</p>
<p>@Bean</p>
</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="Service相互调用，被调用类已Catch异常，为何-Transactional仍然回滚"><a href="#Service相互调用，被调用类已Catch异常，为何-Transactional仍然回滚" class="headerlink" title="Service相互调用，被调用类已Catch异常，为何@Transactional仍然回滚"></a>Service相互调用，被调用类已Catch异常，为何@Transactional仍然回滚</h4><ul>
<li><p>场景</p>
<p>@Transactional 在ServiceA 上注解，当ServiceA调用ServiceB，在ServiceB出现异常并捕获时，ServiceA落库的数据仍然抛出异常被回滚</p>
</li>
<li><p>原因</p>
<p>由于事务传播机制，ServiceB默认Propagation.REQUIRED传播方式，因此当ServiceB出现异常时，即使被捕获，仍然已被标记需要回滚</p>
</li>
<li><p>解决方案</p>
<p>ServiceB设置为Propagation.REQUIRES_NEW传播机制，同时取消ServiceB的捕获try-catch，移入serviceA调用serviceB的部分，由serviceA进行捕获即可</p>
</li>
</ul>
<h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><h4 id="Spring-Security和Shiro区别"><a href="#Spring-Security和Shiro区别" class="headerlink" title="Spring Security和Shiro区别"></a>Spring Security和Shiro区别</h4><p>TODO</p>
<h4 id="JWT-对比-cookie-和-session-有什么区别"><a href="#JWT-对比-cookie-和-session-有什么区别" class="headerlink" title="JWT 对比 cookie 和 session 有什么区别"></a>JWT 对比 cookie 和 session 有什么区别</h4><p>TODO</p>
<h4 id="Session可以存放Cookie吗"><a href="#Session可以存放Cookie吗" class="headerlink" title="Session可以存放Cookie吗"></a>Session可以存放Cookie吗</h4><p>TODO</p>
<h4 id="SSO与OAuth2-0区别"><a href="#SSO与OAuth2-0区别" class="headerlink" title="SSO与OAuth2.0区别"></a>SSO与OAuth2.0区别</h4><ul>
<li>SSO是单点登录，负责一次鉴权，多应用使用</li>
<li>Oauth2.0是授予操作权限</li>
<li>SSO是为了解决一个用户在鉴权服务器登陆过一次以后，可以在任何应用（通常是一个厂家的各个系统）中畅通无阻。OAuth2.0解决的是通过令牌（token）而不是密码获取某个系统的操作权限（不同厂家之间的账号共享）。</li>
</ul>
<h4 id="登录一般选择用Jwt还是-Redis"><a href="#登录一般选择用Jwt还是-Redis" class="headerlink" title="登录一般选择用Jwt还是 Redis"></a>登录一般选择用Jwt还是 Redis</h4><p>TODO</p>
<h4 id="Redis-续期你们是怎么做的？难不成每次请求都重置过期时间吗？这不会存在一个安全问题吗"><a href="#Redis-续期你们是怎么做的？难不成每次请求都重置过期时间吗？这不会存在一个安全问题吗" class="headerlink" title="Redis 续期你们是怎么做的？难不成每次请求都重置过期时间吗？这不会存在一个安全问题吗"></a>Redis 续期你们是怎么做的？难不成每次请求都重置过期时间吗？这不会存在一个安全问题吗</h4><p>TODO</p>
<p>使用jiwt续期，因为有refresh token，这个只在登录和刷新才需要携带相对安全一点旦规定了登录最大时问，一般请求只需要access token，这个token有效时间很短相对安全可控。但是存在登录流程需要和前端配合且不能强制退出这个缺点</p>
<h2 id="SpringBoot-相关"><a href="#SpringBoot-相关" class="headerlink" title="SpringBoot 相关"></a>SpringBoot 相关</h2><h4 id="SpringBoot-的启动原理"><a href="#SpringBoot-的启动原理" class="headerlink" title="SpringBoot 的启动原理"></a>SpringBoot 的启动原理</h4><p>TODO</p>
<h4 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h4><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含 了以下<code> 3 个注解</code>：</p>
<p><code>@SpringBootConfiguration：</code>组合了 @Configuration 注解，实现配置文件的功能。</p>
<p><code>@EnableAutoConfiguration：</code>打开自动配置的功能，也可以关闭某个自动配置的选项</p>
<p><code>@ComponentScan</code>：Spring组件扫描。</p>
<h4 id="SpringBoot-生命周期"><a href="#SpringBoot-生命周期" class="headerlink" title="SpringBoot 生命周期"></a>SpringBoot 生命周期</h4><p>SpringBoot应用的生命周期，整体上可以分为SpringApplication初始化阶段、SpringApplication运行阶段、SpringApplication结束阶段、SpringBoot应用退出四个阶段。</p>
<h4 id="Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h4><ul>
<li>Log4j2,LogBack等</li>
<li>推荐使用LogBack</li>
</ul>
<h4 id="SpringBoot-Starter的工作原理"><a href="#SpringBoot-Starter的工作原理" class="headerlink" title="SpringBoot Starter的工作原理"></a>SpringBoot Starter的工作原理</h4><ul>
<li>解析Maven各个starter中的spring.factories文件，根据需求自动配置把Bean注入SpringContext中</li>
</ul>
<h4 id="SpringBoot-自动装配原理"><a href="#SpringBoot-自动装配原理" class="headerlink" title="SpringBoot 自动装配原理"></a>SpringBoot 自动装配原理</h4><p>TODO</p>
<h4 id="Bean注解和-Component区别"><a href="#Bean注解和-Component区别" class="headerlink" title="@Bean注解和@Component区别"></a>@Bean注解和@Component区别</h4><p>TODO</p>
<h4 id="SpringBoot事务的使用"><a href="#SpringBoot事务的使用" class="headerlink" title="SpringBoot事务的使用"></a>SpringBoot事务的使用</h4><ul>
<li>声明式：@Transactional(rollbackFor&#x3D;Exception.class)，这种方法可能出现事务失效问题</li>
<li>非声明式：TransactionTemplate</li>
</ul>
<h4 id="登陆的实现"><a href="#登陆的实现" class="headerlink" title="登陆的实现"></a>登陆的实现</h4><p>TODO</p>
<p>HandlerInterceptor</p>
<h4 id="声明式事务失效原因"><a href="#声明式事务失效原因" class="headerlink" title="声明式事务失效原因"></a>声明式事务失效原因</h4><p>TODO</p>
<h4 id="执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）"><a href="#执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）" class="headerlink" title="执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）"></a>执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）</h4><ul>
<li>全部回滚：@Required</li>
<li>只会第51次：REQUIRES_NEW</li>
</ul>
<h4 id="最大程度的模拟并行Spring的事务传播行为"><a href="#最大程度的模拟并行Spring的事务传播行为" class="headerlink" title="最大程度的模拟并行Spring的事务传播行为"></a>最大程度的模拟并行Spring的事务传播行为</h4><p>TODO</p>
<h4 id="Async异步调用方法"><a href="#Async异步调用方法" class="headerlink" title="Async异步调用方法"></a>Async异步调用方法</h4><ul>
<li>启动类加上@EnableSync注解后，直接在需要的方法上打上@Async注解</li>
<li>建议配置额外线程池使用@Async</li>
<li>需注意与其他AOP注入冲突问题，可以用@Lazy注解解决</li>
</ul>
<h4 id="如何在-Spring-Boot-启动的时候运行一些特定的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特定的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特定的代码？"></a>如何在 Spring Boot 启动的时候运行一些特定的代码？</h4><ul>
<li>可以实现接口 <code>ApplicationRunner</code> 或者 <code>CommandLineRunner</code>，这两个接口实现方式一样，它们都只提供了一个 <code>run</code> 方法</li>
<li>Spring Listener周期启动？</li>
</ul>
<h4 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h4><ul>
<li>Spring Boot 可以通过<code> @PropertySource,@Value,@Environment, @ConfigurationPropertie注解</code>来绑定变量</li>
</ul>
<h4 id="bootstrap-properties-和-application-properties-有何异同"><a href="#bootstrap-properties-和-application-properties-有何异同" class="headerlink" title="bootstrap.properties 和 application.properties 有何异同"></a>bootstrap.properties 和 application.properties 有何异同</h4><ul>
<li>都可以是核心文件</li>
<li>bootstrap优先级比application高</li>
<li>Springboot一般使用application，SpringCloud使用bootstrap</li>
</ul>
<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><ul>
<li>后端通过通过实现WebMvcConfifigurer接口然后重写addCorsMappings方法解决</li>
</ul>
<h4 id="SpringBoot异常处理相关注解"><a href="#SpringBoot异常处理相关注解" class="headerlink" title="SpringBoot异常处理相关注解?"></a>SpringBoot异常处理相关注解?</h4><ul>
<li>@ControllerAdvice</li>
<li>@ExceptionHandler</li>
</ul>
<h4 id="SpringBoot配置监控"><a href="#SpringBoot配置监控" class="headerlink" title="SpringBoot配置监控?"></a>SpringBoot配置监控?</h4><ul>
<li>Maven 引入 spring-boot-starter-actuator</li>
</ul>
<h4 id="相同的服务A、B、C，挂了一个A，RESTAPI怎么知道A挂了并调用-B"><a href="#相同的服务A、B、C，挂了一个A，RESTAPI怎么知道A挂了并调用-B" class="headerlink" title="相同的服务A、B、C，挂了一个A，RESTAPI怎么知道A挂了并调用 B"></a>相同的服务A、B、C，挂了一个A，RESTAPI怎么知道A挂了并调用 B</h4><p>TODO</p>
<h4 id="前后端分离的session失效问题，能否用redis-替代session"><a href="#前后端分离的session失效问题，能否用redis-替代session" class="headerlink" title="前后端分离的session失效问题，能否用redis 替代session"></a>前后端分离的session失效问题，能否用redis 替代session</h4><ul>
<li>Token返回前端，前端Header带token</li>
<li>可以</li>
</ul>
<h2 id="Spring-Cloud-相关"><a href="#Spring-Cloud-相关" class="headerlink" title="Spring Cloud 相关"></a>Spring Cloud 相关</h2><h4 id="为什么要进行系统拆分？如何进行系统拆分？"><a href="#为什么要进行系统拆分？如何进行系统拆分？" class="headerlink" title="为什么要进行系统拆分？如何进行系统拆分？"></a>为什么要进行系统拆分？如何进行系统拆分？</h4><p>TODO</p>
<h4 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h4><h4 id="微服务之间是如何独立通讯的？"><a href="#微服务之间是如何独立通讯的？" class="headerlink" title="微服务之间是如何独立通讯的？"></a>微服务之间是如何独立通讯的？</h4><ul>
<li>HTTP：OpenFeign</li>
<li>二进制：Dubbo</li>
<li>MQ</li>
</ul>
<h4 id="微服务架构优缺点"><a href="#微服务架构优缺点" class="headerlink" title="微服务架构优缺点"></a>微服务架构优缺点</h4><p>TODO</p>
<h4 id="服务之间如何快速通信"><a href="#服务之间如何快速通信" class="headerlink" title="服务之间如何快速通信"></a>服务之间如何快速通信</h4><ul>
<li>RESTful API</li>
<li>MQ</li>
<li>RPC</li>
<li>WebSocket</li>
<li>gRPC</li>
</ul>
<h4 id="怎么避免微服务深度调用"><a href="#怎么避免微服务深度调用" class="headerlink" title="怎么避免微服务深度调用"></a>怎么避免微服务深度调用</h4><p>TODO</p>
<h4 id="OpenFeign底层调用原理"><a href="#OpenFeign底层调用原理" class="headerlink" title="OpenFeign底层调用原理"></a>OpenFeign底层调用原理</h4><p>TODO</p>
<h4 id="Ribbon的工作原理"><a href="#Ribbon的工作原理" class="headerlink" title="Ribbon的工作原理"></a>Ribbon的工作原理</h4><p>TODO</p>
<h4 id="Sentinel如何实现熔断"><a href="#Sentinel如何实现熔断" class="headerlink" title="Sentinel如何实现熔断"></a>Sentinel如何实现熔断</h4><p>TODO</p>
<h4 id="Spring-Boot-和-Spring-Cloud，谈谈你对它们的理解？"><a href="#Spring-Boot-和-Spring-Cloud，谈谈你对它们的理解？" class="headerlink" title="Spring Boot 和 Spring Cloud，谈谈你对它们的理解？"></a>Spring Boot 和 Spring Cloud，谈谈你对它们的理解？</h4><ul>
<li>Spring Boot基于Spring的脚手架</li>
<li>Spring Cloud是一套依托于Spring生态的微服务解决方案</li>
</ul>
<h4 id="Sentinel内部是怎么统计-QPS指标达到限流的目的？滑动窗口算法的实现？如何判断请求在哪个时间窗口内？"><a href="#Sentinel内部是怎么统计-QPS指标达到限流的目的？滑动窗口算法的实现？如何判断请求在哪个时间窗口内？" class="headerlink" title="Sentinel内部是怎么统计 QPS指标达到限流的目的？滑动窗口算法的实现？如何判断请求在哪个时间窗口内？"></a>Sentinel内部是怎么统计 QPS指标达到限流的目的？滑动窗口算法的实现？如何判断请求在哪个时间窗口内？</h4><p>TODO</p>
<h4 id="如何限流？在工作中是怎么做的？说一下具体的实现？"><a href="#如何限流？在工作中是怎么做的？说一下具体的实现？" class="headerlink" title="如何限流？在工作中是怎么做的？说一下具体的实现？"></a>如何限流？在工作中是怎么做的？说一下具体的实现？</h4><p>TODO</p>
<h4 id="集群分布式-Session-如何实现？"><a href="#集群分布式-Session-如何实现？" class="headerlink" title="集群分布式 Session 如何实现？"></a>集群分布式 Session 如何实现？</h4><ul>
<li>Redis存储，各服务器共享</li>
<li>tomcat-redis-session-manager，session粘滞：强行分发session到各个服务器</li>
</ul>
<h4 id="如何设计一个高并发的系统"><a href="#如何设计一个高并发的系统" class="headerlink" title="如何设计一个高并发的系统"></a>如何设计一个高并发的系统</h4><p>TODO</p>
<h4 id="请解释一下什么是C10K问题，后来是怎么解决的"><a href="#请解释一下什么是C10K问题，后来是怎么解决的" class="headerlink" title="请解释一下什么是C10K问题，后来是怎么解决的"></a>请解释一下什么是C10K问题，后来是怎么解决的</h4><ul>
<li>在同时连接到服务器的客户端数量超过 10000 个的环境中，即便硬件性能足够， 依然无法正常提供服务</li>
<li>多路复用，非阻塞IO，减少不必要性能损耗，异步响应</li>
</ul>
<h4 id="高并发除了加锁还有什么解决方案"><a href="#高并发除了加锁还有什么解决方案" class="headerlink" title="高并发除了加锁还有什么解决方案"></a>高并发除了加锁还有什么解决方案</h4><p>TODO</p>
<h4 id="Spring-Cloud-和-Dubbo-有哪些区别？"><a href="#Spring-Cloud-和-Dubbo-有哪些区别？" class="headerlink" title="Spring Cloud 和 Dubbo 有哪些区别？"></a>Spring Cloud 和 Dubbo 有哪些区别？</h4><ul>
<li>定位不同：SpringCloud是解决方案，Dubbo作用于服务调用与治理</li>
<li>生态不同：SpringCloud是Spring平台生态，Dubbo初始设计是SOA的RPC远程调用</li>
<li>调用方式：SpringCloud是Http调用，通常是Rest风格。Dubbo使用Dubbo协议，接口一般是Java的Service接口，传输二进制数据，内部Netty的NIO方式，性能更好</li>
<li>Spring Cloud注册中心Eureka（Spring Cloud Alibaba是Nacos），Dubbo采用Zookeeper</li>
</ul>
<h4 id="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"><a href="#Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？" class="headerlink" title="Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？"></a>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</h4><p>TODO</p>
<h4 id="SpringCloud几个组件主要功能"><a href="#SpringCloud几个组件主要功能" class="headerlink" title="SpringCloud几个组件主要功能"></a>SpringCloud几个组件主要功能</h4><p>TODO</p>
<h4 id="Stream-Binder是什么"><a href="#Stream-Binder是什么" class="headerlink" title="Stream Binder是什么"></a>Stream Binder是什么</h4><p>TODO</p>
<h4 id="分布式微服务的组件和底层代码（如GateWay、Sentinal）"><a href="#分布式微服务的组件和底层代码（如GateWay、Sentinal）" class="headerlink" title="分布式微服务的组件和底层代码（如GateWay、Sentinal）"></a>分布式微服务的组件和底层代码（如GateWay、Sentinal）</h4><p>TODO</p>
<h4 id="分布式session设置"><a href="#分布式session设置" class="headerlink" title="分布式session设置"></a>分布式session设置</h4><p>TODO</p>
<h4 id="分布式session一致性"><a href="#分布式session一致性" class="headerlink" title="分布式session一致性"></a>分布式session一致性</h4><p>TODO</p>
<h4 id="分布式接口的幂等性设计「不能重复扣款」"><a href="#分布式接口的幂等性设计「不能重复扣款」" class="headerlink" title="分布式接口的幂等性设计「不能重复扣款」"></a>分布式接口的幂等性设计「不能重复扣款」</h4><p>TODO</p>
<h4 id="如何实现分布式锁"><a href="#如何实现分布式锁" class="headerlink" title="如何实现分布式锁"></a>如何实现分布式锁</h4><p>TODO</p>
<h4 id="设计一个高并发秒杀系统"><a href="#设计一个高并发秒杀系统" class="headerlink" title="设计一个高并发秒杀系统"></a>设计一个高并发秒杀系统</h4><p>TODO</p>
<p>亿级流量多级缓存的架构</p>
<h4 id="服务熔断怎么设计"><a href="#服务熔断怎么设计" class="headerlink" title="服务熔断怎么设计"></a>服务熔断怎么设计</h4><p>TODO</p>
<h4 id="微服务高可用如何设计，如3台服务器，一台宕机如何防止这种现象"><a href="#微服务高可用如何设计，如3台服务器，一台宕机如何防止这种现象" class="headerlink" title="微服务高可用如何设计，如3台服务器，一台宕机如何防止这种现象"></a>微服务高可用如何设计，如3台服务器，一台宕机如何防止这种现象</h4><p>TODO</p>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h4 id="Zookeeper有哪些用"><a href="#Zookeeper有哪些用" class="headerlink" title="Zookeeper有哪些用"></a>Zookeeper有哪些用</h4><p>TODO</p>
<h4 id="zookeeper保证的CP，如何保障的"><a href="#zookeeper保证的CP，如何保障的" class="headerlink" title="zookeeper保证的CP，如何保障的"></a>zookeeper保证的CP，如何保障的</h4><p>TODO</p>
<h4 id="正式服和测试服公用一个zookeeper，怎么解决交叉消费"><a href="#正式服和测试服公用一个zookeeper，怎么解决交叉消费" class="headerlink" title="正式服和测试服公用一个zookeeper，怎么解决交叉消费"></a>正式服和测试服公用一个zookeeper，怎么解决交叉消费</h4><p>TODO</p>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/overview/what/">Dubbo官网包含介绍与问题解析</a></p>
<h4 id="Dubbo与Spring-Cloud关系"><a href="#Dubbo与Spring-Cloud关系" class="headerlink" title="Dubbo与Spring Cloud关系"></a>Dubbo与Spring Cloud关系</h4><ul>
<li>Dubbo是一款RPC服务开发框架，解决微服务架构下的服务通信与服务治理问题</li>
<li>Spring Cloud是一套微服务框架，包含服务治理等功能</li>
</ul>
<h4 id="Dubbo-负载均衡策略都有哪些？"><a href="#Dubbo-负载均衡策略都有哪些？" class="headerlink" title="Dubbo 负载均衡策略都有哪些？"></a>Dubbo 负载均衡策略都有哪些？</h4><table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">特性</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Weighted Random LoadBalance</td>
<td align="left">加权随机</td>
<td align="left">默认算法，默认权重相同</td>
</tr>
<tr>
<td align="left">RoundRobin LoadBalance</td>
<td align="left">加权轮询</td>
<td align="left">借鉴于 Nginx 的平滑加权轮询算法，默认权重相同，</td>
</tr>
<tr>
<td align="left">LeastActive LoadBalance</td>
<td align="left">最少活跃优先 + 加权随机</td>
<td align="left">背后是能者多劳的思想</td>
</tr>
<tr>
<td align="left">Shortest-Response LoadBalance</td>
<td align="left">最短响应优先 + 加权随机</td>
<td align="left">更加关注响应速度</td>
</tr>
<tr>
<td align="left">ConsistentHash LoadBalance</td>
<td align="left">一致性哈希</td>
<td align="left">确定的入参，确定的提供者，适用于有状态请求</td>
</tr>
</tbody></table>
<h4 id="Dubbo-的工作原理？（带图）"><a href="#Dubbo-的工作原理？（带图）" class="headerlink" title="Dubbo 的工作原理？（带图）"></a>Dubbo 的工作原理？（带图）</h4><p>TODO</p>
<h4 id="Dubbo服务发现"><a href="#Dubbo服务发现" class="headerlink" title="Dubbo服务发现"></a>Dubbo服务发现</h4><p>TODO</p>
<h4 id="Dubbo-进行服务治理、服务降级、失败重试以及超时重试？"><a href="#Dubbo-进行服务治理、服务降级、失败重试以及超时重试？" class="headerlink" title="Dubbo 进行服务治理、服务降级、失败重试以及超时重试？"></a>Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</h4><p>TODO</p>
<h4 id="Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗"><a href="#Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗" class="headerlink" title="Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗"></a>Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗</h4><p>TODO</p>
<h4 id="Dubbo超时重试；Dubbo超时时间设置"><a href="#Dubbo超时重试；Dubbo超时时间设置" class="headerlink" title="Dubbo超时重试；Dubbo超时时间设置"></a>Dubbo超时重试；Dubbo超时时间设置</h4><p>TODO</p>
<h4 id="如何保障请求执行顺序"><a href="#如何保障请求执行顺序" class="headerlink" title="如何保障请求执行顺序"></a>如何保障请求执行顺序</h4><p>TODO</p>
<h4 id="怎么处理外部调用你们的dubbo-接口超时的情景"><a href="#怎么处理外部调用你们的dubbo-接口超时的情景" class="headerlink" title="怎么处理外部调用你们的dubbo 接口超时的情景"></a>怎么处理外部调用你们的dubbo 接口超时的情景</h4><p>TODO</p>
<h4 id="Dubbo中热插拔导致的资源末回收怎么处理"><a href="#Dubbo中热插拔导致的资源末回收怎么处理" class="headerlink" title="Dubbo中热插拔导致的资源末回收怎么处理"></a>Dubbo中热插拔导致的资源末回收怎么处理</h4><p>TODO</p>
<p>比如说 SPI创建对象,如果说这个对象中开辟了线程池,那么热插拔的时候,如何来释放这个线程池的资源如何平滑地承接流量,如何真实地load进去呢？怎么实现无感?</p>
<p>说了一个思路,使用钩子函数,开辟守护线程,定期检查是否发生了热插拔替换 如果发生<br>了就调用这个对象的释放资源的方法</p>
<h4 id="Dubbo-的-SPI-和-Java-的-SPI-有什么区别？"><a href="#Dubbo-的-SPI-和-Java-的-SPI-有什么区别？" class="headerlink" title="Dubbo 的 SPI 和 Java 的 SPI 有什么区别？"></a>Dubbo 的 SPI 和 Java 的 SPI 有什么区别？</h4><p>TODO</p>
<h4 id="Dubbo组件之间的关联性"><a href="#Dubbo组件之间的关联性" class="headerlink" title="Dubbo组件之间的关联性"></a>Dubbo组件之间的关联性</h4><p>TODO</p>
<h4 id="如何自己设计一个类似-Dubbo-的-RPC-框架？"><a href="#如何自己设计一个类似-Dubbo-的-RPC-框架？" class="headerlink" title="如何自己设计一个类似 Dubbo 的 RPC 框架？"></a>如何自己设计一个类似 Dubbo 的 RPC 框架？</h4><p>TODO</p>
<h3 id="gRpc"><a href="#gRpc" class="headerlink" title="gRpc"></a>gRpc</h3><h4 id="gRpc是什么，有什么优点"><a href="#gRpc是什么，有什么优点" class="headerlink" title="gRpc是什么，有什么优点"></a>gRpc是什么，有什么优点</h4><p>TODO</p>
<h4 id="gRpc和Rest区别是什么"><a href="#gRpc和Rest区别是什么" class="headerlink" title="gRpc和Rest区别是什么"></a>gRpc和Rest区别是什么</h4><p>TODO</p>
<h4 id="gRPC用的是什么协议"><a href="#gRPC用的是什么协议" class="headerlink" title="gRPC用的是什么协议"></a>gRPC用的是什么协议</h4><p>TODO</p>
<h4 id="gRPC为什么使用protoBuf作为序列化机制，跟其他二进制有比有什么优势"><a href="#gRPC为什么使用protoBuf作为序列化机制，跟其他二进制有比有什么优势" class="headerlink" title="gRPC为什么使用protoBuf作为序列化机制，跟其他二进制有比有什么优势"></a>gRPC为什么使用protoBuf作为序列化机制，跟其他二进制有比有什么优势</h4><p>TODO</p>
<p>注意阿里hessian</p>
<h4 id="gRPC流程是什么"><a href="#gRPC流程是什么" class="headerlink" title="gRPC流程是什么"></a>gRPC流程是什么</h4><p>TODO</p>
<h4 id="gRPC支持哪些类型的序列化"><a href="#gRPC支持哪些类型的序列化" class="headerlink" title="gRPC支持哪些类型的序列化"></a>gRPC支持哪些类型的序列化</h4><p>TODO</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/">Seata官网</a></p>
<h4 id="分布式事务，缓存和数据库的一致性保持"><a href="#分布式事务，缓存和数据库的一致性保持" class="headerlink" title="分布式事务，缓存和数据库的一致性保持"></a>分布式事务，缓存和数据库的一致性保持</h4><p>TODO</p>
<h4 id="分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势"><a href="#分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势" class="headerlink" title="分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势"></a>分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势</h4><ul>
<li>2PC 3PC TCC Saga事务 本地消息表，MQ消息事务最大努力通知</li>
</ul>
<h4 id="Seata配置方式"><a href="#Seata配置方式" class="headerlink" title="Seata配置方式"></a>Seata配置方式</h4><p>TODO</p>
<p>引入包，相关参数</p>
<h4 id="Seata模式"><a href="#Seata模式" class="headerlink" title="Seata模式"></a>Seata模式</h4><p>TODO</p>
<p>TA，2PC，3PC，Saga关联</p>
<h4 id="Seata流程"><a href="#Seata流程" class="headerlink" title="Seata流程"></a>Seata流程</h4><p>TODO</p>
<h4 id="Seata-AT模式两阶段过程"><a href="#Seata-AT模式两阶段过程" class="headerlink" title="Seata AT模式两阶段过程"></a>Seata AT模式两阶段过程</h4><ul>
<li><p>第一阶段：开启全局事务，注册分支事务，存储全局锁、业务数据与回滚日志</p>
</li>
<li><p>第二阶段：事务协调者根据所有分支状况，决定当前事务是commit还是rollback。</p>
<p>两种结果都需删除undolog日志、全局事务、分支事务、存储的全局锁。</p>
</li>
</ul>
<h4 id="分布式事务与分布式锁（扣款不要出现负数）"><a href="#分布式事务与分布式锁（扣款不要出现负数）" class="headerlink" title="分布式事务与分布式锁（扣款不要出现负数）"></a>分布式事务与分布式锁（扣款不要出现负数）</h4><p>TODO</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h4 id="Nacos作用"><a href="#Nacos作用" class="headerlink" title="Nacos作用"></a>Nacos作用</h4><p>TODO</p>
<h4 id="Nacos优缺点"><a href="#Nacos优缺点" class="headerlink" title="Nacos优缺点"></a>Nacos优缺点</h4><p>TODO</p>
<h4 id="Nacos-1-x版本作为注册中心原理"><a href="#Nacos-1-x版本作为注册中心原理" class="headerlink" title="Nacos 1.x版本作为注册中心原理"></a>Nacos 1.x版本作为注册中心原理</h4><ul>
<li>Client端Http向Nacos Server发送注册请求</li>
<li>Client端向Nacos Server查询服务提供方注册的列表数据</li>
<li>每10s定时拉取 + 检测到服务提供者异常，基于UDP协议推送更新</li>
<li>服务Client每5s定时心跳推送给Nacos Server，检测服务状态</li>
<li>Nacos Server定时心跳任务检查</li>
<li>集群同步任务使用Distro</li>
</ul>
<h4 id="Nacos注册中心是-AP还是CP"><a href="#Nacos注册中心是-AP还是CP" class="headerlink" title="Nacos注册中心是 AP还是CP"></a>Nacos注册中心是 AP还是CP</h4><p>TODO</p>
<h4 id="Nacos和Erueka区别"><a href="#Nacos和Erueka区别" class="headerlink" title="Nacos和Erueka区别"></a>Nacos和Erueka区别</h4><p>TODO</p>
<h4 id="Nacos和Zookeeper区别"><a href="#Nacos和Zookeeper区别" class="headerlink" title="Nacos和Zookeeper区别"></a>Nacos和Zookeeper区别</h4><p>TODO</p>
<h4 id="Nacos和Apollo区别"><a href="#Nacos和Apollo区别" class="headerlink" title="Nacos和Apollo区别"></a>Nacos和Apollo区别</h4><ul>
<li><p>领域</p>
<p>Nacos主要关注微服务场景下的服务发现、配置管理和DNS解析。</p>
<p>Apollo主要关注企业级应用场景下的配置管理</p>
</li>
<li><p>协议</p>
<p>Nacos支持Restful和gRpc协议，Apollo只支持Http协议</p>
</li>
<li><p>数据存储</p>
<p>Nacos 使用MySQL存储，Apollo使用自带H2数据库存储</p>
</li>
<li><p>功能特性</p>
<p>Nacos提供服务注册和服务发现、动态配置、服务健康检测、流量管理等功能。</p>
<p>Apollo提供分布式配置管理、灰度发布、发布审计等功能。</p>
</li>
<li><p>社区生态</p>
<p>Nacos有国内社区生态，Apollo国际生态广</p>
</li>
</ul>
<h4 id="一个Nacos如何进行不同环境隔离？如果是在一个nameSpace下又如何隔离？开发环境下，前端怎么调用指定的后端"><a href="#一个Nacos如何进行不同环境隔离？如果是在一个nameSpace下又如何隔离？开发环境下，前端怎么调用指定的后端" class="headerlink" title="一个Nacos如何进行不同环境隔离？如果是在一个nameSpace下又如何隔离？开发环境下，前端怎么调用指定的后端"></a>一个Nacos如何进行不同环境隔离？如果是在一个nameSpace下又如何隔离？开发环境下，前端怎么调用指定的后端</h4><p>TODO</p>
<h4 id="Nacos和euraka的区别"><a href="#Nacos和euraka的区别" class="headerlink" title="Nacos和euraka的区别"></a>Nacos和euraka的区别</h4><p>TODO</p>
<h2 id="MQ-相关"><a href="#MQ-相关" class="headerlink" title="MQ 相关"></a>MQ 相关</h2><h3 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h3><h4 id="MQ选型"><a href="#MQ选型" class="headerlink" title="MQ选型"></a>MQ选型</h4><ul>
<li>Kafka：高吞吐量，适合数据量大的业务</li>
<li>RocketMQ：拥有事务消息，可靠性要求高可使用</li>
<li>RabbitMQ：结合Erlang并发性好，但不利于二次开发</li>
<li>ActiveMQ：维护越来越少，不建议使用</li>
</ul>
<h4 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h4><p>TODO</p>
<h4 id="手写生产者消费者（Product-A、C，Follower-B、D，Bind-AC-BD-Exchange）"><a href="#手写生产者消费者（Product-A、C，Follower-B、D，Bind-AC-BD-Exchange）" class="headerlink" title="手写生产者消费者（Product A、C，Follower B、D，Bind AC &amp;&amp; BD + Exchange）"></a>手写生产者消费者（Product A、C，Follower B、D，Bind AC &amp;&amp; BD + Exchange）</h4><p>TODO</p>
<h4 id="项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？"><a href="#项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？" class="headerlink" title="项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？"></a>项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？</h4><p>TODO</p>
<h4 id="MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？"><a href="#MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？" class="headerlink" title="MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？"></a>MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？</h4><p>TODO</p>
<h4 id="MQ有遇到过重复消费的问题吗？怎么解决的呢？"><a href="#MQ有遇到过重复消费的问题吗？怎么解决的呢？" class="headerlink" title="MQ有遇到过重复消费的问题吗？怎么解决的呢？"></a>MQ有遇到过重复消费的问题吗？怎么解决的呢？</h4><ul>
<li>Redisson+幂等性判断</li>
</ul>
<h4 id="MQ有遇到过消息丢失吗？可靠性怎么保证呢？"><a href="#MQ有遇到过消息丢失吗？可靠性怎么保证呢？" class="headerlink" title="MQ有遇到过消息丢失吗？可靠性怎么保证呢？"></a>MQ有遇到过消息丢失吗？可靠性怎么保证呢？</h4><p>TODO</p>
<h4 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</h4><p>TODO</p>
<h4 id="如何保证消息的一致性"><a href="#如何保证消息的一致性" class="headerlink" title="如何保证消息的一致性"></a>如何保证消息的一致性</h4><p>TODO</p>
<h3 id="Kafka相关"><a href="#Kafka相关" class="headerlink" title="Kafka相关"></a>Kafka相关</h3><h4 id="Kafka特性"><a href="#Kafka特性" class="headerlink" title="Kafka特性"></a>Kafka特性</h4><ul>
<li>高吞吐量</li>
<li>扩展性强</li>
<li>多客户端支持</li>
<li>Kafka Stream流处理</li>
<li>消息压缩</li>
<li>消息持久化</li>
</ul>
<h4 id="Kafka可以不用zookeeper吗"><a href="#Kafka可以不用zookeeper吗" class="headerlink" title="Kafka可以不用zookeeper吗"></a>Kafka可以不用zookeeper吗</h4><ul>
<li>历史版本不可以</li>
<li>新版本2.8后可以使用KRaft脱离zookeeper</li>
</ul>
<h4 id="Kafka-的-partition和-block"><a href="#Kafka-的-partition和-block" class="headerlink" title="Kafka 的 partition和 block"></a>Kafka 的 partition和 block</h4><p>TODO</p>
<h4 id="Kafka底层原理"><a href="#Kafka底层原理" class="headerlink" title="Kafka底层原理"></a>Kafka底层原理</h4><p>TODO</p>
<h4 id="Kafka机制"><a href="#Kafka机制" class="headerlink" title="Kafka机制"></a>Kafka机制</h4><p>TODO</p>
<h4 id="Kafka事务"><a href="#Kafka事务" class="headerlink" title="Kafka事务"></a>Kafka事务</h4><p>TODO</p>
<h4 id="如何处理消息堆积"><a href="#如何处理消息堆积" class="headerlink" title="如何处理消息堆积"></a>如何处理消息堆积</h4><p>TODO</p>
<h4 id="如何高并发顺序消费Kafka中的数据"><a href="#如何高并发顺序消费Kafka中的数据" class="headerlink" title="如何高并发顺序消费Kafka中的数据"></a>如何高并发顺序消费Kafka中的数据</h4><p>TODO</p>
<h4 id="Kafka消息顺序性"><a href="#Kafka消息顺序性" class="headerlink" title="Kafka消息顺序性"></a>Kafka消息顺序性</h4><p>TODO</p>
<h4 id="Kafka如何管理偏移量的"><a href="#Kafka如何管理偏移量的" class="headerlink" title="Kafka如何管理偏移量的"></a>Kafka如何管理偏移量的</h4><p>TODO</p>
<h4 id="Kafka持久化内存满了除了迁移还能怎么办"><a href="#Kafka持久化内存满了除了迁移还能怎么办" class="headerlink" title="Kafka持久化内存满了除了迁移还能怎么办"></a>Kafka持久化内存满了除了迁移还能怎么办</h4><p>TODO</p>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>TODO</p>
<h4 id="mmap和sendFile区别"><a href="#mmap和sendFile区别" class="headerlink" title="mmap和sendFile区别"></a>mmap和sendFile区别</h4><p>TODO</p>
<h4 id="Kafka的索引使用的是什么数据结构"><a href="#Kafka的索引使用的是什么数据结构" class="headerlink" title="Kafka的索引使用的是什么数据结构"></a>Kafka的索引使用的是什么数据结构</h4><ul>
<li>LSM树</li>
</ul>
<h4 id="Kafka消费过程时，PageCache污染原因"><a href="#Kafka消费过程时，PageCache污染原因" class="headerlink" title="Kafka消费过程时，PageCache污染原因"></a>Kafka消费过程时，PageCache污染原因</h4><p>TODO</p>
<h4 id="如何理解Kafka的端到端延时"><a href="#如何理解Kafka的端到端延时" class="headerlink" title="如何理解Kafka的端到端延时"></a>如何理解Kafka的端到端延时</h4><ul>
<li><p>Producer</p>
<ul>
<li>linger.ms 设定ms时间内发送一批消息</li>
<li>batch.size 设定积攒多少条消息进行发送</li>
<li>compression.type 压缩打包到消息，减少带宽耗费时间</li>
<li>max.inflight.requests.per.connection Broker 响应时间</li>
</ul>
</li>
<li><p>Broker</p>
<ul>
<li>acks &#x3D; 0 在Produce发送后即可，不需要等待Broker反馈</li>
<li>acks &#x3D; 1 需记录到Broker PageCache 才响应Producer</li>
<li>acks &#x3D; -1 必须在所有副本都被同步后才能响应Producer</li>
</ul>
</li>
<li><p>Consumer</p>
<ul>
<li><p>fetch.min.bytes &#x3D; 1</p>
<p>fetch.max.wait.ms &#x3D; 500</p>
<p>设定一次拉取多少条消息，如果攒不够就在指定等待时间内拉取下一批次消息</p>
</li>
</ul>
</li>
</ul>
<h4 id="Kafka数据丢失解决方法"><a href="#Kafka数据丢失解决方法" class="headerlink" title="Kafka数据丢失解决方法"></a>Kafka数据丢失解决方法</h4><ul>
<li><p>Producer</p>
<ul>
<li>设置 acks &#x3D; all 等待broker将数据完整写入副本响应后，认为数据发送成功</li>
<li>设置retries &#x3D; 10 重试次数</li>
</ul>
</li>
<li><p>Broker</p>
<ul>
<li><p>多目录参数设置</p>
<p>log.dirs</p>
</li>
<li><p>强制刷盘设置（不建议）</p>
<p>log.flush.interval.messages</p>
<p>log.flush.interval.ms</p>
<p>log.flush.scheduler.interval.ms</p>
</li>
</ul>
</li>
<li><p>Consumer</p>
<ul>
<li>ack 应答机制</li>
</ul>
</li>
</ul>
<h4 id="Kafka如何保证消息有序"><a href="#Kafka如何保证消息有序" class="headerlink" title="Kafka如何保证消息有序"></a>Kafka如何保证消息有序</h4><ul>
<li><p>每个Topic只设置一个Partition，保证写入有序，但不保证网络问题导致的顺序变更</p>
</li>
<li><p>局部有序</p>
<p>同类型消息放入Topic的同一分区</p>
</li>
</ul>
<h4 id="Kafka顺序读为什么快"><a href="#Kafka顺序读为什么快" class="headerlink" title="Kafka顺序读为什么快"></a>Kafka顺序读为什么快</h4><ul>
<li>PageCache对Block file中数据的预读</li>
</ul>
<h4 id="Kafka顺序写为什么快"><a href="#Kafka顺序写为什么快" class="headerlink" title="Kafka顺序写为什么快"></a>Kafka顺序写为什么快</h4><ul>
<li>物理地址和逻辑地址保证一致，减少磁盘旋转寻址开销，直接追加写</li>
</ul>
<h4 id="Kafka从设计上怎么保证吞吐量"><a href="#Kafka从设计上怎么保证吞吐量" class="headerlink" title="Kafka从设计上怎么保证吞吐量"></a>Kafka从设计上怎么保证吞吐量</h4><p>TODO</p>
<h3 id="RocketMQ相关"><a href="#RocketMQ相关" class="headerlink" title="RocketMQ相关"></a>RocketMQ相关</h3><h4 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h4><p>TODO</p>
<p>生生产者产生消息；<br>消息发送到存储端，保存下来<br>消息推送到消费者，消费者消费完，ack应答</p>
<h4 id="RocketMQ支持哪些消息类型"><a href="#RocketMQ支持哪些消息类型" class="headerlink" title="RocketMQ支持哪些消息类型"></a>RocketMQ支持哪些消息类型</h4><p>TODO</p>
<h4 id="RocketMQ的Consumer用的什么模式"><a href="#RocketMQ的Consumer用的什么模式" class="headerlink" title="RocketMQ的Consumer用的什么模式"></a>RocketMQ的Consumer用的什么模式</h4><p>TODO</p>
<h4 id="RocketMQ事务消息是否了解？场景题：比如下单清空购物车，你是如何设计的"><a href="#RocketMQ事务消息是否了解？场景题：比如下单清空购物车，你是如何设计的" class="headerlink" title="RocketMQ事务消息是否了解？场景题：比如下单清空购物车，你是如何设计的"></a>RocketMQ事务消息是否了解？场景题：比如下单清空购物车，你是如何设计的</h4><p>TODO</p>
<p>事务消息主要用来解决消息生产者和消息消费者的数据一致性问题。</p>
<h4 id="RocketMQ为什么不用Zookeeper作为注册中心"><a href="#RocketMQ为什么不用Zookeeper作为注册中心" class="headerlink" title="RocketMQ为什么不用Zookeeper作为注册中心"></a>RocketMQ为什么不用Zookeeper作为注册中心</h4><p>TODO</p>
<h4 id="RocketMQ保证顺序消费，为何要在Broker端锁定该消息队列，保证只有一个消费者会获得该消费队列"><a href="#RocketMQ保证顺序消费，为何要在Broker端锁定该消息队列，保证只有一个消费者会获得该消费队列" class="headerlink" title="RocketMQ保证顺序消费，为何要在Broker端锁定该消息队列，保证只有一个消费者会获得该消费队列"></a>RocketMQ保证顺序消费，为何要在Broker端锁定该消息队列，保证只有一个消费者会获得该消费队列</h4><ul>
<li>rocketMQ再均衡没有类似kafka的coordinator参与，都是各个consumer独立完成。肯存在某一时刻多个consumer消费同一个consumequeue的情况</li>
</ul>
<h4 id="RocketMQ如果消费者组A下面有两个消费组A1，A2，问消费者A1和A2是否消费不同的主题"><a href="#RocketMQ如果消费者组A下面有两个消费组A1，A2，问消费者A1和A2是否消费不同的主题" class="headerlink" title="RocketMQ如果消费者组A下面有两个消费组A1，A2，问消费者A1和A2是否消费不同的主题"></a>RocketMQ如果消费者组A下面有两个消费组A1，A2，问消费者A1和A2是否消费不同的主题</h4><p>TODO</p>
<h4 id="RocketMQ如何保证事务"><a href="#RocketMQ如何保证事务" class="headerlink" title="RocketMQ如何保证事务"></a>RocketMQ如何保证事务</h4><p>TODO</p>
<h3 id="RabbitMQ相关"><a href="#RabbitMQ相关" class="headerlink" title="RabbitMQ相关"></a>RabbitMQ相关</h3><h4 id="RabbitMQ-如何保证不丢消息"><a href="#RabbitMQ-如何保证不丢消息" class="headerlink" title="RabbitMQ 如何保证不丢消息"></a>RabbitMQ 如何保证不丢消息</h4><ul>
<li><p>主要方法</p>
<p>持久化消息，Consumer ACK机制</p>
</li>
<li><p>其他方法</p>
<p>备份队列，镜像队列和生产者确认机制</p>
</li>
</ul>
<h4 id="RabbitMQ交换机有哪些"><a href="#RabbitMQ交换机有哪些" class="headerlink" title="RabbitMQ交换机有哪些"></a>RabbitMQ交换机有哪些</h4><p>TODO</p>
<h4 id="RabbitMQ如何顺序消费"><a href="#RabbitMQ如何顺序消费" class="headerlink" title="RabbitMQ如何顺序消费"></a>RabbitMQ如何顺序消费</h4><ul>
<li>MQ的队列是有序的，但是消费组可能速度不同，需要只留一个消费者。如果需要绝对顺序，则不可开启普通线程池避免消费时乱序</li>
</ul>
<h2 id="Cache-相关"><a href="#Cache-相关" class="headerlink" title="Cache 相关"></a>Cache 相关</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis-的String-是如何实现的"><a href="#Redis-的String-是如何实现的" class="headerlink" title="Redis 的String 是如何实现的"></a>Redis 的String 是如何实现的</h4><p>TODO</p>
<h4 id="Redis-GEOSEARCH数据结构怎样的，底层实现"><a href="#Redis-GEOSEARCH数据结构怎样的，底层实现" class="headerlink" title="Redis GEOSEARCH数据结构怎样的，底层实现"></a>Redis GEOSEARCH数据结构怎样的，底层实现</h4><p>TODO</p>
<h4 id="Set底层结构是什-hyperloglogs了解吗"><a href="#Set底层结构是什-hyperloglogs了解吗" class="headerlink" title="Set底层结构是什? hyperloglogs了解吗?"></a>Set底层结构是什? hyperloglogs了解吗?</h4><p>TODO</p>
<h4 id="Redis-Hash与Java-HashMap区别"><a href="#Redis-Hash与Java-HashMap区别" class="headerlink" title="Redis Hash与Java HashMap区别"></a>Redis Hash与Java HashMap区别</h4><p>TODO</p>
<h4 id="Redis主从、哨兵和集群区别"><a href="#Redis主从、哨兵和集群区别" class="headerlink" title="Redis主从、哨兵和集群区别"></a>Redis主从、哨兵和集群区别</h4><ul>
<li><p>主从</p>
<p>主从复制，读写分离。但不能自动恢复</p>
</li>
<li><p>哨兵</p>
<p>哨兵选举可以自动恢复，着眼于高可用。但不能解决负载均衡问题</p>
</li>
<li><p>集群</p>
<p>着眼于高并发，可以解决负载均衡问题，方案是slot，通过一致性哈希算法将数据分散在不同的slot中 16384个slot</p>
</li>
</ul>
<h4 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h4><ul>
<li>事务是一个单独的隔离操作：事务中所有命令都序列化、顺序执行。执行过程中不会被其他命令打断</li>
<li>事务是一个原子操作：要么全部执行，要么全部不执行</li>
<li>MULTI、EXEC、DISCARD、WATCH</li>
</ul>
<h4 id="Redis为什么是原子性的"><a href="#Redis为什么是原子性的" class="headerlink" title="Redis为什么是原子性的"></a>Redis为什么是原子性的</h4><ul>
<li><p>单线程操作数据</p>
</li>
<li><p>Redis 提供事务支持，允许将多个命令作为单个原子操作执行。 </p>
<p>Redis 事务使用 MULTI 和 EXEC 命令将命令组合在一起并将它们作为单个事务执行。如果事务中的任何命令失败，则回滚整个事务，确保整个事务的原子性。</p>
</li>
</ul>
<h4 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h4><ul>
<li>内存存储</li>
<li>IO多路调用epoll网络模型</li>
<li>单线程查询数据，减少切换CPU分片耗时</li>
<li>数据结构优化</li>
</ul>
<h4 id="Redis底层实现"><a href="#Redis底层实现" class="headerlink" title="Redis底层实现"></a>Redis底层实现</h4><p>TODO</p>
<h4 id="Redis如何更新缓存"><a href="#Redis如何更新缓存" class="headerlink" title="Redis如何更新缓存"></a>Redis如何更新缓存</h4><p>TODO</p>
<h4 id="Redis如何内存优化"><a href="#Redis如何内存优化" class="headerlink" title="Redis如何内存优化"></a>Redis如何内存优化</h4><ul>
<li>尽可能使用Hashes，它使用内存非常小</li>
</ul>
<h4 id="Redis数据一致性怎么做的"><a href="#Redis数据一致性怎么做的" class="headerlink" title="Redis数据一致性怎么做的"></a>Redis数据一致性怎么做的</h4><p>TODO</p>
<h4 id="Redis-Hashtable-如何扩容的"><a href="#Redis-Hashtable-如何扩容的" class="headerlink" title="Redis Hashtable 如何扩容的"></a>Redis Hashtable 如何扩容的</h4><p>TODO</p>
<h4 id="为什么要设计Redis-Slot结构，如何查找数据"><a href="#为什么要设计Redis-Slot结构，如何查找数据" class="headerlink" title="为什么要设计Redis Slot结构，如何查找数据"></a>为什么要设计Redis Slot结构，如何查找数据</h4><p>TODO</p>
<h4 id="Redis的哈希槽算法和哈希一致性算法"><a href="#Redis的哈希槽算法和哈希一致性算法" class="headerlink" title="Redis的哈希槽算法和哈希一致性算法"></a>Redis的哈希槽算法和哈希一致性算法</h4><p>TODO</p>
<h4 id="Redis-rehash过程中，旧hash数据被访问后会把该数据Copy到新表，这个过程是以单条数据为粒度还是以桶为粒度拷贝的"><a href="#Redis-rehash过程中，旧hash数据被访问后会把该数据Copy到新表，这个过程是以单条数据为粒度还是以桶为粒度拷贝的" class="headerlink" title="Redis rehash过程中，旧hash数据被访问后会把该数据Copy到新表，这个过程是以单条数据为粒度还是以桶为粒度拷贝的"></a>Redis rehash过程中，旧hash数据被访问后会把该数据Copy到新表，这个过程是以单条数据为粒度还是以桶为粒度拷贝的</h4><ul>
<li>以桶为单位</li>
<li>即使桶数据很大，它也是以默认10个key为单位复制，避免其他指令阻塞。</li>
<li>可以通过<code>hash-max-ziplist-entries</code> 和 <code>hash-max-ziplist-value</code>命令更改批次量</li>
</ul>
<h4 id="如何找出Redis中的慢查询记录"><a href="#如何找出Redis中的慢查询记录" class="headerlink" title="如何找出Redis中的慢查询记录"></a>如何找出Redis中的慢查询记录</h4><ul>
<li>redis设置slowlog-log-slower-than、 slowlog-max-len两个参数</li>
<li>slowlog get 查看</li>
<li>redis慢日志的删除采用 <strong>先进先出</strong> 的方式</li>
</ul>
<h4 id="Redis-List过大如何优化"><a href="#Redis-List过大如何优化" class="headerlink" title="Redis List过大如何优化"></a>Redis List过大如何优化</h4><ul>
<li>分片</li>
</ul>
<h4 id="你们是如何对Redis进行性能优化的"><a href="#你们是如何对Redis进行性能优化的" class="headerlink" title="你们是如何对Redis进行性能优化的"></a>你们是如何对Redis进行性能优化的</h4><ul>
<li>Key尽量短</li>
<li>数据尽量小</li>
<li>不使用lrange之类命令查询</li>
<li>设置Key生命周期</li>
<li>选择默认LRU策略</li>
</ul>
<h4 id="为什么-使用-Redis-而不是用-Memcached"><a href="#为什么-使用-Redis-而不是用-Memcached" class="headerlink" title="为什么 使用 Redis 而不是用 Memcached"></a>为什么 使用 Redis 而不是用 Memcached</h4><ul>
<li>Redis可以持久化数据</li>
<li>速度更快</li>
<li>支持数据结构更多，Memcached只支持字符串，Redis支持String，Hash，List，Set，ZSet，以及BitMap、Geospatial、Hyperloglog</li>
</ul>
<h4 id="Redis的Set底层什么时候是Hash什么时候是跳表"><a href="#Redis的Set底层什么时候是Hash什么时候是跳表" class="headerlink" title="Redis的Set底层什么时候是Hash什么时候是跳表"></a>Redis的Set底层什么时候是Hash什么时候是跳表</h4><p>TODO</p>
<h4 id="ZSet数据结构以及空间复杂度"><a href="#ZSet数据结构以及空间复杂度" class="headerlink" title="ZSet数据结构以及空间复杂度"></a>ZSet数据结构以及空间复杂度</h4><p>TODO</p>
<h4 id="跳跃列表原理怎么实现"><a href="#跳跃列表原理怎么实现" class="headerlink" title="跳跃列表原理怎么实现"></a>跳跃列表原理怎么实现</h4><p>TODO</p>
<h4 id="quickList和zipList原理"><a href="#quickList和zipList原理" class="headerlink" title="quickList和zipList原理"></a>quickList和zipList原理</h4><p>TODO</p>
<h4 id="zipList时间复杂度"><a href="#zipList时间复杂度" class="headerlink" title="zipList时间复杂度"></a>zipList时间复杂度</h4><p>TODO</p>
<h4 id="Redis怎么做限流"><a href="#Redis怎么做限流" class="headerlink" title="Redis怎么做限流"></a>Redis怎么做限流</h4><p>TODO</p>
<p>redis 的zset 滑动窗口限流，顺便说了一下漏桶和令牌桶</p>
<h4 id="Redis异步消息怎么处理"><a href="#Redis异步消息怎么处理" class="headerlink" title="Redis异步消息怎么处理"></a>Redis异步消息怎么处理</h4><p>TODO</p>
<h4 id="Redis-5-0-新增Stream对它有什么理解"><a href="#Redis-5-0-新增Stream对它有什么理解" class="headerlink" title="Redis 5.0 新增Stream对它有什么理解"></a>Redis 5.0 新增Stream对它有什么理解</h4><p>TODO</p>
<h4 id="为什么redis7用listpack取代ziplist"><a href="#为什么redis7用listpack取代ziplist" class="headerlink" title="为什么redis7用listpack取代ziplist"></a>为什么redis7用listpack取代ziplist</h4><p>TODO</p>
<h4 id="大批量删除Redis-key导致Redis不稳定如何解决"><a href="#大批量删除Redis-key导致Redis不稳定如何解决" class="headerlink" title="大批量删除Redis key导致Redis不稳定如何解决"></a>大批量删除Redis key导致Redis不稳定如何解决</h4><ul>
<li>开启 lazy-free<ul>
<li>lazyfree-lazy-eviction：当 redis 内存达到阈值 maxmemory 时，将执行内存淘汰</li>
<li>lazyfree-lazy-expire：当设置了过期 key 的过期时间到了，将删除 key</li>
<li>lazyfree-lazy-server-del：这种主要用户提交 del 删除指令</li>
<li>replica-lazy-flush：主要用于复制过程中，全量同步的场景，从节点需要删除整个 db</li>
</ul>
</li>
</ul>
<h4 id="如何保证Redis高并发、高可用"><a href="#如何保证Redis高并发、高可用" class="headerlink" title="如何保证Redis高并发、高可用"></a>如何保证Redis高并发、高可用</h4><ul>
<li>集群Slot</li>
</ul>
<h4 id="Redis持久化机制，以及优缺点"><a href="#Redis持久化机制，以及优缺点" class="headerlink" title="Redis持久化机制，以及优缺点"></a>Redis持久化机制，以及优缺点</h4><ul>
<li><p>RDB 快照方式半持久化记录，循环时间点替换临时文件</p>
<ul>
<li><p>优点</p>
<p>只有一个dump.rdf方便持久化</p>
<p>容灾性好，一个文件可以保持到安全的磁盘</p>
<p>性能最大化，fork子进程完成写操作，让主进程持续处理命令，IO最大化</p>
<p>数据集大时，比AOF启动效率高</p>
</li>
<li><p>缺点</p>
<p>数据安全性低，如果发生一次故障丢失临时文件，则全部丢失</p>
</li>
</ul>
</li>
<li><p>AOF 所有命令行记录以redis命令请求协议歌手完全存储</p>
<ul>
<li><p>优点</p>
<p>数据安全，aways&#x2F;seconds&#x2F;times</p>
<p>append追加写入，宕机可以少丢数据，且可以提高redis-check-aof工具解决数据一致性问题</p>
<p>rewrite模式，可以优化合并指令</p>
</li>
<li><p>缺点</p>
<p>AOF文件比RDB大，且恢复速度慢</p>
<p>数据集大时，比RDB启动效率低</p>
</li>
</ul>
</li>
</ul>
<h4 id="AOF的文件特别大的时候有什么解决办法"><a href="#AOF的文件特别大的时候有什么解决办法" class="headerlink" title="AOF的文件特别大的时候有什么解决办法"></a>AOF的文件特别大的时候有什么解决办法</h4><p>TODO</p>
<h4 id="Redis回收进程如何工作"><a href="#Redis回收进程如何工作" class="headerlink" title="Redis回收进程如何工作"></a>Redis回收进程如何工作</h4><ul>
<li>每次添加信数据时允许，检查maxmemory限制，大于则根据测量回收</li>
</ul>
<h4 id="雪崩、穿透、击穿问题怎么解决"><a href="#雪崩、穿透、击穿问题怎么解决" class="headerlink" title="雪崩、穿透、击穿问题怎么解决"></a>雪崩、穿透、击穿问题怎么解决</h4><ul>
<li>雪崩，不同过期时间</li>
<li>穿透，即查询不存在数据。无数据时设定假数据，有时进行更新</li>
<li>击穿，互斥锁</li>
</ul>
<h4 id="Bloom过滤器原理"><a href="#Bloom过滤器原理" class="headerlink" title="Bloom过滤器原理"></a>Bloom过滤器原理</h4><p>TODO</p>
<h4 id="Redis的内存用完了会发生什么"><a href="#Redis的内存用完了会发生什么" class="headerlink" title="Redis的内存用完了会发生什么"></a>Redis的内存用完了会发生什么</h4><ul>
<li>新增报错，但旧数据可查询</li>
<li>等待Key过期与LRU删除</li>
</ul>
<h4 id="在项目里面缓存是怎么用的"><a href="#在项目里面缓存是怎么用的" class="headerlink" title="在项目里面缓存是怎么用的"></a>在项目里面缓存是怎么用的</h4><ul>
<li>修改频次低的数据缓存到Redis进行快速查询反馈，权限模块功能权限的缓存</li>
<li>队列使用，redission.getBlockingQueue(queueName)，多节点消费使用同一中间件新增List数据判定是否全部处理，出库模块</li>
<li>redission锁，高并发修改数据时进行锁定</li>
</ul>
<h4 id="用Redis实现一个成绩的排序"><a href="#用Redis实现一个成绩的排序" class="headerlink" title="用Redis实现一个成绩的排序"></a>用Redis实现一个成绩的排序</h4><ul>
<li>Sorted Set</li>
</ul>
<h4 id="Redis-大key删除时容易把redis-搞崩，怎么解决"><a href="#Redis-大key删除时容易把redis-搞崩，怎么解决" class="headerlink" title="Redis 大key删除时容易把redis 搞崩，怎么解决"></a>Redis 大key删除时容易把redis 搞崩，怎么解决</h4><p>TODO</p>
<h4 id="高并发下，redis和mysql双写一致性如何保证"><a href="#高并发下，redis和mysql双写一致性如何保证" class="headerlink" title="高并发下，redis和mysql双写一致性如何保证"></a>高并发下，redis和mysql双写一致性如何保证</h4><ul>
<li>旁路缓存读写模式</li>
</ul>
<h4 id="Redis-Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致"><a href="#Redis-Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致" class="headerlink" title="Redis Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致"></a>Redis Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致</h4><p>TODO</p>
<h4 id="Redis-存在线程安全问题吗"><a href="#Redis-存在线程安全问题吗" class="headerlink" title="Redis 存在线程安全问题吗"></a>Redis 存在线程安全问题吗</h4><ul>
<li>不存在，主线程处理数据，其他线程处理网络IO</li>
</ul>
<h4 id="Redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h4><p>TODO</p>
<p>答：Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h4 id="一个字符串类型的值能存储最大容量是多少"><a href="#一个字符串类型的值能存储最大容量是多少" class="headerlink" title="一个字符串类型的值能存储最大容量是多少"></a>一个字符串类型的值能存储最大容量是多少</h4><ul>
<li>512M</li>
</ul>
<h4 id="PipeLine好处"><a href="#PipeLine好处" class="headerlink" title="PipeLine好处"></a>PipeLine好处</h4><ul>
<li>将多次IO往返时间缩减为一次，前提是pipeline执行的指令直接没有因果关系性</li>
</ul>
<h4 id="Redis-大量Key集中过期，为什么这时访问Redis其他Key有延迟"><a href="#Redis-大量Key集中过期，为什么这时访问Redis其他Key有延迟" class="headerlink" title="Redis 大量Key集中过期，为什么这时访问Redis其他Key有延迟"></a>Redis 大量Key集中过期，为什么这时访问Redis其他Key有延迟</h4><ul>
<li>单线程问题导致。Redis必须在数据过期清理任务结束后才能响应后续访问任务，因此会导致访问延迟</li>
<li>过期策略<ul>
<li>主动过期：LRU删除，每100ms挑20个Key，如果过期比例超25%则循环删除直至比例低于25%或当前任务时间时间超过25ms才退出循环</li>
<li>懒惰过期：访问到Key时如果过期则删除</li>
</ul>
</li>
</ul>
<h4 id="系统在10：05-设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在"><a href="#系统在10：05-设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在" class="headerlink" title="系统在10：05 设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在"></a>系统在10：05 设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在</h4><ul>
<li><p>未开启备份状态下，或落盘处于时间差，则不存在</p>
</li>
<li><p>开启备份状态且成功状态下</p>
<ul>
<li><p>AOF</p>
<p>当Key过期时，追加del key语句，由于从宕机中恢复，没有追加语句，Key会存在</p>
<p>主启动：存在，但LRU或惰性删除，当第一次访问时删除并返回nil</p>
<p>从启动：根据Master当前状态删除，如果访问到slave节点，会获取过期数据</p>
</li>
<li><p>RDB</p>
<p>主启动，忽略已过期的Key</p>
<p>从启动，不忽略，但是LRU惰性删除</p>
</li>
</ul>
</li>
</ul>
<h4 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据</h4><ul>
<li><p>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略</p>
<p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p>
<p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
</li>
</ul>
<h4 id="Redis-Cluster数据库"><a href="#Redis-Cluster数据库" class="headerlink" title="Redis Cluster数据库"></a>Redis Cluster数据库</h4><ul>
<li>无法选择，默认0数据库</li>
</ul>
<h4 id="基于-Redis-的分布式锁会有什么问题"><a href="#基于-Redis-的分布式锁会有什么问题" class="headerlink" title="基于 Redis 的分布式锁会有什么问题"></a>基于 Redis 的分布式锁会有什么问题</h4><p>TODO</p>
<p>主从模型下同步不保证一致会导致锁失效</p>
<h4 id="Redis-分布式锁超时可以超时时间设长一点可以吗？不可以的话需要怎么解决？"><a href="#Redis-分布式锁超时可以超时时间设长一点可以吗？不可以的话需要怎么解决？" class="headerlink" title="Redis 分布式锁超时可以超时时间设长一点可以吗？不可以的话需要怎么解决？"></a>Redis 分布式锁超时可以超时时间设长一点可以吗？不可以的话需要怎么解决？</h4><p>TODO</p>
<h4 id="Redis-锁续期这个怎么实现"><a href="#Redis-锁续期这个怎么实现" class="headerlink" title="Redis 锁续期这个怎么实现"></a>Redis 锁续期这个怎么实现</h4><p>TODO</p>
<h4 id="在主从模式和-Redis-Cluster-中分布式锁会有什么问题"><a href="#在主从模式和-Redis-Cluster-中分布式锁会有什么问题" class="headerlink" title="在主从模式和 Redis Cluster 中分布式锁会有什么问题"></a>在主从模式和 Redis Cluster 中分布式锁会有什么问题</h4><p>TODO</p>
<h3 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h3><h4 id="Redis-Hash-Slot概念"><a href="#Redis-Hash-Slot概念" class="headerlink" title="Redis Hash Slot概念"></a>Redis Hash Slot概念</h4><ul>
<li>Redis Cluster没有使用一致性hash，而是引入Hash Slot概念，共16384个槽，每个Key提高CRC16校验后对16384取模决定放在哪个Slot</li>
</ul>
<h4 id="Redis-分布式锁怎么实现的"><a href="#Redis-分布式锁怎么实现的" class="headerlink" title="Redis 分布式锁怎么实现的"></a>Redis 分布式锁怎么实现的</h4><ul>
<li>SETNX</li>
<li>RedLock</li>
</ul>
<h4 id="Redis-分布式锁和-zookeeper-分布式锁区别"><a href="#Redis-分布式锁和-zookeeper-分布式锁区别" class="headerlink" title="Redis 分布式锁和 zookeeper 分布式锁区别"></a>Redis 分布式锁和 zookeeper 分布式锁区别</h4><ul>
<li>CA</li>
<li>CP</li>
</ul>
<h4 id="RedLock红锁算法"><a href="#RedLock红锁算法" class="headerlink" title="RedLock红锁算法"></a>RedLock红锁算法</h4><ul>
<li>N&#x2F;2+1</li>
</ul>
<h4 id="Redission细节源码"><a href="#Redission细节源码" class="headerlink" title="Redission细节源码"></a>Redission细节源码</h4><p>TODO</p>
<h4 id="分布式锁超时问题怎么解决"><a href="#分布式锁超时问题怎么解决" class="headerlink" title="分布式锁超时问题怎么解决"></a>分布式锁超时问题怎么解决</h4><ul>
<li>Watchdog</li>
</ul>
<h2 id="DataBase相关"><a href="#DataBase相关" class="headerlink" title="DataBase相关"></a>DataBase相关</h2><h4 id="如何设计数据库"><a href="#如何设计数据库" class="headerlink" title="如何设计数据库"></a>如何设计数据库</h4><p>TODO</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="OLTP与OLAP联系与区别"><a href="#OLTP与OLAP联系与区别" class="headerlink" title="OLTP与OLAP联系与区别"></a>OLTP与OLAP联系与区别</h4><p>TODO</p>
<h4 id="索引优化如何实现"><a href="#索引优化如何实现" class="headerlink" title="索引优化如何实现"></a>索引优化如何实现</h4><p>TODO</p>
<h4 id="主键是什么，有什么特性"><a href="#主键是什么，有什么特性" class="headerlink" title="主键是什么，有什么特性"></a>主键是什么，有什么特性</h4><p>TODO</p>
<h3 id="MyBatis相关"><a href="#MyBatis相关" class="headerlink" title="MyBatis相关"></a>MyBatis相关</h3><h4 id="MyBatis传参方式、动态标签"><a href="#MyBatis传参方式、动态标签" class="headerlink" title="MyBatis传参方式、动态标签"></a>MyBatis传参方式、动态标签</h4><p>TODO</p>
<h4 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h4><p>区分一级缓存和二级缓存</p>
<ul>
<li><p>一级缓存</p>
<p>强制开启，同一事务同一语句优先命中一级缓存。</p>
<p>执行参数通过算法生成Cache-Key，结果为Value，存储结构为Map</p>
<p>任何Update、Insert、Delete语句都会清除缓存</p>
</li>
<li><p>二级缓存</p>
<p>非强制开启，外部存储介质，以不同NameSpace隔离。</p>
<p>多Instance状态下，应用A更改 NameSpace-A缓存，不会变更NameSpace-B缓存，当应用B访问会获得错误结果</p>
<p>不建议开启</p>
</li>
</ul>
<h4 id="MyBatis-mapper方法名可以一样吗"><a href="#MyBatis-mapper方法名可以一样吗" class="headerlink" title="MyBatis mapper方法名可以一样吗"></a>MyBatis mapper方法名可以一样吗</h4><ul>
<li>可以，使用的是全限定名称</li>
</ul>
<h4 id="MyBatis配置文件"><a href="#MyBatis配置文件" class="headerlink" title="MyBatis配置文件"></a>MyBatis配置文件</h4><p>TODO</p>
<h4 id="MyBatis比JDBC有什么优势"><a href="#MyBatis比JDBC有什么优势" class="headerlink" title="MyBatis比JDBC有什么优势"></a>MyBatis比JDBC有什么优势</h4><ul>
<li>减少JDBC冗余代码，由MyBatis管理开关连接</li>
<li>不可以在XML编写SQL，改变SQL不需重新编译</li>
</ul>
<h4 id="MyBatis如何映射"><a href="#MyBatis如何映射" class="headerlink" title="MyBatis如何映射"></a>MyBatis如何映射</h4><p>TODO</p>
<h4 id="MyBatis的运行流程"><a href="#MyBatis的运行流程" class="headerlink" title="MyBatis的运行流程"></a>MyBatis的运行流程</h4><p>TODO</p>
<h4 id="MyBatis原理"><a href="#MyBatis原理" class="headerlink" title="MyBatis原理"></a>MyBatis原理</h4><p>TODO</p>
<h4 id="MyBatis如何分页"><a href="#MyBatis如何分页" class="headerlink" title="MyBatis如何分页"></a>MyBatis如何分页</h4><p>TODO</p>
<h4 id="MyBatis如何解决SQL注入问题"><a href="#MyBatis如何解决SQL注入问题" class="headerlink" title="MyBatis如何解决SQL注入问题"></a>MyBatis如何解决SQL注入问题</h4><ul>
<li>#占位符</li>
<li>PreparedStatement预编译</li>
</ul>
<h4 id="什么是数据库连接池，为什么要连接池"><a href="#什么是数据库连接池，为什么要连接池" class="headerlink" title="什么是数据库连接池，为什么要连接池"></a>什么是数据库连接池，为什么要连接池</h4><p>TODO</p>
<h4 id="MyBatis-和hibernate的区别"><a href="#MyBatis-和hibernate的区别" class="headerlink" title="MyBatis 和hibernate的区别"></a>MyBatis 和hibernate的区别</h4><p>TODO</p>
<h4 id="数据字典是什么"><a href="#数据字典是什么" class="headerlink" title="数据字典是什么"></a>数据字典是什么</h4><p>TODO</p>
<h4 id="MyBatis出现连接超时如何排查"><a href="#MyBatis出现连接超时如何排查" class="headerlink" title="MyBatis出现连接超时如何排查"></a>MyBatis出现连接超时如何排查</h4><p>TODO</p>
<h4 id="MyBatis默认连接数是多少"><a href="#MyBatis默认连接数是多少" class="headerlink" title="MyBatis默认连接数是多少"></a>MyBatis默认连接数是多少</h4><p>TODO</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="IP地址如何在数据库中存储"><a href="#IP地址如何在数据库中存储" class="headerlink" title="IP地址如何在数据库中存储"></a>IP地址如何在数据库中存储</h4><ul>
<li><p>32位UNSIGNED INT类型存储</p>
</li>
<li><p>节省空间，不管是数据存储空间，还是索引存储空间</p>
</li>
<li><p>便于使用范围查询（BETWEEN…AND），且效率更高</p>
</li>
<li><p>Java代码中的 移位操作 和 &amp; 计算</p>
</li>
<li><p>MYSQL 命令 inet_aton() 命令将IP字符串转化为数字类型，inet_ntoa 命令将数字转化为字符串IP</p>
</li>
</ul>
<h4 id="MySQL中-和-是什么区别"><a href="#MySQL中-和-是什么区别" class="headerlink" title="MySQL中#和$是什么区别"></a>MySQL中#和$是什么区别</h4><ul>
<li><p>#是占位符，传入数据会加入””</p>
<p>$是拼接符，不处理传入数据，可能会数据注入</p>
</li>
<li><p>建议使用#</p>
</li>
</ul>
<h4 id="MySQL中char和varchar的区别"><a href="#MySQL中char和varchar的区别" class="headerlink" title="MySQL中char和varchar的区别"></a>MySQL中char和varchar的区别</h4><ul>
<li>char固定长度255，varchar可变长度65535，理论查询效率char更高，但尾部空格插入时丢弃，不足长度会补齐，建议不变长度字段使用</li>
<li>InnoDB建议varchar，所有数据都适用指向数据列的头指针</li>
</ul>
<h4 id="普通索引和唯一索引的效率比较"><a href="#普通索引和唯一索引的效率比较" class="headerlink" title="普通索引和唯一索引的效率比较"></a>普通索引和唯一索引的效率比较</h4><ul>
<li>查询：唯一索引比普通索引快<ul>
<li>唯一索引只有一条，找到所属页二分法查询到第一条即结束</li>
<li>普通索引有多条，会一直向下查询</li>
</ul>
</li>
<li>写入：普通索引比唯一索引快<ul>
<li>唯一索引需验证唯一性，因此需要先进行数据查询才可写入</li>
<li>change buffer缓存的是非唯一索引数据，对于唯一索引内容必须需要磁盘IO检查数据唯唯一性</li>
</ul>
</li>
</ul>
<h4 id="深度很高的树结构如何存入数据库"><a href="#深度很高的树结构如何存入数据库" class="headerlink" title="深度很高的树结构如何存入数据库"></a>深度很高的树结构如何存入数据库</h4><p>TODO</p>
<h4 id="一个大型表如何移动到另一个表上"><a href="#一个大型表如何移动到另一个表上" class="headerlink" title="一个大型表如何移动到另一个表上"></a>一个大型表如何移动到另一个表上</h4><p>TODO</p>
<h4 id="SQL查询突然变慢如何分析"><a href="#SQL查询突然变慢如何分析" class="headerlink" title="SQL查询突然变慢如何分析"></a>SQL查询突然变慢如何分析</h4><ul>
<li>DB CPU是否高峰期</li>
<li>慢SQL查询，processlist</li>
</ul>
<h4 id="为什么不推荐SLECT-FROM"><a href="#为什么不推荐SLECT-FROM" class="headerlink" title="为什么不推荐SLECT * FROM"></a>为什么不推荐SLECT * FROM</h4><ul>
<li>字段多</li>
<li>执行期优化，全表扫描</li>
</ul>
<h4 id="SQL如何有效使用复合索引"><a href="#SQL如何有效使用复合索引" class="headerlink" title="SQL如何有效使用复合索引"></a>SQL如何有效使用复合索引</h4><ul>
<li>最左匹配</li>
</ul>
<h4 id="Exist和in的区别"><a href="#Exist和in的区别" class="headerlink" title="Exist和in的区别"></a>Exist和in的区别</h4><p>TODO</p>
<h4 id="主键索引唯一索引区别"><a href="#主键索引唯一索引区别" class="headerlink" title="主键索引唯一索引区别"></a>主键索引唯一索引区别</h4><ul>
<li>Primary Key唯一，Not Null</li>
<li>Unique 针对字段，可以为Null</li>
</ul>
<h4 id="千万DB数据分页怎么处理"><a href="#千万DB数据分页怎么处理" class="headerlink" title="千万DB数据分页怎么处理"></a>千万DB数据分页怎么处理</h4><ul>
<li>主键处理，记录上一次最大&#x2F;最小主键，<code>Where id &gt; primary key value</code></li>
</ul>
<h4 id="怎样防止SQL注入"><a href="#怎样防止SQL注入" class="headerlink" title="怎样防止SQL注入"></a>怎样防止SQL注入</h4><ul>
<li># 占位符</li>
<li>手动处理</li>
</ul>
<h4 id="SQL查询的索引覆盖"><a href="#SQL查询的索引覆盖" class="headerlink" title="SQL查询的索引覆盖"></a>SQL查询的索引覆盖</h4><ul>
<li>二级索引，包含所有需要字段，不回表直接返回</li>
</ul>
<h4 id="数据库索引的实现，为什么选择这个实现"><a href="#数据库索引的实现，为什么选择这个实现" class="headerlink" title="数据库索引的实现，为什么选择这个实现"></a>数据库索引的实现，为什么选择这个实现</h4><p>TODO</p>
<h4 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h4><p>TODO</p>
<h4 id="MySQL索引数据结构，B-TREE与二叉树对比"><a href="#MySQL索引数据结构，B-TREE与二叉树对比" class="headerlink" title="MySQL索引数据结构，B-TREE与二叉树对比"></a>MySQL索引数据结构，B-TREE与二叉树对比</h4><ul>
<li>B+Tree</li>
<li>B-Tree指针数据都在一起，B+Tree非叶子节点存储指针和Primary Key，叶子节点存储数据</li>
<li>二叉树层数高，且可能形成链表</li>
</ul>
<h4 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h4><ul>
<li>唯一索引保证数据唯一</li>
<li>为业务常用字段建立索引</li>
<li>尽量使用数据内容少的字段作索引</li>
<li>索引尽量5个以内</li>
<li>删除不再使用的索引</li>
</ul>
<h4 id="表设计原则"><a href="#表设计原则" class="headerlink" title="表设计原则"></a>表设计原则</h4><ul>
<li>符合三大范式</li>
<li>减少使用大量空间</li>
<li>避免冗余数据</li>
<li>使用所以</li>
<li>避免联合查询</li>
<li>使用合适数据类型</li>
<li>考虑并发控制</li>
<li>考虑数据访问方式</li>
<li>考虑数据安全性</li>
</ul>
<h4 id="联合索引什么时候使用"><a href="#联合索引什么时候使用" class="headerlink" title="联合索引什么时候使用"></a>联合索引什么时候使用</h4><ul>
<li>同时查询多个列</li>
<li>高并发的表，曾经联合索引可以减少锁冲突，提高效率</li>
<li>范围查询，如果联合索引第一列被用于筛选数据，则会利用索引提高效率</li>
</ul>
<p>不一定比单列更快，不应该包含过多的列，顺序很重要</p>
<h4 id="SQL语句执行关键字顺序"><a href="#SQL语句执行关键字顺序" class="headerlink" title="SQL语句执行关键字顺序"></a>SQL语句执行关键字顺序</h4><ol>
<li>SELECT：查询需要返回的列。</li>
<li>FROM：指定数据表，视图或子查询。</li>
<li>WHERE：指定查询条件。</li>
<li>GROUP BY：按照指定列对结果集进行分组。</li>
<li>HAVING：对分组后的结果进行条件过滤。</li>
<li>ORDER BY：对查询结果进行排序。</li>
<li>LIMIT：限制结果集的返回数量。</li>
</ol>
<h4 id="MySQL的最左匹配原则是利用了B-树的什么特性"><a href="#MySQL的最左匹配原则是利用了B-树的什么特性" class="headerlink" title="MySQL的最左匹配原则是利用了B+树的什么特性"></a>MySQL的最左匹配原则是利用了B+树的什么特性</h4><p>TODO</p>
<h4 id="JOIN的实现原理"><a href="#JOIN的实现原理" class="headerlink" title="JOIN的实现原理"></a>JOIN的实现原理</h4><p>TODO</p>
<h4 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h4><p>TODO</p>
<h4 id="MySQL-范围查询原理"><a href="#MySQL-范围查询原理" class="headerlink" title="MySQL 范围查询原理"></a>MySQL 范围查询原理</h4><ul>
<li>聚簇索引，主键指针从左到右</li>
</ul>
<h4 id="MySQL存储引擎？MyISAM与InnoDB区别？"><a href="#MySQL存储引擎？MyISAM与InnoDB区别？" class="headerlink" title="MySQL存储引擎？MyISAM与InnoDB区别？"></a>MySQL存储引擎？MyISAM与InnoDB区别？</h4><ul>
<li>InnoDB</li>
<li>MyISAM 表锁，查询快，指针数据分离</li>
<li>InnoDB 行锁 B+ Tree，事务，指针数据聚合</li>
</ul>
<h4 id="只用主键ID查找时-B-Tree和B-Tree哪个快"><a href="#只用主键ID查找时-B-Tree和B-Tree哪个快" class="headerlink" title="只用主键ID查找时 B+Tree和B-Tree哪个快"></a>只用主键ID查找时 B+Tree和B-Tree哪个快</h4><ul>
<li>B+Tree与B-Tree都是树结构，都只需要进行节点的查找和比较操作，查询速度较为接近</li>
<li>但是B+Tree叶子节点更稠密，因此B+Tree可能更快</li>
</ul>
<h4 id="B-Tree树节点具体存什么"><a href="#B-Tree树节点具体存什么" class="headerlink" title="B+Tree树节点具体存什么"></a>B+Tree树节点具体存什么</h4><p>TODO</p>
<h4 id="B-树是数据的顺序一定是从左到右递增的么"><a href="#B-树是数据的顺序一定是从左到右递增的么" class="headerlink" title="B+树是数据的顺序一定是从左到右递增的么"></a>B+树是数据的顺序一定是从左到右递增的么</h4><p>TODO</p>
<h4 id="页分裂伪代码，B-树的倒数底层层可以页分裂么"><a href="#页分裂伪代码，B-树的倒数底层层可以页分裂么" class="headerlink" title="页分裂伪代码，B+树的倒数底层层可以页分裂么"></a>页分裂伪代码，B+树的倒数底层层可以页分裂么</h4><p>TODO</p>
<h4 id="MySQL一页最大存多少数据"><a href="#MySQL一页最大存多少数据" class="headerlink" title="MySQL一页最大存多少数据"></a>MySQL一页最大存多少数据</h4><ul>
<li>16K</li>
</ul>
<h4 id="B-树3层的话可以存放多少量级的数据"><a href="#B-树3层的话可以存放多少量级的数据" class="headerlink" title="B+树3层的话可以存放多少量级的数据"></a>B+树3层的话可以存放多少量级的数据</h4><p>TODO</p>
<h4 id="如何优化MySQL的页分裂算法"><a href="#如何优化MySQL的页分裂算法" class="headerlink" title="如何优化MySQL的页分裂算法"></a>如何优化MySQL的页分裂算法</h4><p>TODO</p>
<h4 id="Mysql中InnoDB中的索引有什么特点"><a href="#Mysql中InnoDB中的索引有什么特点" class="headerlink" title="Mysql中InnoDB中的索引有什么特点"></a>Mysql中InnoDB中的索引有什么特点</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366972218">https://zhuanlan.zhihu.com/p/366972218</a></p>
<p>TODO</p>
<h4 id="InnoDB二次写是什么"><a href="#InnoDB二次写是什么" class="headerlink" title="InnoDB二次写是什么"></a>InnoDB二次写是什么</h4><p>TODO</p>
<h4 id="Mysql中聚簇索引和非聚簇索引的区别"><a href="#Mysql中聚簇索引和非聚簇索引的区别" class="headerlink" title="Mysql中聚簇索引和非聚簇索引的区别"></a>Mysql中聚簇索引和非聚簇索引的区别</h4><ul>
<li><p>聚簇索引</p>
<ul>
<li><p>叶子节点：包含主键、完整数据、数据页指针。</p>
<p>完整数据用于Cover Index查询，其他查询均向Data Block 数据页指针进一步查询数据再返回。原因是MySQL多个引擎，为了保证通用。</p>
</li>
<li><p>非叶子节点：包含主键、数据页指针，用于Range Query</p>
</li>
</ul>
</li>
<li><p>非聚簇索引</p>
<p>二级索引，叶子节点为索引值和对应的主键，非叶子节点为索引值对应的下一节点的指针。非叶子节点需要一直向叶子节点寻找直至找到主键，再在聚簇索引叶子节点获取数据页指针，进行回表查询。</p>
</li>
</ul>
<h4 id="MySQL索引是作用于库还是作用于表"><a href="#MySQL索引是作用于库还是作用于表" class="headerlink" title="MySQL索引是作用于库还是作用于表"></a>MySQL索引是作用于库还是作用于表</h4><ul>
<li>在 MySQL 中，索引是在表上创建的，但它存储在称为索引树的单独数据结构中，该数据结构由数据库引擎管理。所以，你可以说索引作用于表，但它不是表本身的一部分。</li>
<li>当执行涉及带有索引的表的查询时，数据库引擎使用索引来更快地定位数据。这可以显着加快查询性能，尤其是对于大型表。</li>
<li>所以，综上所述，索引在MySQL中是在一张表上创建的，但是是由数据库引擎单独存储和管理的。</li>
</ul>
<h4 id="建立联合索引的时候要注意什么"><a href="#建立联合索引的时候要注意什么" class="headerlink" title="建立联合索引的时候要注意什么"></a>建立联合索引的时候要注意什么</h4><ul>
<li>最左匹配</li>
<li>数据量小</li>
<li>限制字段数目</li>
</ul>
<h4 id="索引下推是什么"><a href="#索引下推是什么" class="headerlink" title="索引下推是什么"></a>索引下推是什么</h4><p>TODO</p>
<h4 id="MySQL执行语句流程"><a href="#MySQL执行语句流程" class="headerlink" title="MySQL执行语句流程"></a>MySQL执行语句流程</h4><ul>
<li>连接器</li>
<li>解析：解析 SQL 查询以检查其语法并确保查询中引用的表和列存在。</li>
<li>缓存：如果之前执行过查询，MySQL 可能会从其查询缓存中检索查询结果，而不是再次执行查询。</li>
<li>优化：查询优化器确定查询的最佳执行计划。它考虑各种因素，如可用索引、表大小和查询类型来优化查询执行计划。</li>
<li>执行：执行优化查询，包括从表中读取数据、应用过滤器和排序以及根据需要连接表。</li>
<li>结果检索：结果集被发送回客户端应用程序，然后客户端应用程序可以处理结果。</li>
</ul>
<h4 id="数据库设计三大范式？开发中应该遵守吗？"><a href="#数据库设计三大范式？开发中应该遵守吗？" class="headerlink" title="数据库设计三大范式？开发中应该遵守吗？"></a>数据库设计三大范式？开发中应该遵守吗？</h4><ul>
<li>第一范式：数据库表的每一列都是不可分割的基本数据项</li>
<li>第二范式：<strong>确保表中的每列都和主键相关【符合1NF，同时非主属性完全依赖于主键】</strong>一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>
<li>第三范式：<strong>确保每列都和主键列直接相关,而不是间接相关【符合2NF，并且消除传递依赖】主键关联，没有其他数据相同，减少冗余</strong></li>
<li>尽量满足，空间换时间（JSON查询等）</li>
</ul>
<h4 id="MySQL乐观锁悲观锁实现"><a href="#MySQL乐观锁悲观锁实现" class="headerlink" title="MySQL乐观锁悲观锁实现"></a>MySQL乐观锁悲观锁实现</h4><ul>
<li>乐观锁</li>
<li>悲观锁</li>
</ul>
<h4 id="MySQL表锁、页面锁、行锁的作用及优缺点？"><a href="#MySQL表锁、页面锁、行锁的作用及优缺点？" class="headerlink" title="MySQL表锁、页面锁、行锁的作用及优缺点？"></a>MySQL表锁、页面锁、行锁的作用及优缺点？</h4><p>TODO</p>
<h4 id="MySQL-5-6-17后加索引时会锁表吗"><a href="#MySQL-5-6-17后加索引时会锁表吗" class="headerlink" title="MySQL 5.6.17后加索引时会锁表吗"></a>MySQL 5.6.17后加索引时会锁表吗</h4><p>TODO</p>
<h4 id="MySQL为什么添加索引或字段时会造成锁表"><a href="#MySQL为什么添加索引或字段时会造成锁表" class="headerlink" title="MySQL为什么添加索引或字段时会造成锁表"></a>MySQL为什么添加索引或字段时会造成锁表</h4><p>TODO</p>
<h4 id="MySQL行锁怎么实现的"><a href="#MySQL行锁怎么实现的" class="headerlink" title="MySQL行锁怎么实现的"></a>MySQL行锁怎么实现的</h4><p>TODO</p>
<h4 id="MySQL-行锁和表锁-互斥吗"><a href="#MySQL-行锁和表锁-互斥吗" class="headerlink" title="MySQL 行锁和表锁 互斥吗"></a>MySQL 行锁和表锁 互斥吗</h4><p>TODO</p>
<h4 id="MySQL读写锁"><a href="#MySQL读写锁" class="headerlink" title="MySQL读写锁"></a>MySQL读写锁</h4><p>TODO</p>
<h4 id="MySQL？什么时候会触发排它锁？"><a href="#MySQL？什么时候会触发排它锁？" class="headerlink" title="MySQL？什么时候会触发排它锁？"></a>MySQL？什么时候会触发排它锁？</h4><p>TODO</p>
<h4 id="MySQL间隙锁是什么"><a href="#MySQL间隙锁是什么" class="headerlink" title="MySQL间隙锁是什么"></a>MySQL间隙锁是什么</h4><p>TODO</p>
<h4 id="数据库什么时候会锁行"><a href="#数据库什么时候会锁行" class="headerlink" title="数据库什么时候会锁行"></a>数据库什么时候会锁行</h4><ul>
<li><p>更新、删除</p>
<p>保证不好有其他会话操作，避免数据出现一致性问题</p>
</li>
<li><p>插入</p>
<p>如果有Primary Key或者Unique Index，会锁定确保其他会话不好插入重复数据</p>
</li>
<li><p>事务</p>
<p>执行事务语句时，会锁涉及到的所有行，确保一致性和完整性</p>
</li>
<li><p>在数据库中，行级锁是最小的锁粒度。如果同时有多个会话需要访问同一个行，那么其中一个会话会获得锁，而其他会话需要等待锁被释放才能访问该行。在高并发的情况下，如果锁的粒度过大，会导致大量的等待，从而影响数据库的性能。因此，在设计数据库时需要考虑好锁的粒度，以确保系统的高并发能力。</p>
</li>
</ul>
<h4 id="MySQL死锁的解决办法"><a href="#MySQL死锁的解决办法" class="headerlink" title="MySQL死锁的解决办法"></a>MySQL死锁的解决办法</h4><p>TODO</p>
<h4 id="MySQL中distinct和group-by性能比较"><a href="#MySQL中distinct和group-by性能比较" class="headerlink" title="MySQL中distinct和group by性能比较"></a>MySQL中distinct和group by性能比较</h4><p>TODO</p>
<h4 id="临键锁只与非唯一索引有关吗？那对主键id做范围查询的时候加的什么锁？比如id-＞7-for-update"><a href="#临键锁只与非唯一索引有关吗？那对主键id做范围查询的时候加的什么锁？比如id-＞7-for-update" class="headerlink" title="临键锁只与非唯一索引有关吗？那对主键id做范围查询的时候加的什么锁？比如id ＞7 for update"></a>临键锁只与非唯一索引有关吗？那对主键id做范围查询的时候加的什么锁？比如id ＞7 for update</h4><p>TODO</p>
<h4 id="你知道MySQL中redo-log、binlog、undo-log-区别与作用？"><a href="#你知道MySQL中redo-log、binlog、undo-log-区别与作用？" class="headerlink" title="你知道MySQL中redo log、binlog、undo log 区别与作用？"></a>你知道MySQL中redo log、binlog、undo log 区别与作用？</h4><ul>
<li>binlog 数据恢复与备份，二进制</li>
<li>redo log 持久化数据，磁盘文件，宕机恢复</li>
<li>undo log 事务恢复数据，原子性与一致性，通过MVCC保证隔离型。Insert语句执行成功后删除，update语句保留</li>
</ul>
<h4 id="SQL优化有哪些着手点"><a href="#SQL优化有哪些着手点" class="headerlink" title="SQL优化有哪些着手点"></a>SQL优化有哪些着手点</h4><ul>
<li>慢查询日志，Explain，业务常用Key索引</li>
</ul>
<h4 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h4><p>TODO</p>
<h4 id="千万数据量的表每日ETL定时同步，如何优化查询"><a href="#千万数据量的表每日ETL定时同步，如何优化查询" class="headerlink" title="千万数据量的表每日ETL定时同步，如何优化查询"></a>千万数据量的表每日ETL定时同步，如何优化查询</h4><p>TODO</p>
<h4 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h4><p>TODO</p>
<h4 id="脏读，不可重复读和幻读主要有什么区别"><a href="#脏读，不可重复读和幻读主要有什么区别" class="headerlink" title="脏读，不可重复读和幻读主要有什么区别"></a>脏读，不可重复读和幻读主要有什么区别</h4><ul>
<li><p>脏读</p>
<p>读到未提交的事务数据</p>
</li>
<li><p>不可重复读</p>
<p>当前事务中读同一条数据内容不一致</p>
</li>
<li><p>幻读</p>
<p>当前事务中，同一条查询语句获得结果数量不一致</p>
</li>
</ul>
<h4 id="MySQL中的GTID是什么"><a href="#MySQL中的GTID是什么" class="headerlink" title="MySQL中的GTID是什么"></a>MySQL中的GTID是什么</h4><ul>
<li>GTID 代表全局事务 ID。在 MySQL 中，GTID 是在数据库服务器上执行的每个事务的唯一标识符。 </li>
<li>GTID 是两部分的组合：执行事务的服务器的唯一服务器 ID，以及为该服务器上的每个事务递增的序列号。</li>
<li>用处<ul>
<li>轻松跟踪复制进度，确保所有服务器都是最新的。</li>
<li>简化的故障转移：如果服务器发生故障，您可以使用 GTID 确定在该服务器上提交了哪些事务，然后在新服务器联机时将这些事务应用到它。</li>
<li>更轻松的架构更改：使用 GTID，您可以在主服务器上执行架构更改，并将这些更改自动复制到所有辅助服务器，而无需担心冲突或丢失事务。</li>
</ul>
</li>
</ul>
<h4 id="GTID可以全局事务，为什么还需Seata"><a href="#GTID可以全局事务，为什么还需Seata" class="headerlink" title="GTID可以全局事务，为什么还需Seata"></a>GTID可以全局事务，为什么还需Seata</h4><ul>
<li>微服务如果所有应用都在同一个DB，可以通过GTID进行全局事务管理</li>
<li>但是微服务一般有多个数据库，跨数据库之间全局事务需要额外Middleware或TCC技术</li>
</ul>
<h4 id="说说你了解的数据库的隔离级别、MVCC"><a href="#说说你了解的数据库的隔离级别、MVCC" class="headerlink" title="说说你了解的数据库的隔离级别、MVCC"></a>说说你了解的数据库的隔离级别、MVCC</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>问题</th>
<th>MVCC作用</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>脏读、不可重复度、幻读</td>
<td>不处理，直接最新数据</td>
</tr>
<tr>
<td>读已提交</td>
<td>不可重复读，幻读</td>
<td>快照读：每个数据读取前都生成一个快照</td>
</tr>
<tr>
<td>可重复度</td>
<td>幻读</td>
<td>快照读：启动事务时生成快照，事务期间都使用该快照</td>
</tr>
<tr>
<td>序列化</td>
<td></td>
<td>加锁串行化访问，不需MVCC处理</td>
</tr>
</tbody></table>
<h4 id="如何实现-MySQL-的读写分离？MySQL-主从复制原理是啥？如何解决-MySQL-主从同步"><a href="#如何实现-MySQL-的读写分离？MySQL-主从复制原理是啥？如何解决-MySQL-主从同步" class="headerlink" title="如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步"></a>如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步</h4><p>TODO</p>
<h4 id="为什么要设计事务隔离级别"><a href="#为什么要设计事务隔离级别" class="headerlink" title="为什么要设计事务隔离级别"></a>为什么要设计事务隔离级别</h4><ul>
<li>解决并发问题</li>
</ul>
<h4 id="Text-Blod如何索引"><a href="#Text-Blod如何索引" class="headerlink" title="Text&#x2F;Blod如何索引"></a>Text&#x2F;Blod如何索引</h4><ul>
<li>存储过程促发器</li>
</ul>
<h4 id="MySQL复制有几种方式"><a href="#MySQL复制有几种方式" class="headerlink" title="MySQL复制有几种方式"></a>MySQL复制有几种方式</h4><ul>
<li><p>基于语句的复制（Statement-based Replication，SBR）</p>
<p>将Master DB的SQL执行语句复制，在Slave DB执行相同SQL语句</p>
<p>易于理解和调试，但是可能由于数据库版本差异导致失败</p>
</li>
<li><p>基于行的复制（Row-based Replication，RBR）</p>
<p>将Master DB上修改的行记录，并在Slave DB将相同的行进行插入或修改实现数据复制</p>
<p>可避免版本导致的语法差异，但需更大磁盘空间和带宽</p>
</li>
<li><p>混合复制（Mixed-based Replication，MBR）</p>
<p>将基于语句和行复制结合，根据情况自动选择使用哪种复制</p>
</li>
<li><p>半同步复制（Semi-synchronous Replication）</p>
<p>在数据库上执行写操作时，至少等待一个从数据库将数据同步过去并确认，才算写操作成功，可提高数据一致性和可用性，但增加IO和网络开销</p>
</li>
<li><p>组复制（Group Replication）</p>
<p>允许多个MySQL实例作为一组，在组内进行数据同步和决策，提高可用性和容错性。组内实例提高复制日志和心跳信息进行通信，并根据投票选举保证数据一致性和高可用性</p>
</li>
</ul>
<h4 id="MySQL主从延迟如何解决"><a href="#MySQL主从延迟如何解决" class="headerlink" title="MySQL主从延迟如何解决"></a>MySQL主从延迟如何解决</h4><p>TODO</p>
<h4 id="如何设计表和表结构"><a href="#如何设计表和表结构" class="headerlink" title="如何设计表和表结构"></a>如何设计表和表结构</h4><p>TODO</p>
<p>有一个商品表，有不同商品，对应不同供应商，可能还有价格降价活动，如何设计表</p>
<h4 id="数据量很大的情況下-需要先从db中查询用户基础信息然后根据用户基本信息去查询redis中关联的用户关联信息-这里忽略OOM的情况下-有什么办法去提升性能呢"><a href="#数据量很大的情況下-需要先从db中查询用户基础信息然后根据用户基本信息去查询redis中关联的用户关联信息-这里忽略OOM的情况下-有什么办法去提升性能呢" class="headerlink" title="数据量很大的情況下,需要先从db中查询用户基础信息然后根据用户基本信息去查询redis中关联的用户关联信息,这里忽略OOM的情况下 ,有什么办法去提升性能呢"></a>数据量很大的情況下,需要先从db中查询用户基础信息然后根据用户基本信息去查询redis中关联的用户关联信息,这里忽略OOM的情况下 ,有什么办法去提升性能呢</h4><p>TODO</p>
<h4 id="一个文章表-宇段包含-文章类型-发布时间-，查询个发布时间段内特定文章类型文章-如何建立索引（联合索引（文章类型，发布时间））"><a href="#一个文章表-宇段包含-文章类型-发布时间-，查询个发布时间段内特定文章类型文章-如何建立索引（联合索引（文章类型，发布时间））" class="headerlink" title="一个文章表 宇段包含 文章类型 发布时间 ，查询个发布时间段内特定文章类型文章 如何建立索引（联合索引（文章类型，发布时间））"></a>一个文章表 宇段包含 文章类型 发布时间 ，查询个发布时间段内特定文章类型文章 如何建立索引（联合索引（文章类型，发布时间））</h4><p>TODO</p>
<h4 id="limit-1000000-加载很慢的话，你是怎么解决的呢"><a href="#limit-1000000-加载很慢的话，你是怎么解决的呢" class="headerlink" title="limit 1000000 加载很慢的话，你是怎么解决的呢"></a>limit 1000000 加载很慢的话，你是怎么解决的呢</h4><ul>
<li>连续ID使用 where id &gt; x 偏移量再向下limit，但是跳页有问题</li>
<li>orderby + 索引</li>
<li>利用延迟关联或子查询优化</li>
</ul>
<h4 id="Select-for-update作用"><a href="#Select-for-update作用" class="headerlink" title="Select for update作用"></a>Select for update作用</h4><ul>
<li>悲观锁查询<ul>
<li>查询不带索引&#x2F;主键是表锁</li>
<li>带索引&#x2F;主键是行锁</li>
</ul>
</li>
</ul>
<h4 id="现行的基于locality-的页缓存有什么不足？"><a href="#现行的基于locality-的页缓存有什么不足？" class="headerlink" title="现行的基于locality 的页缓存有什么不足？"></a>现行的基于locality 的页缓存有什么不足？</h4><p>TODO</p>
<h4 id="如何结合查询器-优化器来优化缓存配置"><a href="#如何结合查询器-优化器来优化缓存配置" class="headerlink" title="如何结合查询器&#x2F; 优化器来优化缓存配置"></a>如何结合查询器&#x2F; 优化器来优化缓存配置</h4><p>TODO</p>
<h4 id="数据库表达式计划缓存说下。表达式计划缓存select怎么生成的"><a href="#数据库表达式计划缓存说下。表达式计划缓存select怎么生成的" class="headerlink" title="数据库表达式计划缓存说下。表达式计划缓存select怎么生成的"></a>数据库表达式计划缓存说下。表达式计划缓存select怎么生成的</h4><p>TODO</p>
<h4 id="union-all-在MvSQL5-7里改进了哪些？"><a href="#union-all-在MvSQL5-7里改进了哪些？" class="headerlink" title="union all 在MvSQL5.7里改进了哪些？"></a>union all 在MvSQL5.7里改进了哪些？</h4><p>TODO</p>
<h4 id="一千多万的表A-和两千万的表b-要求把b有a没有的插入，同时把a数据和b有差异的筛选出来。有什么个方案？"><a href="#一千多万的表A-和两千万的表b-要求把b有a没有的插入，同时把a数据和b有差异的筛选出来。有什么个方案？" class="headerlink" title="一千多万的表A 和两千万的表b,要求把b有a没有的插入，同时把a数据和b有差异的筛选出来。有什么个方案？"></a>一千多万的表A 和两千万的表b,要求把b有a没有的插入，同时把a数据和b有差异的筛选出来。有什么个方案？</h4><ul>
<li>Right Join On 左表关键字 &#x3D; null</li>
</ul>
<h4 id="迁移过程中双读双写具体是什么样的方案"><a href="#迁移过程中双读双写具体是什么样的方案" class="headerlink" title="迁移过程中双读双写具体是什么样的方案"></a>迁移过程中双读双写具体是什么样的方案</h4><p>TODO</p>
<h4 id="双写过程中只写成功了其中一个-DB，返回给用户报错，那是否会存在脏数据"><a href="#双写过程中只写成功了其中一个-DB，返回给用户报错，那是否会存在脏数据" class="headerlink" title="双写过程中只写成功了其中一个 DB，返回给用户报错，那是否会存在脏数据"></a>双写过程中只写成功了其中一个 DB，返回给用户报错，那是否会存在脏数据</h4><p>TODO</p>
<h4 id="双读具体是什么方案，其中一个读成功了就返回还是要两个都读成功才可以"><a href="#双读具体是什么方案，其中一个读成功了就返回还是要两个都读成功才可以" class="headerlink" title="双读具体是什么方案，其中一个读成功了就返回还是要两个都读成功才可以"></a>双读具体是什么方案，其中一个读成功了就返回还是要两个都读成功才可以</h4><p>TODO</p>
<h4 id="数据宕机如何解决"><a href="#数据宕机如何解决" class="headerlink" title="数据宕机如何解决"></a>数据宕机如何解决</h4><ul>
<li><p>运维侧</p>
<ul>
<li><p>设备宕机无响应</p>
<p>主从切换&#x2F;灾备环境切换。宕机期间的数据根据redolog恢复</p>
</li>
<li><p>设备未宕机但响应慢</p>
<p>临时增大最大连接数</p>
</li>
</ul>
</li>
<li><p>开发测</p>
<ul>
<li><p>新模块新功能异常导致的DB宕机</p>
<p>回滚旧版本</p>
</li>
<li><p>根据日志查看是否由于慢查询多导致响应异常</p>
<p>待业务过高峰期进行SQL语句</p>
</li>
</ul>
</li>
</ul>
<h4 id="MySQL-ISAM-InnoDB-增长主键-当突然断电停机后进行重启，两个引擎中的自增主键会连续吗"><a href="#MySQL-ISAM-InnoDB-增长主键-当突然断电停机后进行重启，两个引擎中的自增主键会连续吗" class="headerlink" title="MySQL ISAM InnoDB,增长主键,当突然断电停机后进行重启，两个引擎中的自增主键会连续吗"></a>MySQL ISAM InnoDB,增长主键,当突然断电停机后进行重启，两个引擎中的自增主键会连续吗</h4><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>TODO</p>
<h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><h4 id="Oracle临时表有哪些"><a href="#Oracle临时表有哪些" class="headerlink" title="Oracle临时表有哪些"></a>Oracle临时表有哪些</h4><p>TODO</p>
<h3 id="分布式-拆表"><a href="#分布式-拆表" class="headerlink" title="分布式 &amp;&amp; 拆表"></a>分布式 &amp;&amp; 拆表</h3><h4 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案"></a>分库分表方案</h4><p>TODO</p>
<ul>
<li>水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数据拆分到多个库中。</li>
<li>水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数据拆分到多个表中。</li>
<li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li>
<li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li>
</ul>
<h4 id="分库分表可能遇到的问题"><a href="#分库分表可能遇到的问题" class="headerlink" title="分库分表可能遇到的问题"></a>分库分表可能遇到的问题</h4><p>TODO</p>
<ul>
<li>事务问题：需要用分布式事务啦</li>
<li>跨节点 Join 的问题：解决这一问题可以分两次查询实现</li>
<li>跨节点的 count,order by,group by 以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li>
<li>数据迁移，容量规划，扩容等问题</li>
<li>ID 问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑 UUID</li>
<li>跨分片的排序分页问题（后台加大 pagesize 处理）</li>
</ul>
<h4 id="旧服务单表，如何改造新服务多表，且新旧服务同时运行"><a href="#旧服务单表，如何改造新服务多表，且新旧服务同时运行" class="headerlink" title="旧服务单表，如何改造新服务多表，且新旧服务同时运行"></a>旧服务单表，如何改造新服务多表，且新旧服务同时运行</h4><p>TODO</p>
<h4 id="分表分错了后如何排查"><a href="#分表分错了后如何排查" class="headerlink" title="分表分错了后如何排查"></a>分表分错了后如何排查</h4><p>TODO</p>
<h4 id="如何拆表，优缺点"><a href="#如何拆表，优缺点" class="headerlink" title="如何拆表，优缺点"></a>如何拆表，优缺点</h4><p>TODO</p>
<h4 id="我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）"><a href="#我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）" class="headerlink" title="我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）"></a>我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）</h4><p>TODO</p>
<h4 id="分库分表之后，id-主键如何处理？"><a href="#分库分表之后，id-主键如何处理？" class="headerlink" title="分库分表之后，id 主键如何处理？"></a>分库分表之后，id 主键如何处理？</h4><ul>
<li>继续使用原主键简单场景，设置步长</li>
<li>低频场景，UUID</li>
<li>高频场景，雪花算法</li>
</ul>
<h4 id="表拆分后如何查询"><a href="#表拆分后如何查询" class="headerlink" title="表拆分后如何查询"></a>表拆分后如何查询</h4><p>TODO</p>
<h4 id="为什么分布式不推荐JOIN"><a href="#为什么分布式不推荐JOIN" class="headerlink" title="为什么分布式不推荐JOIN"></a>为什么分布式不推荐JOIN</h4><p>TODO</p>
<h3 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h3><p>TODO</p>
<h2 id="ElasticSearch相关"><a href="#ElasticSearch相关" class="headerlink" title="ElasticSearch相关"></a>ElasticSearch相关</h2><h4 id="ES倒排表压缩算法"><a href="#ES倒排表压缩算法" class="headerlink" title="ES倒排表压缩算法"></a>ES倒排表压缩算法</h4><p>TODO</p>
<p>FOR</p>
<h4 id="ES-索引过程"><a href="#ES-索引过程" class="headerlink" title="ES 索引过程"></a>ES 索引过程</h4><p>TODO</p>
<h4 id="如何瞬间完成海量数据检索"><a href="#如何瞬间完成海量数据检索" class="headerlink" title="如何瞬间完成海量数据检索"></a>如何瞬间完成海量数据检索</h4><ul>
<li>ES，倒排索引</li>
</ul>
<h4 id="ES如何加快分词搜索速度，倒排索引原理"><a href="#ES如何加快分词搜索速度，倒排索引原理" class="headerlink" title="ES如何加快分词搜索速度，倒排索引原理"></a>ES如何加快分词搜索速度，倒排索引原理</h4><p>TODO</p>
<h4 id="ES脑裂问题"><a href="#ES脑裂问题" class="headerlink" title="ES脑裂问题"></a>ES脑裂问题</h4><p>TODO</p>
<h4 id="调优-1"><a href="#调优-1" class="headerlink" title="调优"></a>调优</h4><p>TODO</p>
<h4 id="ES模糊查询要怎么写"><a href="#ES模糊查询要怎么写" class="headerlink" title="ES模糊查询要怎么写"></a>ES模糊查询要怎么写</h4><ul>
<li>fuzzy</li>
</ul>
<h3 id="Click-House"><a href="#Click-House" class="headerlink" title="Click House"></a>Click House</h3><p>TODO</p>
<h2 id="Network相关"><a href="#Network相关" class="headerlink" title="Network相关"></a>Network相关</h2><h4 id="OSI七层模型，每层作用"><a href="#OSI七层模型，每层作用" class="headerlink" title="OSI七层模型，每层作用"></a>OSI七层模型，每层作用</h4><p>TODO</p>
<p>网络层的主要功能（路由），运输层TCP的主要核心（可靠传输）；数据链路层最核心参数（MAC，面试官说不对，应该是调整包大小的参数</p>
<h4 id="TCP如何实现可靠连接"><a href="#TCP如何实现可靠连接" class="headerlink" title="TCP如何实现可靠连接"></a>TCP如何实现可靠连接</h4><p>TODO</p>
<h4 id="TCP的拥塞机制"><a href="#TCP的拥塞机制" class="headerlink" title="TCP的拥塞机制"></a>TCP的拥塞机制</h4><p>TODO</p>
<h4 id="TCP在网络中的第几层"><a href="#TCP在网络中的第几层" class="headerlink" title="TCP在网络中的第几层"></a>TCP在网络中的第几层</h4><ul>
<li>第三层</li>
</ul>
<h4 id="TCP长连接的应用"><a href="#TCP长连接的应用" class="headerlink" title="TCP长连接的应用"></a>TCP长连接的应用</h4><p>TODO</p>
<h4 id="TCP协议头多少字节"><a href="#TCP协议头多少字节" class="headerlink" title="TCP协议头多少字节"></a>TCP协议头多少字节</h4><ul>
<li>60</li>
</ul>
<h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>TODO</p>
<h4 id="TCP四次挥手，挥手从服务端发起会怎么样"><a href="#TCP四次挥手，挥手从服务端发起会怎么样" class="headerlink" title="TCP四次挥手，挥手从服务端发起会怎么样"></a>TCP四次挥手，挥手从服务端发起会怎么样</h4><p>TODO</p>
<h4 id="FIN-WAIT-2是什么时候的"><a href="#FIN-WAIT-2是什么时候的" class="headerlink" title="FIN-WAIT-2是什么时候的"></a>FIN-WAIT-2是什么时候的</h4><p>TODO</p>
<h4 id="TCP-粘包怎么解决"><a href="#TCP-粘包怎么解决" class="headerlink" title="TCP 粘包怎么解决"></a>TCP 粘包怎么解决</h4><p>TODO</p>
<h4 id="TCP滑动窗口为0的情况什么时候出现，如何解决"><a href="#TCP滑动窗口为0的情况什么时候出现，如何解决" class="headerlink" title="TCP滑动窗口为0的情况什么时候出现，如何解决"></a>TCP滑动窗口为0的情况什么时候出现，如何解决</h4><p>TODO</p>
<h4 id="TCP如何保证传输过程的正确性"><a href="#TCP如何保证传输过程的正确性" class="headerlink" title="TCP如何保证传输过程的正确性"></a>TCP如何保证传输过程的正确性</h4><p>TODO</p>
<h4 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP UDP区别"></a>TCP UDP区别</h4><p>TODO</p>
<h4 id="列举几个网络通信协议"><a href="#列举几个网络通信协议" class="headerlink" title="列举几个网络通信协议"></a>列举几个网络通信协议</h4><p>TODO</p>
<h4 id="HTTP请求类型"><a href="#HTTP请求类型" class="headerlink" title="HTTP请求类型"></a>HTTP请求类型</h4><ul>
<li><strong>OPTIONS</strong>：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 </li>
<li><strong>HEAD</strong>：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 </li>
<li><strong>GET</strong>：向特定的资源发出请求。 </li>
<li><strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。 </li>
<li><strong>PUT</strong>：向指定资源位置上传其最新内容。 </li>
<li><strong>DELETE</strong>：请求服务器删除 Request-URI 所标识的资源。 </li>
<li><strong>TRACE</strong>：回显服务器收到的请求，主要用于测试或诊断。 </li>
<li><strong>CONNECT</strong>：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li>
</ul>
<h4 id="HTTP和TCP的关联"><a href="#HTTP和TCP的关联" class="headerlink" title="HTTP和TCP的关联"></a>HTTP和TCP的关联</h4><p>TODO</p>
<h4 id="HTTP和HTTPS的主要区别"><a href="#HTTP和HTTPS的主要区别" class="headerlink" title="HTTP和HTTPS的主要区别"></a>HTTP和HTTPS的主要区别</h4><ul>
<li>HTTP明文传输</li>
<li>HTTPS 使用TLS (SSL) 来加密普通的HTTP 请求和响应，并对这些请求和响应进行数字签名</li>
</ul>
<h4 id="HTTPS交互过程"><a href="#HTTPS交互过程" class="headerlink" title="HTTPS交互过程"></a>HTTPS交互过程</h4><p>TODO</p>
<h4 id="HTTPS-原理，怎么实现-HTTPS这个协议"><a href="#HTTPS-原理，怎么实现-HTTPS这个协议" class="headerlink" title="HTTPS 原理，怎么实现 HTTPS这个协议"></a>HTTPS 原理，怎么实现 HTTPS这个协议</h4><p>TODO</p>
<h4 id="什么是TLS"><a href="#什么是TLS" class="headerlink" title="什么是TLS"></a>什么是TLS</h4><p>TODO</p>
<h4 id="网络收到很多的TIME-WAIT状态包，原因以及解决方案"><a href="#网络收到很多的TIME-WAIT状态包，原因以及解决方案" class="headerlink" title="网络收到很多的TIME_WAIT状态包，原因以及解决方案"></a>网络收到很多的TIME_WAIT状态包，原因以及解决方案</h4><ul>
<li><p>原因</p>
<p>主动关闭TCP一方发送最后一个ACK后等待对方回应FIN，一般最长等待2MSL。</p>
<p>如果不等待，接收方可能因网络原因延迟，导致重传FIN包。</p>
<p>如果直接关闭，可能导致接收方获取延迟的ACK包后，旧TCP连接丢失，只能返回RST包。新TCP连接建立后，延迟包可能干扰新连接</p>
</li>
<li><p>解决方案</p>
<p>服务器tcp_tw_recycle设置为1</p>
</li>
</ul>
<h4 id="服务端出现大量CLOSE-WAIT原因及解决方案"><a href="#服务端出现大量CLOSE-WAIT原因及解决方案" class="headerlink" title="服务端出现大量CLOSE_WAIT原因及解决方案"></a>服务端出现大量CLOSE_WAIT原因及解决方案</h4><ul>
<li><p>原因</p>
<p>被建立连接服务器没有进行第三次挥手。</p>
<p>网络连接未释放，通常是服务端发生异常后未关闭或者服务器参数配置时间过长。即服务端耗时超时，客户端发起FIN请求，服务器回应ACK，此时服务器端就是CLOSE_WAITss</p>
<p>MySQL可能存在事务没有正确commit或rollback可能</p>
</li>
<li><p>解决方案</p>
<p>JAVA开发查看应用ThreadDump，查看大量线程在哪里Blocked</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1839592">https://cloud.tencent.com/developer/article/1839592</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grey-wolf/p/10936657.html">https://www.cnblogs.com/grey-wolf/p/10936657.html</a></p>
</li>
</ul>
<h4 id="网络IO的五种模型"><a href="#网络IO的五种模型" class="headerlink" title="网络IO的五种模型"></a>网络IO的五种模型</h4><p>TODO</p>
<h4 id="RPC-HTTP区别？"><a href="#RPC-HTTP区别？" class="headerlink" title="RPC HTTP区别？"></a>RPC HTTP区别？</h4><ul>
<li>不是相同类型，HTTP是通用协议，RPC是远程调用思想，主要是对底层协议封装</li>
<li>RPC内部实现可以多种协议进行（如TCP、DUBBO），HTTP某种意义上也是RPC调用。自定义的RPC可以更高效</li>
</ul>
<h4 id="输入一个URL会发生什么"><a href="#输入一个URL会发生什么" class="headerlink" title="输入一个URL会发生什么"></a>输入一个URL会发生什么</h4><p>TODO</p>
<p>首先DNS解析<br>面试宫：为什么要解析 URL<br>我：http协议的三次握手．<br>面试宫：2次握手行不行<br>我：从缓存里面拿资源..<br>面试官：知道什么是启发式缓存吗，在什么条件<br>下触发</p>
<p>首先做的是判断输入的值是否符合域名或者服务器地址规范。不符合是调用内置搜<br>索引擎搜索，符合的话先查缓存，没缓存才开始dns解析，3次握手核心是确保客户端，服务端的发送及接受能力，启发式缓存是当我们完全没去设置缓存机制的时候，浏览器会因为内核不同有一套自己的启发式缓存，类似强缓存</p>
<h4 id="IO多路复用是否是异步"><a href="#IO多路复用是否是异步" class="headerlink" title="IO多路复用是否是异步"></a>IO多路复用是否是异步</h4><ul>
<li>处理IO时，不论是否阻塞都是同步IO</li>
<li>epoll内部每个通知等待都是异步的，都是对外部而言是同步的，底层使用epoll的框架后，可以做成异步的，只需暴露给外部的接口无需等待返回值即可</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59975081">https://www.zhihu.com/question/59975081</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473">https://www.zhihu.com/question/19732473</a></li>
</ul>
<h4 id="IO多路复用的优缺点"><a href="#IO多路复用的优缺点" class="headerlink" title="IO多路复用的优缺点"></a>IO多路复用的优缺点</h4><p>TODO</p>
<h4 id="RTMP是什么"><a href="#RTMP是什么" class="headerlink" title="RTMP是什么"></a>RTMP是什么</h4><p>TODO</p>
<h4 id="描述网页一个Http请求，到后端的整个请求过程"><a href="#描述网页一个Http请求，到后端的整个请求过程" class="headerlink" title="描述网页一个Http请求，到后端的整个请求过程"></a>描述网页一个Http请求，到后端的整个请求过程</h4><p>TODO</p>
<h4 id="长连接的方式有哪些"><a href="#长连接的方式有哪些" class="headerlink" title="长连接的方式有哪些"></a>长连接的方式有哪些</h4><p>TODO</p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p><a target="_blank" rel="noopener" href="https://it-blog-cn.com/blogs/interview/netty.html">https://it-blog-cn.com/blogs/interview/netty.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999225355374428168">https://juejin.cn/post/6999225355374428168</a></p>
<h4 id="Netty的线程模型，零拷贝实现"><a href="#Netty的线程模型，零拷贝实现" class="headerlink" title="Netty的线程模型，零拷贝实现"></a>Netty的线程模型，零拷贝实现</h4><p>TODO</p>
<h3 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h3><h4 id="路由器和交换机的工作原理"><a href="#路由器和交换机的工作原理" class="headerlink" title="路由器和交换机的工作原理"></a>路由器和交换机的工作原理</h4><p>TODO</p>
<h2 id="Middleware-相关"><a href="#Middleware-相关" class="headerlink" title="Middleware 相关"></a>Middleware 相关</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="Nginx负载均衡策略，相关场景"><a href="#Nginx负载均衡策略，相关场景" class="headerlink" title="Nginx负载均衡策略，相关场景"></a>Nginx负载均衡策略，相关场景</h4><ul>
<li>轮训</li>
<li>权重</li>
<li>IP hash：hash算法分配</li>
<li>fair：响应时间分配</li>
<li>sticky：Cookie&#x2F;Session识别</li>
</ul>
<h4 id="Nginx如何识别移动端PC端"><a href="#Nginx如何识别移动端PC端" class="headerlink" title="Nginx如何识别移动端PC端"></a>Nginx如何识别移动端PC端</h4><ul>
<li>user_agent</li>
</ul>
<h4 id="Nginx动静分离如何实现"><a href="#Nginx动静分离如何实现" class="headerlink" title="Nginx动静分离如何实现"></a>Nginx动静分离如何实现</h4><p>TODO</p>
<h4 id="Nginx做负载均衡，增加work-connections配置横向拓展Nginx实例"><a href="#Nginx做负载均衡，增加work-connections配置横向拓展Nginx实例" class="headerlink" title="Nginx做负载均衡，增加work_connections配置横向拓展Nginx实例"></a>Nginx做负载均衡，增加work_connections配置横向拓展Nginx实例</h4><p>TODO</p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>TODO</p>
<h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><p>TODO</p>
<h4 id="大文件怎么读取分割记录并保持顺序"><a href="#大文件怎么读取分割记录并保持顺序" class="headerlink" title="大文件怎么读取分割记录并保持顺序"></a>大文件怎么读取分割记录并保持顺序</h4><p>TODO</p>
<h2 id="Tools-相关"><a href="#Tools-相关" class="headerlink" title="Tools 相关"></a>Tools 相关</h2><h4 id="分布式锁在项目上的使用"><a href="#分布式锁在项目上的使用" class="headerlink" title="分布式锁在项目上的使用"></a>分布式锁在项目上的使用</h4><ul>
<li>redission</li>
<li>数据库根据数据增删</li>
</ul>
<h2 id="Theory-相关"><a href="#Theory-相关" class="headerlink" title="Theory 相关"></a>Theory 相关</h2><h4 id="CAP定理和BASE理论"><a href="#CAP定理和BASE理论" class="headerlink" title="CAP定理和BASE理论"></a>CAP定理和BASE理论</h4><ul>
<li><p>CAP</p>
<ul>
<li>Consistency 一致性 （节点中所有可用数据）<ul>
<li>分布式系统下，一致性指的是数据在多个副本中保证一致性</li>
</ul>
</li>
<li>Availability 可用性 （每个请求都能在有限时间内得到回应）<ul>
<li>服务需要一直处于可用状态，对于每一个用户操作都能在有限时间内响应结果</li>
</ul>
</li>
<li>Partition Tolerance 分区容错性 （保证分散的数据之间能够联通）<ul>
<li>不同分区数据不能因故障无法联通，提高容错性就是增加节点将数据复制到这部分节点上。</li>
<li>提高数据节点存在越多，容忍性越高，但要复制的数据就越多，一致性就越难保证。保证一致性需要等待所有节点写入成功，但会带来可用性问题。</li>
<li>为了保证一致性，更新数据节点时间就会延长，可用性就会降低。</li>
</ul>
</li>
<li><strong>同时只能满足其中两项</strong><ul>
<li>集群主机分散，节点、网络故障是常态，因此一般需要保证P和A，舍弃C</li>
</ul>
</li>
</ul>
</li>
<li><p>BASE</p>
<ul>
<li>BA - <strong>B</strong>asically <strong>A</strong>vailable<ul>
<li>出现不可预知故障时，允许部分节点失效，但要保证整个系统仍处于基本可用状态</li>
</ul>
</li>
<li>Soft state <ul>
<li>允许数据在不同副本上有一定延迟同步。mysql replication的异步复制也是一种体现。</li>
</ul>
</li>
<li>Eventually consistent<ul>
<li>存储在数据没有新的更新状态下，系统所有副本在到达某个时间节点后，数据达到同步状态。</li>
</ul>
</li>
<li><strong>最终一致性是弱一致性的一种特殊情况</strong></li>
</ul>
</li>
<li><p>弱一致性与最终一致性区别</p>
<p>弱一致性即使过了不一致时间窗口，后续的读取也不一定能保证一致，而最终一致过了不一致窗口后，后续的读取一定一致，才能说清楚弱一致和最终一致的区别</p>
</li>
<li><p>CAP与BASE关系</p>
<ul>
<li>在分布式的数据系统中，你能保证下面三个要求中的两个：一致性，可用性，以及分区容错性。在此模型上构建的系统将称作 BASE(基本上可用软状态最终一致)架构，不满足 ACID 性质。</li>
</ul>
</li>
<li><p>ACID</p>
<ul>
<li>Automicity 原子性<ul>
<li>一个事务必须被视为不可被分割的最小工作单元</li>
</ul>
</li>
<li>Consistency 一致性<ul>
<li>数据库总是从一个一致性状态切换到另一个一致性状态</li>
</ul>
</li>
<li>Isolation 隔离性<ul>
<li>一个事务中对数据的变更在提交之前，对于其他事务是不可见的</li>
</ul>
</li>
<li>Durablity 持久性<ul>
<li>一旦提交事务，则所做的修改永久写入磁盘</li>
</ul>
</li>
<li><strong>强一致性</strong></li>
</ul>
</li>
</ul>
<h4 id="什么是Serverless"><a href="#什么是Serverless" class="headerlink" title="什么是Serverless"></a>什么是Serverless</h4><ul>
<li>无状态，即方法执行结束后，不改变类的状态，不变更全局参数</li>
</ul>
<h4 id="如何向面试官证明你做的系统是高可用的？"><a href="#如何向面试官证明你做的系统是高可用的？" class="headerlink" title="如何向面试官证明你做的系统是高可用的？"></a>如何向面试官证明你做的系统是高可用的？</h4><ul>
<li>SLA 服务等级协议（Service-Level Agreement，SLA）</li>
<li>服务监控措施<ul>
<li>系统要素指标：主要有 CPU、内存，和磁盘。</li>
<li>网络要素指标：主要有带宽、网络 I&#x2F;O、CDN、DNS、安全策略、和负载策略。</li>
</ul>
</li>
<li>监控报警策略</li>
<li>系统应用策略</li>
</ul>
<h4 id="UV-PV"><a href="#UV-PV" class="headerlink" title="UV&#x2F;PV"></a>UV&#x2F;PV</h4><p>TODO</p>
<h4 id="什么是灰度发布"><a href="#什么是灰度发布" class="headerlink" title="什么是灰度发布"></a>什么是灰度发布</h4><p>TODO</p>
<h4 id="解释型语言和编译型语言的区别？除了运行速度别的角度？生产效率"><a href="#解释型语言和编译型语言的区别？除了运行速度别的角度？生产效率" class="headerlink" title="解释型语言和编译型语言的区别？除了运行速度别的角度？生产效率"></a>解释型语言和编译型语言的区别？除了运行速度别的角度？生产效率</h4><p>TODO</p>
<h4 id="哈希表为什么查找复杂度是常数"><a href="#哈希表为什么查找复杂度是常数" class="headerlink" title="哈希表为什么查找复杂度是常数"></a>哈希表为什么查找复杂度是常数</h4><p>TODO</p>
<h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>TODO</p>
<h4 id="核心解决的问题"><a href="#核心解决的问题" class="headerlink" title="核心解决的问题"></a>核心解决的问题</h4><p>TODO</p>
<h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>TODO</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>TODO</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h4 id="如何查看TCP连接"><a href="#如何查看TCP连接" class="headerlink" title="如何查看TCP连接"></a>如何查看TCP连接</h4><p>TODO</p>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h2 id="Front-End"><a href="#Front-End" class="headerlink" title="Front-End"></a>Front-End</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h3 id="Layui"><a href="#Layui" class="headerlink" title="Layui"></a>Layui</h3><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h4><p>TODO</p>
<h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><h4 id="Angular介绍下双重绑定的机制"><a href="#Angular介绍下双重绑定的机制" class="headerlink" title="Angular介绍下双重绑定的机制"></a>Angular介绍下双重绑定的机制</h4><p>TODO</p>
<h2 id="Other-1"><a href="#Other-1" class="headerlink" title="Other"></a>Other</h2><h4 id="NIO-Channel底层原理"><a href="#NIO-Channel底层原理" class="headerlink" title="NIO Channel底层原理"></a>NIO Channel底层原理</h4><ul>
<li>NIO 通道使用非阻塞 I&#x2F;O 模型，这意味着它们在等待 I&#x2F;O 操作完成时不会阻塞线程。</li>
<li>NIO Channels 使用与 epoll 类似的机制，这使得它们可以使用单个线程有效地处理许多并发连接。</li>
<li>NIO Channels 使用 mmap 和 scatter-gather copy 等各种技术在用户空间和内核空间之间高效地传输数据，从而减少上下文切换并降低 I&#x2F;O 成本。</li>
</ul>
<h4 id="拿到一个需求你会做哪些事情"><a href="#拿到一个需求你会做哪些事情" class="headerlink" title="拿到一个需求你会做哪些事情"></a>拿到一个需求你会做哪些事情</h4><p>TODO</p>
<h4 id="估算某城市的便利店数量"><a href="#估算某城市的便利店数量" class="headerlink" title="估算某城市的便利店数量"></a>估算某城市的便利店数量</h4><ul>
<li>品牌连锁</li>
<li>自营根据人口密度估算</li>
</ul>
<h4 id="CPU占用突然升高该怎么分析"><a href="#CPU占用突然升高该怎么分析" class="headerlink" title="CPU占用突然升高该怎么分析"></a>CPU占用突然升高该怎么分析</h4><ul>
<li>如果是业务量突然增加，考虑扩容问题</li>
<li>如果业务量没变，则查看当前运行程序是否有出现死锁等问题，可以打ThreadDump等查看</li>
</ul>
<h4 id="线程假死怎么排查，如何处理"><a href="#线程假死怎么排查，如何处理" class="headerlink" title="线程假死怎么排查，如何处理"></a>线程假死怎么排查，如何处理</h4><p>TODO</p>
<h4 id="对称加密和不对称加密的区别"><a href="#对称加密和不对称加密的区别" class="headerlink" title="对称加密和不对称加密的区别"></a>对称加密和不对称加密的区别</h4><p>TODO</p>
<h4 id="常用的高可用方案"><a href="#常用的高可用方案" class="headerlink" title="常用的高可用方案"></a>常用的高可用方案</h4><p>TODO</p>
<h4 id="有哪些MHA结构的方案"><a href="#有哪些MHA结构的方案" class="headerlink" title="有哪些MHA结构的方案"></a>有哪些MHA结构的方案</h4><p>TODO</p>
<h4 id="怎样表达滑动窗口限流"><a href="#怎样表达滑动窗口限流" class="headerlink" title="怎样表达滑动窗口限流"></a>怎样表达滑动窗口限流</h4><p>TODO</p>
<h4 id="查询接口调优，不用缓存且要求实时性，如何调优"><a href="#查询接口调优，不用缓存且要求实时性，如何调优" class="headerlink" title="查询接口调优，不用缓存且要求实时性，如何调优"></a>查询接口调优，不用缓存且要求实时性，如何调优</h4><ul>
<li>优化数据库<ul>
<li>调优数据库查询语句</li>
<li>根据需求配置数据库索引</li>
</ul>
</li>
<li>使用搜索引擎如ES</li>
</ul>
<h4 id="服务上下游为什么用sign而不是oauth协议生成key"><a href="#服务上下游为什么用sign而不是oauth协议生成key" class="headerlink" title="服务上下游为什么用sign而不是oauth协议生成key"></a>服务上下游为什么用sign而不是oauth协议生成key</h4><ul>
<li>服务器通常使用签名、时间戳和其他消息数据的组合来生成访问密钥，因为它提供了一种简单灵活的方法来保护和验证请求，而没有完整 OAuth 协议的开销和复杂性。</li>
<li>OAuth 是一种用于授权和身份验证的标准化协议，它提供了一种安全且标准化的方式来代表用户访问受保护的资源。但是，OAuth 被设计为可在许多不同场景中使用的通用协议，这意味着针对特定用例的实施和配置可能很复杂。</li>
<li>相比之下，使用签名、时间戳和其他消息数据的组合来生成访问密钥是一种更简单、更灵活的方法，可以根据应用程序的特定需求进行定制。通过基于消息数据和只有服务器知道的密钥的组合生成访问密钥，服务器可以确保请求经过身份验证和授权。此外，通过在访问密钥中包含时间戳，服务器可以防止重放攻击，攻击者在这种攻击中拦截并在以后重放有效请求。</li>
<li>总的来说，虽然 OAuth 可以成为保护和验证请求的强大工具，但对于一些更简单、更灵活的方法就足够的场景来说，它复杂程度过高了。</li>
</ul>
<h4 id="操作系统的悲观锁、乐观锁"><a href="#操作系统的悲观锁、乐观锁" class="headerlink" title="操作系统的悲观锁、乐观锁"></a>操作系统的悲观锁、乐观锁</h4><p>TODO</p>
<h4 id="如何实现高可用，项目如何实现高可用的"><a href="#如何实现高可用，项目如何实现高可用的" class="headerlink" title="如何实现高可用，项目如何实现高可用的"></a>如何实现高可用，项目如何实现高可用的</h4><p>TODO</p>
<h4 id="如何单元测试，覆盖率如何"><a href="#如何单元测试，覆盖率如何" class="headerlink" title="如何单元测试，覆盖率如何"></a>如何单元测试，覆盖率如何</h4><ul>
<li>Junit</li>
<li>JaCoco</li>
</ul>
<h4 id="MapReduce原理"><a href="#MapReduce原理" class="headerlink" title="MapReduce原理"></a>MapReduce原理</h4><p>TODO</p>
<h4 id="怎么解决高并发下流量"><a href="#怎么解决高并发下流量" class="headerlink" title="怎么解决高并发下流量"></a>怎么解决高并发下流量</h4><p>TODO</p>
<h4 id="核心线程20，最大600，阻塞队列200，当QPS-200时，请求调用第三方（是一个长时间阻塞任务），不加机器情况下，如何提高吞吐量"><a href="#核心线程20，最大600，阻塞队列200，当QPS-200时，请求调用第三方（是一个长时间阻塞任务），不加机器情况下，如何提高吞吐量" class="headerlink" title="核心线程20，最大600，阻塞队列200，当QPS 200时，请求调用第三方（是一个长时间阻塞任务），不加机器情况下，如何提高吞吐量"></a>核心线程20，最大600，阻塞队列200，当QPS 200时，请求调用第三方（是一个长时间阻塞任务），不加机器情况下，如何提高吞吐量</h4><p>TODO</p>
<h4 id="查询接口，不使用缓存且要求实时性，如何调优"><a href="#查询接口，不使用缓存且要求实时性，如何调优" class="headerlink" title="查询接口，不使用缓存且要求实时性，如何调优"></a>查询接口，不使用缓存且要求实时性，如何调优</h4><p>TODO</p>
<h4 id="用户查询一张表，流量控制降级时，如何兜底"><a href="#用户查询一张表，流量控制降级时，如何兜底" class="headerlink" title="用户查询一张表，流量控制降级时，如何兜底"></a>用户查询一张表，流量控制降级时，如何兜底</h4><p>TODO</p>
<h4 id="用户订单按什么自动分表，分表后如何按照时间段查询指定时间段内所有用户订单"><a href="#用户订单按什么自动分表，分表后如何按照时间段查询指定时间段内所有用户订单" class="headerlink" title="用户订单按什么自动分表，分表后如何按照时间段查询指定时间段内所有用户订单"></a>用户订单按什么自动分表，分表后如何按照时间段查询指定时间段内所有用户订单</h4><p>TODO</p>
<h4 id="Channel的底层原理"><a href="#Channel的底层原理" class="headerlink" title="Channel的底层原理"></a>Channel的底层原理</h4><p>TODO</p>
<p>环形缓存＋双队列</p>
<h4 id="channel-和-select的一小段代码，让说出打印内容"><a href="#channel-和-select的一小段代码，让说出打印内容" class="headerlink" title="channel 和 select的一小段代码，让说出打印内容"></a>channel 和 select的一小段代码，让说出打印内容</h4><h4 id="上下文切换content，我只说了下withtimeout超时时，使用，或者记录一些kv值，供后面的方法使用"><a href="#上下文切换content，我只说了下withtimeout超时时，使用，或者记录一些kv值，供后面的方法使用" class="headerlink" title="上下文切换content，我只说了下withtimeout超时时，使用，或者记录一些kv值，供后面的方法使用"></a>上下文切换content，我只说了下withtimeout超时时，使用，或者记录一些kv值，供后面的方法使用</h4><p>TODO</p>
<h4 id="如果你来设计一个类似淘宝的系统，你怎么划分微服务？"><a href="#如果你来设计一个类似淘宝的系统，你怎么划分微服务？" class="headerlink" title="如果你来设计一个类似淘宝的系统，你怎么划分微服务？"></a>如果你来设计一个类似淘宝的系统，你怎么划分微服务？</h4><p>TODO</p>
<h4 id="如果有一个人他伪造了很多合法的QQ号并且多台主机来攻击怎么办"><a href="#如果有一个人他伪造了很多合法的QQ号并且多台主机来攻击怎么办" class="headerlink" title="如果有一个人他伪造了很多合法的QQ号并且多台主机来攻击怎么办"></a>如果有一个人他伪造了很多合法的QQ号并且多台主机来攻击怎么办</h4><p>TODO</p>
<h4 id="连接相同的基站，网络出口可能是相同的，锁定IP误伤怎么办"><a href="#连接相同的基站，网络出口可能是相同的，锁定IP误伤怎么办" class="headerlink" title="连接相同的基站，网络出口可能是相同的，锁定IP误伤怎么办"></a>连接相同的基站，网络出口可能是相同的，锁定IP误伤怎么办</h4><p>TODO</p>
<h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><p>TODO</p>
<h4 id="9个盒子1个有90克-剩下的100克-最少能用几次称出90克的"><a href="#9个盒子1个有90克-剩下的100克-最少能用几次称出90克的" class="headerlink" title="9个盒子1个有90克 剩下的100克 最少能用几次称出90克的"></a>9个盒子1个有90克 剩下的100克 最少能用几次称出90克的</h4><p>TODO</p>
<h4 id="常见的索引结构"><a href="#常见的索引结构" class="headerlink" title="常见的索引结构"></a>常见的索引结构</h4><p><em>哈希表,有序数组和N叉树</em></p>
<h4 id="系统大量用户登录时出现session连接过多导致用户被登出，如何解决"><a href="#系统大量用户登录时出现session连接过多导致用户被登出，如何解决" class="headerlink" title="系统大量用户登录时出现session连接过多导致用户被登出，如何解决"></a>系统大量用户登录时出现session连接过多导致用户被登出，如何解决</h4><p>TODO</p>
<h4 id="接口幂等是如何保证的"><a href="#接口幂等是如何保证的" class="headerlink" title="接口幂等是如何保证的"></a>接口幂等是如何保证的</h4><p>TODO</p>
<p>实现幂等一般有这8种方案：selecttinsert+ 主键&#x2F;唯<br>一的索引冲突、直接 insert＋主键&#x2F;唯一的索引冲<br>突、状态机密等、抽取防重表、token令牌、悲观锁<br>(如 select for update， 很少用)、乐观说、分布式<br>锁</p>
<h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><p>TODO</p>
<p>技术选型主要比较几个维度：性能、稳定性、接入成本、社区活跃度、业务扩展性、业务特点等等，没有所谓最好的框架&#x2F;工具，只有最合适自己的。</p>
<h4 id="HTTP-流量的录制工具主要是做什么用呢"><a href="#HTTP-流量的录制工具主要是做什么用呢" class="headerlink" title="HTTP 流量的录制工具主要是做什么用呢"></a>HTTP 流量的录制工具主要是做什么用呢</h4><p>TODO</p>
<h4 id="HTTP-流量录制会涉及到一些登陆态的处理吗"><a href="#HTTP-流量录制会涉及到一些登陆态的处理吗" class="headerlink" title="HTTP 流量录制会涉及到一些登陆态的处理吗"></a>HTTP 流量录制会涉及到一些登陆态的处理吗</h4><p>TODO</p>
<h4 id="微信朋友圈设计，朋友圈可见与不可见"><a href="#微信朋友圈设计，朋友圈可见与不可见" class="headerlink" title="微信朋友圈设计，朋友圈可见与不可见"></a>微信朋友圈设计，朋友圈可见与不可见</h4><p>TODO</p>
<h4 id="埋点如何设计"><a href="#埋点如何设计" class="headerlink" title="埋点如何设计"></a>埋点如何设计</h4><p>TODO</p>
<h4 id="实现百度翻译接口，已获得链接和密钥"><a href="#实现百度翻译接口，已获得链接和密钥" class="headerlink" title="实现百度翻译接口，已获得链接和密钥"></a>实现百度翻译接口，已获得链接和密钥</h4><p>TODO</p>
<h4 id="二级计算器"><a href="#二级计算器" class="headerlink" title="二级计算器"></a>二级计算器</h4><p>TODO</p>
<p>策略模式</p>
<h4 id="100百只箭、A、B交替射箭，每次可以射出1、2个，最后一个射出的人获胜，问如何保证A一定能赢"><a href="#100百只箭、A、B交替射箭，每次可以射出1、2个，最后一个射出的人获胜，问如何保证A一定能赢" class="headerlink" title="100百只箭、A、B交替射箭，每次可以射出1、2个，最后一个射出的人获胜，问如何保证A一定能赢"></a>100百只箭、A、B交替射箭，每次可以射出1、2个，最后一个射出的人获胜，问如何保证A一定能赢</h4><p>TODO</p>
<h4 id="如何实现广告的自算收入和三方收入校正"><a href="#如何实现广告的自算收入和三方收入校正" class="headerlink" title="如何实现广告的自算收入和三方收入校正"></a>如何实现广告的自算收入和三方收入校正</h4><p>TODO</p>
<h4 id="从数据库取许多记录每行记录包括id，dad-id-把这些记录转化为tree。"><a href="#从数据库取许多记录每行记录包括id，dad-id-把这些记录转化为tree。" class="headerlink" title="从数据库取许多记录每行记录包括id，dad_ id,把这些记录转化为tree。"></a>从数据库取许多记录每行记录包括id，dad_ id,把这些记录转化为tree。</h4><p>TODO</p>
<h4 id="50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有枪声，第二天没有枪声，第三天开始一阵枪响，问：一共死了几条狗？"><a href="#50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有枪声，第二天没有枪声，第三天开始一阵枪响，问：一共死了几条狗？" class="headerlink" title="50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有枪声，第二天没有枪声，第三天开始一阵枪响，问：一共死了几条狗？"></a>50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有枪声，第二天没有枪声，第三天开始一阵枪响，问：一共死了几条狗？</h4>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/09/Spring-Transaction/" rel="prev" title="Spring 事务">
      <i class="fa fa-chevron-left"></i> Spring 事务
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/16/Garbage-Cllection-Algorithms-And-Implementations-P1/" rel="next" title="垃圾回收的算法与实现 笔记 Part1">
      垃圾回收的算法与实现 笔记 Part1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">Java面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.</span> <span class="nav-text">编程思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">设计模式有哪些原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">设计模式理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">什么是设计模式中的回调模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">饿汉式和懒汉式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">编程规范理解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="nav-number">1.2.</span> <span class="nav-text">算法相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%B0%8F%E9%A1%B6%E5%A0%86%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E8%B7%9F%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">大顶堆小顶堆怎么删除跟节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">字典树序列化问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv4%E8%BD%AC%E6%95%B0%E5%AD%97%EF%BC%8C%E5%8F%AA%E8%83%BD%E7%94%A8int%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">IPv4转数字，只能用int类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E5%81%B6%E6%95%B0%EF%BC%8C%E9%99%A4%E5%BC%80%E5%AF%B92%E5%8F%96%E4%BD%99"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">如何快速判断一个数是奇数还是偶数，除开对2取余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">快速排序和优先级队列处理数据复杂度比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BAABC%E8%8B%A5%E5%B9%B2%E6%AC%A1"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">多线程按顺序输出ABC若干次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="nav-number">1.2.0.7.</span> <span class="nav-text">一亿个数中找到最大数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%AF%8FK%E4%B8%AA%E4%B8%80%E8%A1%8C%EF%BC%8C%E5%AD%98%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%EF%BC%8C%E4%B8%8D%E6%BB%A1%E8%A1%A5%E9%9B%B6"><span class="nav-number">1.2.0.8.</span> <span class="nav-text">一个数组每K个一行，存到一个二维数组中，不满补零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF"><span class="nav-number">1.2.0.9.</span> <span class="nav-text">快速排序思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%B1%82%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%8C%E8%A6%81%E6%B1%82%E7%BB%84%E6%88%90%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%8C%E8%87%B3%E5%B0%91%E9%97%B4%E9%9A%94%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.0.10.</span> <span class="nav-text">一个数组，求最大和，要求组成最大和的元素不是连续的，至少间隔一个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%99%A4%E2%80%99-%E2%80%98%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E2%80%99-%E2%80%98%E7%9A%84%E4%B8%AA%E6%95%B0%E5%92%8C%E5%8E%BB%E9%99%A4%E2%80%99-%E2%80%98%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-%EF%BC%88n%EF%BC%89"><span class="nav-number">1.2.0.11.</span> <span class="nav-text">任意字符串去除’ ‘返回字符串中’ ‘的个数和去除’ ‘的字符串，函数可以重载，时间复杂度为O （n）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2D%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">1.2.0.12.</span> <span class="nav-text">2D接雨水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.0.13.</span> <span class="nav-text">合并多个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%B8%BA5%E7%9A%84%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.2.0.14.</span> <span class="nav-text">深度为5的满二叉树中叶子结点的个数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%E5%92%8C%E5%85%B6%E4%BB%96%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">什么是红黑树？和其他树有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">堆结构与树结构的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">搜索二叉树怎么遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-L1-L2-L3%E5%93%AA%E4%BA%9B%E5%85%B1%E4%BA%AB"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">CPU L1 L2 L3哪些共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8A%E7%9A%84%E7%BA%A2%E8%8A%82%E7%82%B9%E4%B8%BB%E8%A6%81%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="nav-number">1.3.0.5.</span> <span class="nav-text">HashMap 的红黑树、红黑树上的红节点主要是干什么的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%87%A0%E4%BA%BF%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%EF%BC%8C%E6%A0%87%E5%87%BA%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BA%BA"><span class="nav-number">1.3.0.6.</span> <span class="nav-text">十几亿个数据，实现黑白名单，标出黑名单的几个人</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.0.7.</span> <span class="nav-text">计算机内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E5%92%8C%E6%AD%A3%E5%88%99%E6%96%87%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.0.8.</span> <span class="nav-text">上下文无关文法和正则文法的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8C%85%E5%90%ABinsert%E5%92%8CqueryMedium%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E9%AB%98%E9%A2%91%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%8F%92%E5%85%A5%E4%BD%8E%E9%A2%91%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%A6%81%E6%B1%82%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9C%80%E4%BC%98"><span class="nav-number">1.3.0.9.</span> <span class="nav-text">定义一个数据结构，包含insert和queryMedium两个方法，查询高频操作，插入低频操作，要求查询效率最优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.</span> <span class="nav-text">Java 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Java基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#float%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">float如何判断是否为0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%88%B0%E9%94%80%E6%AF%81%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">对象创建到销毁的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">abstract应用范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interface%E9%BB%98%E8%AE%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">interface默认修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-this%E6%80%8E%E4%B9%88%E7%94%A8"><span class="nav-number">1.4.1.7.</span> <span class="nav-text">super this怎么用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.1.8.</span> <span class="nav-text">switch如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%90%86%E8%A7%A3"><span class="nav-number">1.4.1.9.</span> <span class="nav-text">Java包装类型理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="nav-number">1.4.1.10.</span> <span class="nav-text">Java面向对象特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E5%9C%A8JVM%E5%93%AA%E4%B8%AA%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.4.1.11.</span> <span class="nav-text">值类型和引用类型分别在JVM哪个区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%97"><span class="nav-number">1.4.1.12.</span> <span class="nav-text">String是值类型吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.1.13.</span> <span class="nav-text">接口能不能实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E7%B1%BB%E4%B9%88%EF%BC%8C%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88-%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.1.14.</span> <span class="nav-text">抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99"><span class="nav-number">1.4.1.15.</span> <span class="nav-text">父类静态方法能否被子类重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.1.16.</span> <span class="nav-text">静态属性和静态方法是否可以被继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99Equals%E4%B8%80%E5%AE%9A%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99HashCode"><span class="nav-number">1.4.1.17.</span> <span class="nav-text">为什么重写Equals一定也要重写HashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashCode%E7%9B%B8%E5%90%8C%EF%BC%8C%E6%98%AF%E5%90%A6Equals%EF%BC%8C%E5%8F%8D%E4%B9%8B%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="nav-number">1.4.1.18.</span> <span class="nav-text">HashCode相同，是否Equals，反之是否相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E5%BC%82%E6%88%96%E4%B8%A4%E6%AC%A1%E7%AD%89%E4%BA%8E%E6%B2%A1%E6%9C%89%E5%BC%82%E6%88%96"><span class="nav-number">1.4.1.19.</span> <span class="nav-text">对一个数异或两次等于没有异或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#float%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%80%8E%E4%B9%88%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.4.1.20.</span> <span class="nav-text">float在内存中怎么表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.1.21.</span> <span class="nav-text">数组动态分配内存如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.22.</span> <span class="nav-text">如何防止非原子操作的冲突问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.4.1.23.</span> <span class="nav-text">什么是哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%A7%E8%87%B4%E5%90%AB%E4%B9%89"><span class="nav-number">1.4.1.24.</span> <span class="nav-text">Object 常用方法及每个方法的大致含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8JDK1-5%E4%B8%AD%E5%BC%95%E5%85%A5%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%98%E5%9C%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.25.</span> <span class="nav-text">在JDK1.5中引入了泛型，泛型的存在是用来解决什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.26.</span> <span class="nav-text">泛型中extends和super的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD2%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="nav-number">1.4.1.27.</span> <span class="nav-text">有没有可能2个不相等的对象有相同的hashcode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E5%87%A0%E4%B8%AA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.28.</span> <span class="nav-text">举例几个树形结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E4%BD%93%E7%B3%BB%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88"><span class="nav-number">1.4.1.29.</span> <span class="nav-text">Java异常类体系共同祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.30.</span> <span class="nav-text">Error和Exception的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.4.1.31.</span> <span class="nav-text">Java异常框架有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-number">1.4.1.32.</span> <span class="nav-text">你知道什么是指令重排序？为什么要重排序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%9C%A8Java%E4%B8%AD%E5%AE%83%E8%B7%9Fsynchronized%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">1.4.1.33.</span> <span class="nav-text">Java中的volatile关键是什么作用？在Java中它跟synchronized方法有什么不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Overload%E3%80%81Override%E3%80%81Overwrite%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.34.</span> <span class="nav-text">Overload、Override、Overwrite的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.4.1.35.</span> <span class="nav-text">什么是浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%83%E5%AF%B9%E5%86%99%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%B8%AE%E5%8A%A9"><span class="nav-number">1.4.1.36.</span> <span class="nav-text">什么是不可变对象，它对写并发应用有什么帮助</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.4.1.37.</span> <span class="nav-text">如何创建不可变的类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E8%83%BD%E4%B8%8D%E8%83%BD%E6%9C%89%E5%AD%90%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E8%A2%AB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.1.38.</span> <span class="nav-text">String能不能有子类，为什么 String 被设计为是不可变的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E8%BD%ACInteger%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.1.39.</span> <span class="nav-text">String转Integer的方式和原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.4.1.40.</span> <span class="nav-text">描述动态代理的几种实现方式，分别说出相应的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">1.4.1.41.</span> <span class="nav-text">JAVA实现反射的两种方式？为什么要这样设计？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.4.1.42.</span> <span class="nav-text">Servlet生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SimpleWebServer%E6%94%AF%E6%8C%81HTTPS%E5%90%97"><span class="nav-number">1.4.1.43.</span> <span class="nav-text">SimpleWebServer支持HTTPS吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-%E5%92%8Cfinal-static%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.44.</span> <span class="nav-text">static 和final static的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%B1%A0%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.1.45.</span> <span class="nav-text">Java内存池提供的接口，实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.4.1.46.</span> <span class="nav-text">空闲链表法中每个节点管理的内存大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EJB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.1.47.</span> <span class="nav-text">EJB是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95-xml%E6%88%96properties"><span class="nav-number">1.4.1.48.</span> <span class="nav-text">Java读取配置文件方法 xml或properties</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-Map-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.2.</span> <span class="nav-text">List &amp;&amp; Map 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E7%90%86%E8%A7%A3%EF%BC%8CMap%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8CHashMap%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Java集合理解，Map的理解，HashMap关键属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMap%E7%B1%BB%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CHashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">用过哪些Map类，都有什么区别，HashMap是线程安全的吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array%E5%92%8CList%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Array和List区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">ArrayList扩容机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ArrayList%E6%AF%94LinkedList%E9%AB%98%E6%95%88"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">为什么ArrayList比LinkedList高效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E6%AF%94TreeMap%E6%9B%B4%E9%AB%98%E6%95%88%E5%90%97"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">HashMap比TreeMap更高效吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E8%B0%81%E6%9B%B4%E9%AB%98%E6%95%88"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">数组链表谁更高效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88Copy%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">如何高效Copy数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F1W%EF%BC%8C%E5%AD%981W%E4%B8%AA%E6%98%AF%E5%90%A6%E4%BC%9A%E6%89%A9%E5%AE%B9"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">HashMap初始化容量1W，存1W个是否会扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FHashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="nav-number">1.4.2.10.</span> <span class="nav-text">解决Hash冲突的办法有哪些？HashMap用的哪种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87K-V%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">1.4.2.11.</span> <span class="nav-text">HashMap如何通过K-V管理数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A92%E7%9A%84%E5%80%8D%E6%95%B0%E5%BD%93%E4%BD%9C%E5%AE%B9%E9%87%8F"><span class="nav-number">1.4.2.12.</span> <span class="nav-text">HashMap为什么选择2的倍数当作容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%88%9D%E5%A7%8B%E4%B8%BA%E4%BB%80%E4%B9%8816"><span class="nav-number">1.4.2.13.</span> <span class="nav-text">HashMap初始为什么16</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF0-75"><span class="nav-number">1.4.2.14.</span> <span class="nav-text">HashMap因子为什么是0.75</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E6%89%A9%E5%AE%B9%E5%90%8E%E5%A6%82%E4%BD%95%E5%86%8D%E6%95%A3%E5%88%97%EF%BC%88rehash%EF%BC%89"><span class="nav-number">1.4.2.15.</span> <span class="nav-text">HashMap扩容后如何再散列（rehash）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%9C%A8Java-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%BF%9B%E5%85%A5%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.4.2.16.</span> <span class="nav-text">HashMap在Java 7 为什么会进入死循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%AD%98%E5%82%A8%E9%87%8F%E5%8F%98%E6%9B%B4%E6%97%B6%E5%88%87%E6%8D%A2%E7%BB%93%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2"><span class="nav-number">1.4.2.17.</span> <span class="nav-text">HashMap为什么要在存储量变更时切换结构，如何切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-1"><span class="nav-number">1.4.2.18.</span> <span class="nav-text">HashMap为什么查询时间复杂度为O(1)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.19.</span> <span class="nav-text">ConcurrentHashMap如何解决安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E5%9C%A8Java-7%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.20.</span> <span class="nav-text">ConcurrentHashMap在Java 7性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Java-8%E6%94%BE%E5%BC%83%E4%BA%86%E5%88%86%E6%AE%B5%E9%94%81"><span class="nav-number">1.4.2.21.</span> <span class="nav-text">ConcurrentHashMap为什么在Java 8放弃了分段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F%E4%BD%A0%E7%9F%A5%E9%81%93Java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.2.22.</span> <span class="nav-text">什么是阻塞队列？你知道Java中有哪些阻塞队列吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBlockingQueue%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.2.23.</span> <span class="nav-text">ArrayBlockingQueue原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8Java%E5%86%99%E4%BB%A3%E7%A0%81%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.24.</span> <span class="nav-text">用Java写代码来解决生产者——消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.4.2.25.</span> <span class="nav-text">线程如何设置优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%EF%BC%9F%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%8F%91%E7%8E%B0%E5%92%8C%E8%A7%A3%E5%86%B3%E7%AB%9E%E4%BA%89"><span class="nav-number">1.4.2.26.</span> <span class="nav-text">什么是竞争条件？你怎样发现和解决竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%ADCyclicBarrier%E5%92%8CCountdownLatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.27.</span> <span class="nav-text">在Java中CyclicBarrier和CountdownLatch有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.2.28.</span> <span class="nav-text">你知道哪几种锁？分别有什么特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%8C%E4%BB%8E%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E8%AE%B2"><span class="nav-number">1.4.2.29.</span> <span class="nav-text">synchronized为什么是重量级锁，从系统层面讲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronize%E9%94%81%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.4.2.30.</span> <span class="nav-text">synchronize锁有几种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronize%E9%94%81%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">1.4.2.31.</span> <span class="nav-text">synchronize锁是安全的吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9Fsynchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FLock%E6%8E%A5%E5%8F%A3%E6%AF%94synchronized%E5%9D%97%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.2.32.</span> <span class="nav-text">线程加锁有哪些方式？synchronized和lock的区别？Lock接口比synchronized块的优势是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JUC%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%E4%B8%8Esynchronized%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.33.</span> <span class="nav-text">JUC提供的锁与synchronized有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-11-%E7%9A%84synchronized%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">1.4.2.34.</span> <span class="nav-text">Java 11 的synchronized锁升级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%8A%A0%E5%9C%A8%E5%A4%9A%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.2.35.</span> <span class="nav-text">synchronized加在多个非静态函数，函数之间什么关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.36.</span> <span class="nav-text">乐观锁和悲观锁的本质区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-for%E5%BE%AA%E7%8E%AF%E8%BF%87%E4%BA%8E%E6%B6%88%E8%80%97cpu%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%98%9F%E5%88%97"><span class="nav-number">1.4.2.37.</span> <span class="nav-text">CAS for循环过于消耗cpu怎么办，如何实现公平队列?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E6%98%AF%E5%90%A6%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.4.2.38.</span> <span class="nav-text">volatile是否能保证线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB-False-Sharing-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3"><span class="nav-number">1.4.2.39.</span> <span class="nav-text">伪共享 (False Sharing) 怎么理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%8C%E8%AF%A5%E7%BC%93%E5%AD%98%E5%85%81%E8%AE%B8%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E8%AF%BB%EF%BC%8C%E4%BD%86%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%86%99%EF%BC%8C%E4%BB%A5%E6%AD%A4%E6%9D%A5%E4%BF%9D%E6%8C%81%E5%AE%83%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.2.40.</span> <span class="nav-text">需要实现一个高效的缓存，该缓存允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%B8%A6%E6%9D%A5%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.41.</span> <span class="nav-text">为什么多线程会带来性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%A4%AA%E5%A4%A7%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.4.2.42.</span> <span class="nav-text">线程池中的线程调度，负载太大怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E3%80%81%E5%85%B3%E8%81%94%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">1.4.2.43.</span> <span class="nav-text">线程池基本原理、使用场景、注意事项、关联的连接池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86AQS"><span class="nav-number">1.4.2.44.</span> <span class="nav-text">线程池线程管理AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.4.2.45.</span> <span class="nav-text">线程池阻塞非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0Cancel%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.2.46.</span> <span class="nav-text">线程池Cancel策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%83%8C%E5%8E%8B"><span class="nav-number">1.4.2.47.</span> <span class="nav-text">线程池的背压</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8ETomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%90%8C"><span class="nav-number">1.4.2.48.</span> <span class="nav-text">Java线程池与Tomcat线程池异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-sleep-Object-wait-LockSupport-park-Condition-await-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.49.</span> <span class="nav-text">Thread.sleep(), Object.wait(), LockSupport.park(),Condition.await()区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E6%80%8E%E6%A0%B7%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.2.50.</span> <span class="nav-text">Java中怎样唤醒一个阻塞的线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait%E4%B8%8Eawait%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.51.</span> <span class="nav-text">wait与await区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-sleep-0-%E7%9B%AE%E7%9A%84"><span class="nav-number">1.4.2.52.</span> <span class="nav-text">Thread.sleep(0)目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-yield"><span class="nav-number">1.4.2.53.</span> <span class="nav-text">Thread.yield()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.4.2.54.</span> <span class="nav-text">在Java进程中的通信方式有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.2.55.</span> <span class="nav-text">在Java中线程间有哪些通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.56.</span> <span class="nav-text">多进程与多线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88AtomicInteger%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A5%BD"><span class="nav-number">1.4.2.57.</span> <span class="nav-text">为什么AtomicInteger在高并发下性能不好</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.2.58.</span> <span class="nav-text">有哪些解决死锁问题的策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.59.</span> <span class="nav-text">有哪些线程安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.2.60.</span> <span class="nav-text">线程池有哪几种拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start-%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5"><span class="nav-number">1.4.2.61.</span> <span class="nav-text">一个线程两次调用start()方法会出现什么情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD"><span class="nav-number">1.4.2.62.</span> <span class="nav-text">线程如何中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="nav-number">1.4.2.63.</span> <span class="nav-text">线程如何停止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E8%B5%84%E6%BA%90%EF%BC%8C%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%AB%98%E6%95%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.2.64.</span> <span class="nav-text">线程读写资源，在不使用锁的情况下高效实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%94%A8%E5%88%B0%E8%BF%87ThreadLocal%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.2.65.</span> <span class="nav-text">ThreadLocal是什么？在工作中用到过ThreadLocal吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.4.2.66.</span> <span class="nav-text">ThreadLocal怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B"><span class="nav-number">1.4.2.67.</span> <span class="nav-text">ThreadLocal 内存泄露是怎么回事</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.2.68.</span> <span class="nav-text">ThreadLocalMap的结构了解吗？扩容机制了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">1.4.2.69.</span> <span class="nav-text">ThreadLocal父子线程怎么共享数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E6%9C%89JMM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">1.4.2.70.</span> <span class="nav-text">ThreadLocal有JMM内存屏障问题吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%8E%82%E8%A7%84%E5%AE%9A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8Executors%E5%8E%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.4.2.71.</span> <span class="nav-text">为什么大厂规定不能使用Executors去创建线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E9%9C%80%E8%A6%81%EF%BC%8C%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.4.2.72.</span> <span class="nav-text">如何根据实际需要，定制自己的线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-AQS%EF%BC%9FAQS-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E9%87%8D%E8%A6%81%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.2.73.</span> <span class="nav-text">为什么需要 AQS？AQS 的作用和重要性是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%A6%82%E4%BD%95"><span class="nav-number">1.4.2.74.</span> <span class="nav-text">多线程的信号量如何</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS%E5%92%8CReentrantLock%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.2.75.</span> <span class="nav-text">AQS和ReentrantLock的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.4.2.76.</span> <span class="nav-text">CAS是一种什么样的同步机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.2.77.</span> <span class="nav-text">你知道CAS 有什么缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E2%80%9D%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.2.78.</span> <span class="nav-text">你知道线程池实现“线程复用”的原理吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.2.79.</span> <span class="nav-text">阻塞和非阻塞队列的并发安全原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9%E2%80%9C%E5%85%AC%E5%B9%B3%E9%94%81%E2%80%9D%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E2%80%9C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E2%80%9D%EF%BC%9F"><span class="nav-number">1.4.2.80.</span> <span class="nav-text">你对“公平锁”了解吗？为什么会有“非公平锁”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9%E2%80%9C%E8%87%AA%E6%97%8B%E9%94%81%E2%80%9D%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.2.81.</span> <span class="nav-text">你对“自旋锁”了解吗？优缺点分别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E6%A0%B8%E5%BF%83%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.4.2.82.</span> <span class="nav-text">CPU 核心数和线程数的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">1.4.2.83.</span> <span class="nav-text">多线程环境中遇到的常见的问题是什么？怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%AD%E7%BB%BF%E8%89%B2%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.84.</span> <span class="nav-text">在Java中绿色线程和本地线程区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.85.</span> <span class="nav-text">死锁与活锁的区别，死锁与饥饿的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.4.2.86.</span> <span class="nav-text">Java中用到的线程调度算法是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.2.87.</span> <span class="nav-text">在线程中怎么处理不可捕捉异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%BB%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Java%E4%B8%AD%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.2.88.</span> <span class="nav-text">什么是线程组，为什么在Java中不推荐使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Executor%E6%A1%86%E6%9E%B6%E6%AF%94%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B%E5%A5%BD"><span class="nav-number">1.4.2.89.</span> <span class="nav-text">为什么使用Executor框架比使用应用创建和管理线程好</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%ADExecutor%E5%92%8CExecutors%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.90.</span> <span class="nav-text">在Java中Executor和Executors的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%AF%A6%E7%BB%86%E7%9A%84"><span class="nav-number">1.4.2.91.</span> <span class="nav-text">方法中的参数在内存中的传递过程，详细的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8Eexcel%E8%A1%A8%E4%B8%AD%E6%89%B9%E9%87%8F-%EF%BC%8810w-%EF%BC%89-%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.2.92.</span> <span class="nav-text">从excel表中批量 （10w+） 导入数据。解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E5%92%8CLinux%E4%B8%8A%E6%9F%A5%E6%89%BE%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84CPU%E6%97%B6%E9%97%B4%E6%9C%80%E9%95%BF"><span class="nav-number">1.4.2.93.</span> <span class="nav-text">如何在Windows和Linux上查找哪个线程使用的CPU时间最长</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other"><span class="nav-number">1.4.3.</span> <span class="nav-text">Other</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A810%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">如何用10行代码实现一个负载均衡服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BE%E4%B8%87%E6%96%87%E4%BB%B6%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E6%9C%89%E5%BE%88%E5%A4%9A%E6%B1%89%E5%AD%97%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%90%8C%E3%80%82%E5%81%87%E8%AE%BE1000%E4%B8%AA%E6%B1%89%E5%AD%97%EF%BC%8C%E9%97%AE%E6%80%8E%E6%A0%B7%E7%BB%9F%E8%AE%A1%E5%87%BA%E8%BF%99%E4%BA%9B%E6%96%87%E4%BB%B6%E9%87%8C%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B1%89%E5%AD%97"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">百万文件，每个文件有很多汉字，每个文件大小不同。假设1000个汉字，问怎样统计出这些文件里出现次数最多的汉字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA-LIST%E6%9F%A5%E8%AF%A2%E8%BF%87%E5%A4%A7%E5%AE%B9%E6%98%93OOM%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">JAVA LIST查询过大容易OOM解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8Java%E7%BC%96%E7%A8%8B%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">用Java编程一个会导致死锁的程序，怎么解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-IO%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.4.</span> <span class="nav-text">File IO相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%87%A0%E7%A7%8DCopy%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%93%AA%E7%A7%8D%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Java几种Copy方式，哪种效率最高</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.5.</span> <span class="nav-text">JMM 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">JMM模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">volatile模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%B7%E5%86%99%E6%95%B0%E6%8D%AEsynchronized%E5%92%8Cvolatile%E5%BC%82%E5%90%8C"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">刷写数据synchronized和volatile异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E2%80%9D%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.0.4.</span> <span class="nav-text">什么是“内存可见性”问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.5.0.5.</span> <span class="nav-text">你知道主内存和工作内存的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF-happens-before-%E5%8E%9F%E5%88%99%E5%90%97%EF%BC%9F"><span class="nav-number">1.5.0.6.</span> <span class="nav-text">你知道什么是 happens-before 原则吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%AA%97%E5%8F%A3%E6%9C%9F"><span class="nav-number">1.5.0.7.</span> <span class="nav-text">JAVA创建对象时是否存在窗口期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%9C%A8-JAVA%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%93%E7%8E%B0%E7%9A%84"><span class="nav-number">1.5.0.8.</span> <span class="nav-text">共享内存在 JAVA中是怎么体现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.0.9.</span> <span class="nav-text">Java里面的内存模型和操作系统里面的内存模型有什么区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.</span> <span class="nav-text">JVM 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">JVM结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">JVM内存分配的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84"><span class="nav-number">1.6.0.4.</span> <span class="nav-text">Java运行时区域中哪些是线程共享的哪些是线程私有的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="nav-number">1.6.0.5.</span> <span class="nav-text">程序计数器作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E9%87%8C%E9%9D%A2%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.6.0.6.</span> <span class="nav-text">虚拟机栈里面是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%E5%86%85%E5%AE%B9"><span class="nav-number">1.6.0.7.</span> <span class="nav-text">方法区存储什么内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E6%A0%88%E4%BB%80%E4%B9%88%E6%97%B6%E4%BE%AF%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">1.6.0.8.</span> <span class="nav-text">Java栈什么时侯会发生内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="nav-number">1.6.0.9.</span> <span class="nav-text">内存碎片怎么优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-GCRoots%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.0.10.</span> <span class="nav-text">JVM GCRoots对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%BE%BE"><span class="nav-number">1.6.0.11.</span> <span class="nav-text">什么是不可达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A%E3%80%81B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%9B%9E%E6%94%B6%EF%BC%8C%E4%B8%80%E5%AE%9A%E5%B0%B1%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97"><span class="nav-number">1.6.0.12.</span> <span class="nav-text">A、B对象可回收，一定就会被回收吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86Young-Gen-and-Old-Gen"><span class="nav-number">1.6.0.13.</span> <span class="nav-text">为什么要分Young Gen and Old Gen</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E6%8D%A2%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="nav-number">1.6.0.14.</span> <span class="nav-text">为什么用元空间替换永久代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E4%BC%9A%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95%E5%8C%BA%E6%95%B0%E6%8D%AE%E5%90%97"><span class="nav-number">1.6.0.15.</span> <span class="nav-text">GC会清除方法区数据吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%9C%80%E5%B0%8F%E5%A0%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE"><span class="nav-number">1.6.0.16.</span> <span class="nav-text">最大堆内存和最小堆内存如何配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%8C%E5%BD%93%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%88%9B%E5%BB%BA%E5%BE%88%E5%A4%9A%E6%97%B6%EF%BC%8CJVM%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.6.0.17.</span> <span class="nav-text">一个固定的堆内存，当线程数创建很多时，JVM参数如何设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E4%BC%98"><span class="nav-number">1.6.0.18.</span> <span class="nav-text">调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class%E6%96%87%E4%BB%B6%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B"><span class="nav-number">1.6.0.19.</span> <span class="nav-text">Class文件包括哪些</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.1.</span> <span class="nav-text">ClassLoader相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">简单说说你了解的类加载器，可以打破双亲委派么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%80%E7%BB%88%E6%98%AF%E7%94%B1%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%98%E6%98%AF%E5%AD%90%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">双亲委派最终是由父类加载还是子类加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%AD%90%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%8A%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">父类加载器和子类加载器在代码上是什么关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E6%83%B3%E8%87%AA%E5%B7%B1%E6%8E%A7%E5%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">如果我想自己控制类加载的时机怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAjava-lang-String%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">如果创建一个java.lang.String类，这个类是否可以被类加载器加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">JVM是如何处理异常的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finnal%E3%80%81finnally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.1.7.</span> <span class="nav-text">finnal、finnally、finalize的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Garbage-Collection"><span class="nav-number">1.6.2.</span> <span class="nav-text">Garbage Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK8-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">JDK8 的默认垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF-GC"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">对象是否可 GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%90%AF%E5%8A%A8"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">GC什么时候启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutator"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">Mutator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">基本算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">垃圾收集器有哪几种</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E5%92%8C%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">标记复制和标记整理算法的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%AE%80%E8%BF%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.2.8.</span> <span class="nav-text">CMS是什么，简述工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.2.9.</span> <span class="nav-text">CMS新生代老年代算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E8%83%8C%E5%90%8E%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">1.6.2.10.</span> <span class="nav-text">为什么要分代回收，分代回收背后的思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E7%BC%BA%E9%99%B7"><span class="nav-number">1.6.2.11.</span> <span class="nav-text">CMS缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E5%9B%9E%E6%94%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9C%E9%A1%BF%E4%B8%A4%E6%AC%A1"><span class="nav-number">1.6.2.12.</span> <span class="nav-text">CMS回收为什么要停顿两次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Young-GC-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9D%97%EF%BC%8CEden%E5%88%B0S0-%E8%BF%98%E6%98%AF-S1%E5%8C%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E9%9A%8F%E6%9C%BA%E8%BF%98%E6%98%AF%E7%A1%AE%E5%AE%9A%E7%9A%84"><span class="nav-number">1.6.2.13.</span> <span class="nav-text">Young GC 的时候，主要操作哪些区块，Eden到S0 还是 S1区的过程是随机还是确定的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%85%8D%E7%BD%AE%E4%BA%86CMS-GC%E4%BB%8D%E7%84%B6%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC"><span class="nav-number">1.6.2.14.</span> <span class="nav-text">为什么配置了CMS GC仍然会触发Full GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.6.2.15.</span> <span class="nav-text">G1的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E7%9A%84region%E8%A2%AB%E5%9B%9E%E6%94%B6%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84"><span class="nav-number">1.6.2.16.</span> <span class="nav-text">G1的region被回收之后怎么解决内存碎片的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-GC-%E5%86%99%E5%B1%8F%E9%9A%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.2.17.</span> <span class="nav-text">G1 GC 写屏障原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-GC%E7%9A%84Card-Table%E3%80%81Remembered-Set%E5%92%8C%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%BD%AC%E7%A7%BB%E5%AF%B9%E8%B1%A1%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.2.18.</span> <span class="nav-text">G1 GC的Card Table、Remembered Set和存活对转移对象原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B9%B4%E8%BD%BB%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.2.19.</span> <span class="nav-text">G1垃圾回收器年轻代、老年代回收原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E8%B0%83%E4%BC%98"><span class="nav-number">1.6.2.20.</span> <span class="nav-text">GC调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.21.</span> <span class="nav-text">内存泄漏和内存溢出区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%91%E7%B9%81Young-GC%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.6.2.22.</span> <span class="nav-text">频繁Young GC原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%87%BA%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E8%A7%A3%E5%86%B3"><span class="nav-number">1.6.2.23.</span> <span class="nav-text">如果出程序出现内存溢出，如何排查解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven%E7%9B%B8%E5%85%B3"><span class="nav-number">1.7.</span> <span class="nav-text">Maven相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Maven%E4%B8%ADdependencyManagement%E4%BD%9C%E7%94%A8"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">Maven中dependencyManagement作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96B%E6%A8%A1%E5%9D%971-0%E7%89%88%E6%9C%AC%EF%BC%8CC%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96B%E6%A8%A1%E5%9D%971-1%E7%89%88%E6%9C%AC%EF%BC%8C%E7%8E%B0%E5%9C%A8A%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96C%E6%A8%A1%E5%9D%97%EF%BC%8C%E9%97%AE%E4%BE%9D%E8%B5%96B%E6%A8%A1%E5%9D%97%E5%A4%9A%E5%B0%91%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">A模块依赖B模块1.0版本，C模块依赖B模块1.1版本，现在A模块依赖C模块，问依赖B模块多少版本？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.8.</span> <span class="nav-text">Spring 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RestController%E4%B8%8EController%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">RestController与Controller区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestBody%E4%B8%8EResponseBody%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">RequestBody与ResponseBody区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">Spring底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.0.4.</span> <span class="nav-text">Spring事务底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC%E7%90%86%E8%A7%A3"><span class="nav-number">1.8.0.5.</span> <span class="nav-text">IOC理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC%E4%B8%BB%E8%A6%81%E5%AE%B9%E5%99%A8"><span class="nav-number">1.8.0.6.</span> <span class="nav-text">IOC主要容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.0.7.</span> <span class="nav-text">Spring生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Bean%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.8.0.8.</span> <span class="nav-text">Spring Bean加载初始化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.0.9.</span> <span class="nav-text">AOP原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">1.8.0.10.</span> <span class="nav-text">注解底层实现流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory%E4%B8%8EFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.0.11.</span> <span class="nav-text">BeanFactory与FactoryBean的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Beanfactory%E5%92%8CApplicationContext%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.0.12.</span> <span class="nav-text">Beanfactory和ApplicationContext是什么关系，使用有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9A%E5%92%8CB%E4%B8%A4%E4%B8%AAbean%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.8.0.13.</span> <span class="nav-text">Spring 中如何让A和B两个bean按顺序加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E4%B8%ADBean%E9%BB%98%E8%AE%A4%E6%98%AFSingleton%E8%BF%98%E6%98%AF%E5%A4%9A%E6%80%81%E7%9A%84"><span class="nav-number">1.8.0.14.</span> <span class="nav-text">Spring中Bean默认是Singleton还是多态的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4Singleton"><span class="nav-number">1.8.0.15.</span> <span class="nav-text">为什么默认Singleton</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Scope%E6%8F%90%E4%BE%9Bprototype%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.0.16.</span> <span class="nav-text">为什么@Scope提供prototype类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.8.0.17.</span> <span class="nav-text">Spring如何自定义注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC"><span class="nav-number">1.8.1.</span> <span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">SpringMVC工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">SpringMVC组件工作流程，如果不这么设计会有什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%93%BE%E8%B7%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%B9%E6%B3%95%E6%AF%94%E5%AF%B9"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">检查拦截器的执行链路在哪个方法比对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">Spring有几种依赖注入方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.1.5.</span> <span class="nav-text">Spring有几种异步调用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E4%B8%AD%E7%9A%84SPI%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FSpring-%E5%AE%9E%E7%8E%B0%E7%9A%84SPI%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="nav-number">1.8.1.6.</span> <span class="nav-text">JDK中的SPI机制是怎么实现的？Spring 实现的SPI了解过吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%86%85%E9%83%A8%EF%BC%8C%E6%88%91%E6%83%B3%E7%94%A8%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95-A%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95B%EF%BC%8C%E6%83%B3%E5%AF%B9%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95B%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.8.1.7.</span> <span class="nav-text">如果在一个类内部，我想用某个方法 A调用另一个方法B，想对被调用的方法B进行一个切面，怎么处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1"><span class="nav-number">1.8.1.8.</span> <span class="nav-text">CSRF攻击是什么，原理以及如何防御</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.8.1.9.</span> <span class="nav-text">如何解决跨域，原理是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.1.10.</span> <span class="nav-text">RPC进程通信方式有哪些方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.1.11.</span> <span class="nav-text">SpringMVC的跳转与重定向区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-RestTemplate%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.1.12.</span> <span class="nav-text">Spring RestTemplate的具体实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JDBC%E6%AD%A5%E9%AA%A4mysql%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F-spring-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.8.1.13.</span> <span class="nav-text">为什么 JDBC步骤mysql数据存储格式 spring 相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC-%E6%BA%90%E7%A0%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.8.1.14.</span> <span class="nav-text">JDBC 源码如何实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E4%B8%AD%E7%9A%84session%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E7%9A%84"><span class="nav-number">1.8.1.15.</span> <span class="nav-text">SpringMVC中的session如何拿到的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8xml%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5Bean"><span class="nav-number">1.8.1.16.</span> <span class="nav-text">不使用xml不使用注解如何动态注入Bean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.8.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%EF%BC%8C%E8%A2%AB%E8%B0%83%E7%94%A8%E7%B1%BB%E5%B7%B2Catch%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%BA%E4%BD%95-Transactional%E4%BB%8D%E7%84%B6%E5%9B%9E%E6%BB%9A"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">Service相互调用，被调用类已Catch异常，为何@Transactional仍然回滚</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%89%B4%E6%9D%83"><span class="nav-number">1.8.3.</span> <span class="nav-text">鉴权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Security%E5%92%8CShiro%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">Spring Security和Shiro区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JWT-%E5%AF%B9%E6%AF%94-cookie-%E5%92%8C-session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">JWT 对比 cookie 和 session 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BECookie%E5%90%97"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">Session可以存放Cookie吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSO%E4%B8%8EOAuth2-0%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">SSO与OAuth2.0区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E4%B8%80%E8%88%AC%E9%80%89%E6%8B%A9%E7%94%A8Jwt%E8%BF%98%E6%98%AF-Redis"><span class="nav-number">1.8.3.5.</span> <span class="nav-text">登录一般选择用Jwt还是 Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%BB%AD%E6%9C%9F%E4%BD%A0%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E9%9A%BE%E4%B8%8D%E6%88%90%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E9%83%BD%E9%87%8D%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%97%EF%BC%9F%E8%BF%99%E4%B8%8D%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">1.8.3.6.</span> <span class="nav-text">Redis 续期你们是怎么做的？难不成每次请求都重置过期时间吗？这不会存在一个安全问题吗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.9.</span> <span class="nav-text">SpringBoot 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">SpringBoot 的启动原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.9.0.3.</span> <span class="nav-text">SpringBoot 生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%9F%E6%8E%A8%E8%8D%90%E5%92%8C%E9%BB%98%E8%AE%A4%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="nav-number">1.9.0.4.</span> <span class="nav-text">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-Starter%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.0.5.</span> <span class="nav-text">SpringBoot Starter的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.0.6.</span> <span class="nav-text">SpringBoot 自动装配原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean%E6%B3%A8%E8%A7%A3%E5%92%8C-Component%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.0.7.</span> <span class="nav-text">@Bean注解和@Component区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.0.8.</span> <span class="nav-text">SpringBoot事务的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.9.0.9.</span> <span class="nav-text">登陆的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.9.0.10.</span> <span class="nav-text">声明式事务失效原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9F%90%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%89%8D50%E6%AC%A1%E6%88%90%E5%8A%9F%EF%BC%8C%E7%AC%AC51%E6%AC%A1%E5%A4%B1%E8%B4%A5a%E5%85%A8%E9%83%A8%E5%9B%9E%E6%BB%9Ab%E5%89%8D50%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%AC%AC51%E6%AC%A1%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8Cab%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AESpring%EF%BC%88%E4%BC%A0%E6%92%AD%E6%80%A7%EF%BC%89"><span class="nav-number">1.9.0.11.</span> <span class="nav-text">执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%A8%8B%E5%BA%A6%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%B9%B6%E8%A1%8CSpring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.9.0.12.</span> <span class="nav-text">最大程度的模拟并行Spring的事务传播行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Async%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.0.13.</span> <span class="nav-text">Async异步调用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Spring-Boot-%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%90%E8%A1%8C%E4%B8%80%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="nav-number">1.9.0.14.</span> <span class="nav-text">如何在 Spring Boot 启动的时候运行一些特定的代码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.9.0.15.</span> <span class="nav-text">Spring Boot 有哪几种读取配置的方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bootstrap-properties-%E5%92%8C-application-properties-%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="nav-number">1.9.0.16.</span> <span class="nav-text">bootstrap.properties 和 application.properties 有何异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.0.17.</span> <span class="nav-text">跨域问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.9.0.18.</span> <span class="nav-text">SpringBoot异常处理相关注解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E9%85%8D%E7%BD%AE%E7%9B%91%E6%8E%A7"><span class="nav-number">1.9.0.19.</span> <span class="nav-text">SpringBoot配置监控?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1A%E3%80%81B%E3%80%81C%EF%BC%8C%E6%8C%82%E4%BA%86%E4%B8%80%E4%B8%AAA%EF%BC%8CRESTAPI%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93A%E6%8C%82%E4%BA%86%E5%B9%B6%E8%B0%83%E7%94%A8-B"><span class="nav-number">1.9.0.20.</span> <span class="nav-text">相同的服务A、B、C，挂了一个A，RESTAPI怎么知道A挂了并调用 B</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84session%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%8C%E8%83%BD%E5%90%A6%E7%94%A8redis-%E6%9B%BF%E4%BB%A3session"><span class="nav-number">1.9.0.21.</span> <span class="nav-text">前后端分离的session失效问题，能否用redis 替代session</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Cloud-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.10.</span> <span class="nav-text">Spring Cloud 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%EF%BC%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%EF%BC%9F"><span class="nav-number">1.10.0.1.</span> <span class="nav-text">为什么要进行系统拆分？如何进行系统拆分？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.10.0.2.</span> <span class="nav-text">什么是微服务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E9%80%9A%E8%AE%AF%E7%9A%84%EF%BC%9F"><span class="nav-number">1.10.0.3.</span> <span class="nav-text">微服务之间是如何独立通讯的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.10.0.4.</span> <span class="nav-text">微服务架构优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%80%9A%E4%BF%A1"><span class="nav-number">1.10.0.5.</span> <span class="nav-text">服务之间如何快速通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B7%B1%E5%BA%A6%E8%B0%83%E7%94%A8"><span class="nav-number">1.10.0.6.</span> <span class="nav-text">怎么避免微服务深度调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenFeign%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.0.7.</span> <span class="nav-text">OpenFeign底层调用原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ribbon%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.0.8.</span> <span class="nav-text">Ribbon的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD"><span class="nav-number">1.10.0.9.</span> <span class="nav-text">Sentinel如何实现熔断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Boot-%E5%92%8C-Spring-Cloud%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.10.0.10.</span> <span class="nav-text">Spring Boot 和 Spring Cloud，谈谈你对它们的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%9F%E8%AE%A1-QPS%E6%8C%87%E6%A0%87%E8%BE%BE%E5%88%B0%E9%99%90%E6%B5%81%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AF%B7%E6%B1%82%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E5%86%85%EF%BC%9F"><span class="nav-number">1.10.0.11.</span> <span class="nav-text">Sentinel内部是怎么统计 QPS指标达到限流的目的？滑动窗口算法的实现？如何判断请求在哪个时间窗口内？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E6%B5%81%EF%BC%9F%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.10.0.12.</span> <span class="nav-text">如何限流？在工作中是怎么做的？说一下具体的实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F-Session-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.10.0.13.</span> <span class="nav-text">集群分布式 Session 如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.10.0.14.</span> <span class="nav-text">如何设计一个高并发的系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFC10K%E9%97%AE%E9%A2%98%EF%BC%8C%E5%90%8E%E6%9D%A5%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="nav-number">1.10.0.15.</span> <span class="nav-text">请解释一下什么是C10K问题，后来是怎么解决的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E9%99%A4%E4%BA%86%E5%8A%A0%E9%94%81%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.10.0.16.</span> <span class="nav-text">高并发除了加锁还有什么解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Cloud-%E5%92%8C-Dubbo-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.10.0.17.</span> <span class="nav-text">Spring Cloud 和 Dubbo 有哪些区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Eureka%E5%92%8Czookeeper%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%B8%A4%E4%B8%AA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.10.0.18.</span> <span class="nav-text">Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringCloud%E5%87%A0%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">1.10.0.19.</span> <span class="nav-text">SpringCloud几个组件主要功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-Binder%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.10.0.20.</span> <span class="nav-text">Stream Binder是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%EF%BC%88%E5%A6%82GateWay%E3%80%81Sentinal%EF%BC%89"><span class="nav-number">1.10.0.21.</span> <span class="nav-text">分布式微服务的组件和底层代码（如GateWay、Sentinal）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fsession%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.10.0.22.</span> <span class="nav-text">分布式session设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fsession%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.10.0.23.</span> <span class="nav-text">分布式session一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1%E3%80%8C%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E6%89%A3%E6%AC%BE%E3%80%8D"><span class="nav-number">1.10.0.24.</span> <span class="nav-text">分布式接口的幂等性设计「不能重复扣款」</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.10.0.25.</span> <span class="nav-text">如何实现分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.10.0.26.</span> <span class="nav-text">设计一个高并发秒杀系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.10.0.27.</span> <span class="nav-text">服务熔断怎么设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%A6%823%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%B8%80%E5%8F%B0%E5%AE%95%E6%9C%BA%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%BF%99%E7%A7%8D%E7%8E%B0%E8%B1%A1"><span class="nav-number">1.10.0.28.</span> <span class="nav-text">微服务高可用如何设计，如3台服务器，一台宕机如何防止这种现象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper"><span class="nav-number">1.10.1.</span> <span class="nav-text">Zookeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Zookeeper%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">Zookeeper有哪些用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zookeeper%E4%BF%9D%E8%AF%81%E7%9A%84CP%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E7%9A%84"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">zookeeper保证的CP，如何保障的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E6%9C%8D%E5%92%8C%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%85%AC%E7%94%A8%E4%B8%80%E4%B8%AAzookeeper%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E4%BA%A4%E5%8F%89%E6%B6%88%E8%B4%B9"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">正式服和测试服公用一个zookeeper，怎么解决交叉消费</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo"><span class="nav-number">1.10.2.</span> <span class="nav-text">Dubbo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E4%B8%8ESpring-Cloud%E5%85%B3%E7%B3%BB"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">Dubbo与Spring Cloud关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">Dubbo 负载均衡策略都有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E5%B8%A6%E5%9B%BE%EF%BC%89"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">Dubbo 的工作原理？（带图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">Dubbo服务发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E3%80%81%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E4%BB%A5%E5%8F%8A%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%EF%BC%9F"><span class="nav-number">1.10.2.5.</span> <span class="nav-text">Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E8%B6%85%E6%97%B6%E5%86%85%E9%83%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%B0%83%E7%94%A8%E6%96%B9%E5%B7%B2%E7%BB%8F%E8%B6%85%E6%97%B6%E4%BA%A7%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BA%86%EF%BC%8C%E6%8F%90%E4%BE%9B%E8%80%85%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E8%BF%98%E4%BC%9A%E5%90%91%E8%B0%83%E7%94%A8%E6%96%B9%E5%86%99%E8%BF%94%E5%9B%9E%E5%80%BC%E5%90%97"><span class="nav-number">1.10.2.6.</span> <span class="nav-text">Dubbo超时内部怎么实现的？如果调用方已经超时产生异常了，提供者执行完毕后还会向调用方写返回值吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%EF%BC%9BDubbo%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.10.2.7.</span> <span class="nav-text">Dubbo超时重试；Dubbo超时时间设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.10.2.8.</span> <span class="nav-text">如何保障请求执行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E4%BD%A0%E4%BB%AC%E7%9A%84dubbo-%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6%E7%9A%84%E6%83%85%E6%99%AF"><span class="nav-number">1.10.2.9.</span> <span class="nav-text">怎么处理外部调用你们的dubbo 接口超时的情景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E4%B8%AD%E7%83%AD%E6%8F%92%E6%8B%94%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%AB%E5%9B%9E%E6%94%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.10.2.10.</span> <span class="nav-text">Dubbo中热插拔导致的资源末回收怎么处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-%E7%9A%84-SPI-%E5%92%8C-Java-%E7%9A%84-SPI-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.10.2.11.</span> <span class="nav-text">Dubbo 的 SPI 和 Java 的 SPI 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E6%80%A7"><span class="nav-number">1.10.2.12.</span> <span class="nav-text">Dubbo组件之间的关联性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC-Dubbo-%E7%9A%84-RPC-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="nav-number">1.10.2.13.</span> <span class="nav-text">如何自己设计一个类似 Dubbo 的 RPC 框架？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gRpc"><span class="nav-number">1.10.3.</span> <span class="nav-text">gRpc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gRpc%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">gRpc是什么，有什么优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRpc%E5%92%8CRest%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">gRpc和Rest区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">gRPC用的是什么协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8protoBuf%E4%BD%9C%E4%B8%BA%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%B7%9F%E5%85%B6%E4%BB%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%89%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="nav-number">1.10.3.4.</span> <span class="nav-text">gRPC为什么使用protoBuf作为序列化机制，跟其他二进制有比有什么优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.10.3.5.</span> <span class="nav-text">gRPC流程是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.10.3.6.</span> <span class="nav-text">gRPC支持哪些类型的序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.10.4.</span> <span class="nav-text">分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E6%8C%81"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">分布式事务，缓存和数据库的一致性保持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1Linerizebility%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B8%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">分布式事务如何实现事务Linerizebility？有哪些典型方法，各自有什么优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Seata%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">Seata配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Seata%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.4.4.</span> <span class="nav-text">Seata模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Seata%E6%B5%81%E7%A8%8B"><span class="nav-number">1.10.4.5.</span> <span class="nav-text">Seata流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Seata-AT%E6%A8%A1%E5%BC%8F%E4%B8%A4%E9%98%B6%E6%AE%B5%E8%BF%87%E7%A8%8B"><span class="nav-number">1.10.4.6.</span> <span class="nav-text">Seata AT模式两阶段过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E6%89%A3%E6%AC%BE%E4%B8%8D%E8%A6%81%E5%87%BA%E7%8E%B0%E8%B4%9F%E6%95%B0%EF%BC%89"><span class="nav-number">1.10.4.7.</span> <span class="nav-text">分布式事务与分布式锁（扣款不要出现负数）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nacos"><span class="nav-number">1.10.5.</span> <span class="nav-text">Nacos</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E4%BD%9C%E7%94%A8"><span class="nav-number">1.10.5.1.</span> <span class="nav-text">Nacos作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.10.5.2.</span> <span class="nav-text">Nacos优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos-1-x%E7%89%88%E6%9C%AC%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.5.3.</span> <span class="nav-text">Nacos 1.x版本作为注册中心原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%98%AF-AP%E8%BF%98%E6%98%AFCP"><span class="nav-number">1.10.5.4.</span> <span class="nav-text">Nacos注册中心是 AP还是CP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E5%92%8CErueka%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.5.5.</span> <span class="nav-text">Nacos和Erueka区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E5%92%8CZookeeper%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.5.6.</span> <span class="nav-text">Nacos和Zookeeper区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E5%92%8CApollo%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.5.7.</span> <span class="nav-text">Nacos和Apollo区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AANacos%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%98%AF%E5%9C%A8%E4%B8%80%E4%B8%AAnameSpace%E4%B8%8B%E5%8F%88%E5%A6%82%E4%BD%95%E9%9A%94%E7%A6%BB%EF%BC%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%89%8D%E7%AB%AF%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E5%90%8E%E7%AB%AF"><span class="nav-number">1.10.5.8.</span> <span class="nav-text">一个Nacos如何进行不同环境隔离？如果是在一个nameSpace下又如何隔离？开发环境下，前端怎么调用指定的后端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nacos%E5%92%8Ceuraka%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.5.9.</span> <span class="nav-text">Nacos和euraka的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.11.</span> <span class="nav-text">MQ 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.1.</span> <span class="nav-text">通用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E9%80%89%E5%9E%8B"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">MQ选型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Product-A%E3%80%81C%EF%BC%8CFollower-B%E3%80%81D%EF%BC%8CBind-AC-BD-Exchange%EF%BC%89"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">手写生产者消费者（Product A、C，Follower B、D，Bind AC &amp;&amp; BD + Exchange）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%94%A8%E8%BF%87%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%BD%93%E5%88%9D%E9%80%89%E5%9E%8B%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E8%80%83%E8%99%91%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">项目上用过消息队列吗？用过哪些？当初选型基于什么考虑的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E9%83%A8%E7%BD%B2%E6%98%AF%E5%8D%95%E6%9C%BA%E8%BF%98%E6%98%AF%E9%9B%86%E7%BE%A4%E5%91%A2%EF%BC%9F%E4%BD%A0%E4%BB%AC%E9%AB%98%E5%8F%AF%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.11.1.5.</span> <span class="nav-text">MQ部署是单机还是集群呢？你们高可用是怎么保证的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.11.1.6.</span> <span class="nav-text">MQ有遇到过重复消费的问题吗？怎么解决的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MQ%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%91%A2%EF%BC%9F"><span class="nav-number">1.11.1.7.</span> <span class="nav-text">MQ有遇到过消息丢失吗？可靠性怎么保证呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%BB%A5%E5%90%8E%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.11.1.8.</span> <span class="nav-text">如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.11.1.9.</span> <span class="nav-text">如何保证消息的一致性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka%E7%9B%B8%E5%85%B3"><span class="nav-number">1.11.2.</span> <span class="nav-text">Kafka相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E7%89%B9%E6%80%A7"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">Kafka特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8zookeeper%E5%90%97"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">Kafka可以不用zookeeper吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka-%E7%9A%84-partition%E5%92%8C-block"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">Kafka 的 partition和 block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.2.4.</span> <span class="nav-text">Kafka底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%9C%BA%E5%88%B6"><span class="nav-number">1.11.2.5.</span> <span class="nav-text">Kafka机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.11.2.6.</span> <span class="nav-text">Kafka事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="nav-number">1.11.2.7.</span> <span class="nav-text">如何处理消息堆积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9Kafka%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.11.2.8.</span> <span class="nav-text">如何高并发顺序消费Kafka中的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">1.11.2.9.</span> <span class="nav-text">Kafka消息顺序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84"><span class="nav-number">1.11.2.10.</span> <span class="nav-text">Kafka如何管理偏移量的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%8C%81%E4%B9%85%E5%8C%96%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E9%99%A4%E4%BA%86%E8%BF%81%E7%A7%BB%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.11.2.11.</span> <span class="nav-text">Kafka持久化内存满了除了迁移还能怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.11.2.12.</span> <span class="nav-text">零拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap%E5%92%8CsendFile%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.2.13.</span> <span class="nav-text">mmap和sendFile区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.2.14.</span> <span class="nav-text">Kafka的索引使用的是什么数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B%E6%97%B6%EF%BC%8CPageCache%E6%B1%A1%E6%9F%93%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.11.2.15.</span> <span class="nav-text">Kafka消费过程时，PageCache污染原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Kafka%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%BB%B6%E6%97%B6"><span class="nav-number">1.11.2.16.</span> <span class="nav-text">如何理解Kafka的端到端延时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.2.17.</span> <span class="nav-text">Kafka数据丢失解决方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F"><span class="nav-number">1.11.2.18.</span> <span class="nav-text">Kafka如何保证消息有序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E9%A1%BA%E5%BA%8F%E8%AF%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">1.11.2.19.</span> <span class="nav-text">Kafka顺序读为什么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E9%A1%BA%E5%BA%8F%E5%86%99%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">1.11.2.20.</span> <span class="nav-text">Kafka顺序写为什么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E4%BB%8E%E8%AE%BE%E8%AE%A1%E4%B8%8A%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.11.2.21.</span> <span class="nav-text">Kafka从设计上怎么保证吞吐量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RocketMQ%E7%9B%B8%E5%85%B3"><span class="nav-number">1.11.3.</span> <span class="nav-text">RocketMQ相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">RocketMQ如何保证消息不丢失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">RocketMQ支持哪些消息类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E7%9A%84Consumer%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.11.3.3.</span> <span class="nav-text">RocketMQ的Consumer用的什么模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%EF%BC%9F%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A%E6%AF%94%E5%A6%82%E4%B8%8B%E5%8D%95%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%EF%BC%8C%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="nav-number">1.11.3.4.</span> <span class="nav-text">RocketMQ事务消息是否了解？场景题：比如下单清空购物车，你是如何设计的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Zookeeper%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-number">1.11.3.5.</span> <span class="nav-text">RocketMQ为什么不用Zookeeper作为注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%A6%81%E5%9C%A8Broker%E7%AB%AF%E9%94%81%E5%AE%9A%E8%AF%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E4%BF%9D%E8%AF%81%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E4%BC%9A%E8%8E%B7%E5%BE%97%E8%AF%A5%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97"><span class="nav-number">1.11.3.6.</span> <span class="nav-text">RocketMQ保证顺序消费，为何要在Broker端锁定该消息队列，保证只有一个消费者会获得该消费队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E5%A6%82%E6%9E%9C%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84A%E4%B8%8B%E9%9D%A2%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%B6%88%E8%B4%B9%E7%BB%84A1%EF%BC%8CA2%EF%BC%8C%E9%97%AE%E6%B6%88%E8%B4%B9%E8%80%85A1%E5%92%8CA2%E6%98%AF%E5%90%A6%E6%B6%88%E8%B4%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%BB%E9%A2%98"><span class="nav-number">1.11.3.7.</span> <span class="nav-text">RocketMQ如果消费者组A下面有两个消费组A1，A2，问消费者A1和A2是否消费不同的主题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.11.3.8.</span> <span class="nav-text">RocketMQ如何保证事务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ%E7%9B%B8%E5%85%B3"><span class="nav-number">1.11.4.</span> <span class="nav-text">RabbitMQ相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RabbitMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E6%B6%88%E6%81%AF"><span class="nav-number">1.11.4.1.</span> <span class="nav-text">RabbitMQ 如何保证不丢消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RabbitMQ%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.11.4.2.</span> <span class="nav-text">RabbitMQ交换机有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="nav-number">1.11.4.3.</span> <span class="nav-text">RabbitMQ如何顺序消费</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.12.</span> <span class="nav-text">Cache 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">1.12.1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%9A%84String-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">Redis 的String 是如何实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-GEOSEARCH%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">Redis GEOSEARCH数据结构怎样的，底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80-hyperloglogs%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">Set底层结构是什? hyperloglogs了解吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Hash%E4%B8%8EJava-HashMap%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.1.4.</span> <span class="nav-text">Redis Hash与Java HashMap区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5%E5%92%8C%E9%9B%86%E7%BE%A4%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.1.5.</span> <span class="nav-text">Redis主从、哨兵和集群区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.12.1.6.</span> <span class="nav-text">Redis事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84"><span class="nav-number">1.12.1.7.</span> <span class="nav-text">Redis为什么是原子性的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">1.12.1.8.</span> <span class="nav-text">Redis为什么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.1.9.</span> <span class="nav-text">Redis底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="nav-number">1.12.1.10.</span> <span class="nav-text">Redis如何更新缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%A6%82%E4%BD%95%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-number">1.12.1.11.</span> <span class="nav-text">Redis如何内存优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="nav-number">1.12.1.12.</span> <span class="nav-text">Redis数据一致性怎么做的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Hashtable-%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="nav-number">1.12.1.13.</span> <span class="nav-text">Redis Hashtable 如何扩容的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1Redis-Slot%E7%BB%93%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">1.12.1.14.</span> <span class="nav-text">为什么要设计Redis Slot结构，如何查找数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84%E5%93%88%E5%B8%8C%E6%A7%BD%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%B8%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95"><span class="nav-number">1.12.1.15.</span> <span class="nav-text">Redis的哈希槽算法和哈希一致性算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-rehash%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%97%A7hash%E6%95%B0%E6%8D%AE%E8%A2%AB%E8%AE%BF%E9%97%AE%E5%90%8E%E4%BC%9A%E6%8A%8A%E8%AF%A5%E6%95%B0%E6%8D%AECopy%E5%88%B0%E6%96%B0%E8%A1%A8%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%A5%E5%8D%95%E6%9D%A1%E6%95%B0%E6%8D%AE%E4%B8%BA%E7%B2%92%E5%BA%A6%E8%BF%98%E6%98%AF%E4%BB%A5%E6%A1%B6%E4%B8%BA%E7%B2%92%E5%BA%A6%E6%8B%B7%E8%B4%9D%E7%9A%84"><span class="nav-number">1.12.1.16.</span> <span class="nav-text">Redis rehash过程中，旧hash数据被访问后会把该数据Copy到新表，这个过程是以单条数据为粒度还是以桶为粒度拷贝的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BARedis%E4%B8%AD%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95"><span class="nav-number">1.12.1.17.</span> <span class="nav-text">如何找出Redis中的慢查询记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-List%E8%BF%87%E5%A4%A7%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="nav-number">1.12.1.18.</span> <span class="nav-text">Redis List过大如何优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9Redis%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84"><span class="nav-number">1.12.1.19.</span> <span class="nav-text">你们是如何对Redis进行性能优化的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-%E4%BD%BF%E7%94%A8-Redis-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8-Memcached"><span class="nav-number">1.12.1.20.</span> <span class="nav-text">为什么 使用 Redis 而不是用 Memcached</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84Set%E5%BA%95%E5%B1%82%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AFHash%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E8%B7%B3%E8%A1%A8"><span class="nav-number">1.12.1.21.</span> <span class="nav-text">Redis的Set底层什么时候是Hash什么时候是跳表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.12.1.22.</span> <span class="nav-text">ZSet数据结构以及空间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8%E5%8E%9F%E7%90%86%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.1.23.</span> <span class="nav-text">跳跃列表原理怎么实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#quickList%E5%92%8CzipList%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.1.24.</span> <span class="nav-text">quickList和zipList原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zipList%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.12.1.25.</span> <span class="nav-text">zipList时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%80%8E%E4%B9%88%E5%81%9A%E9%99%90%E6%B5%81"><span class="nav-number">1.12.1.26.</span> <span class="nav-text">Redis怎么做限流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.12.1.27.</span> <span class="nav-text">Redis异步消息怎么处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-5-0-%E6%96%B0%E5%A2%9EStream%E5%AF%B9%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3"><span class="nav-number">1.12.1.28.</span> <span class="nav-text">Redis 5.0 新增Stream对它有什么理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88redis7%E7%94%A8listpack%E5%8F%96%E4%BB%A3ziplist"><span class="nav-number">1.12.1.29.</span> <span class="nav-text">为什么redis7用listpack取代ziplist</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4Redis-key%E5%AF%BC%E8%87%B4Redis%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.12.1.30.</span> <span class="nav-text">大批量删除Redis key导致Redis不稳定如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">1.12.1.31.</span> <span class="nav-text">如何保证Redis高并发、高可用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.12.1.32.</span> <span class="nav-text">Redis持久化机制，以及优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E7%9A%84%E6%96%87%E4%BB%B6%E7%89%B9%E5%88%AB%E5%A4%A7%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.12.1.33.</span> <span class="nav-text">AOF的文件特别大的时候有什么解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.12.1.34.</span> <span class="nav-text">Redis回收进程如何工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.12.1.35.</span> <span class="nav-text">雪崩、穿透、击穿问题怎么解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bloom%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.1.36.</span> <span class="nav-text">Bloom过滤器原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.12.1.37.</span> <span class="nav-text">Redis的内存用完了会发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E7%BC%93%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="nav-number">1.12.1.38.</span> <span class="nav-text">在项目里面缓存是怎么用的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%88%90%E7%BB%A9%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.12.1.39.</span> <span class="nav-text">用Redis实现一个成绩的排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%A4%A7key%E5%88%A0%E9%99%A4%E6%97%B6%E5%AE%B9%E6%98%93%E6%8A%8Aredis-%E6%90%9E%E5%B4%A9%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.12.1.40.</span> <span class="nav-text">Redis 大key删除时容易把redis 搞崩，怎么解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%EF%BC%8Credis%E5%92%8Cmysql%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="nav-number">1.12.1.41.</span> <span class="nav-text">高并发下，redis和mysql双写一致性如何保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Cluster%EF%BC%8C%E5%9C%A8Master%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%BF%94%E5%9B%9E%E5%90%8E%EF%BC%8C%E5%90%91%E8%8A%82%E7%82%B9%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%89%8DMaster%E6%8C%82%E4%BA%86%EF%BC%8C%E5%AD%90%E8%8A%82%E7%82%B9%E5%8D%87%E7%BA%A7%E5%90%8E%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4"><span class="nav-number">1.12.1.42.</span> <span class="nav-text">Redis Cluster，在Master节点执行命令返回后，向节点同步之前Master挂了，子节点升级后数据如何保证一致</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">1.12.1.43.</span> <span class="nav-text">Redis 存在线程安全问题吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.1.44.</span> <span class="nav-text">Redis主从复制原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%83%BD%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">1.12.1.45.</span> <span class="nav-text">一个字符串类型的值能存储最大容量是多少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PipeLine%E5%A5%BD%E5%A4%84"><span class="nav-number">1.12.1.46.</span> <span class="nav-text">PipeLine好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%A4%A7%E9%87%8FKey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%97%B6%E8%AE%BF%E9%97%AERedis%E5%85%B6%E4%BB%96Key%E6%9C%89%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.12.1.47.</span> <span class="nav-text">Redis 大量Key集中过期，为什么这时访问Redis其他Key有延迟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%9C%A810%EF%BC%9A05-%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%80%BC%EF%BC%8C%E5%B9%B6%E7%BB%99%E5%87%BA5%E5%88%86%E9%92%9F%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%88%9A%E5%88%9Aset%E5%AE%8C%E4%B9%8B%E5%90%8Eredis%E9%9B%86%E7%BE%A4%E5%B4%A9%E6%BA%83%EF%BC%8C10%EF%BC%9A11%E5%88%86%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%90%AF%E6%88%90%E5%8A%9F%EF%BC%8C%E9%82%A3%E4%B9%88redis%E4%B8%ADset%E7%9A%84%E5%80%BC%E6%98%AF%E5%90%A6%E8%BF%98%E5%AD%98%E5%9C%A8"><span class="nav-number">1.12.1.48.</span> <span class="nav-text">系统在10：05 设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-%E9%87%8C%E6%9C%89-2000w-%E6%95%B0%E6%8D%AE%EF%BC%8CRedis-%E4%B8%AD%E5%8F%AA%E5%AD%98-20w-%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">1.12.1.49.</span> <span class="nav-text">MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Cluster%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.12.1.50.</span> <span class="nav-text">Redis Cluster数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Redis-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.1.51.</span> <span class="nav-text">基于 Redis 的分布式锁会有什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%B6%85%E6%97%B6%E5%8F%AF%E4%BB%A5%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E8%AE%BE%E9%95%BF%E4%B8%80%E7%82%B9%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%9A%84%E8%AF%9D%E9%9C%80%E8%A6%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">1.12.1.52.</span> <span class="nav-text">Redis 分布式锁超时可以超时时间设长一点可以吗？不可以的话需要怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E9%94%81%E7%BB%AD%E6%9C%9F%E8%BF%99%E4%B8%AA%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.1.53.</span> <span class="nav-text">Redis 锁续期这个怎么实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E5%92%8C-Redis-Cluster-%E4%B8%AD%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.1.54.</span> <span class="nav-text">在主从模式和 Redis Cluster 中分布式锁会有什么问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redission"><span class="nav-number">1.12.2.</span> <span class="nav-text">Redission</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Hash-Slot%E6%A6%82%E5%BF%B5"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">Redis Hash Slot概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">Redis 分布式锁怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C-zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">Redis 分布式锁和 zookeeper 分布式锁区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedLock%E7%BA%A2%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">RedLock红锁算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redission%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">Redission细节源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.12.2.6.</span> <span class="nav-text">分布式锁超时问题怎么解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataBase%E7%9B%B8%E5%85%B3"><span class="nav-number">1.13.</span> <span class="nav-text">DataBase相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.13.0.1.</span> <span class="nav-text">如何设计数据库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.13.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OLTP%E4%B8%8EOLAP%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">OLTP与OLAP联系与区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">索引优化如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="nav-number">1.13.1.3.</span> <span class="nav-text">主键是什么，有什么特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis%E7%9B%B8%E5%85%B3"><span class="nav-number">1.13.2.</span> <span class="nav-text">MyBatis相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%E3%80%81%E5%8A%A8%E6%80%81%E6%A0%87%E7%AD%BE"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">MyBatis传参方式、动态标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E7%BC%93%E5%AD%98"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">MyBatis缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis-mapper%E6%96%B9%E6%B3%95%E5%90%8D%E5%8F%AF%E4%BB%A5%E4%B8%80%E6%A0%B7%E5%90%97"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">MyBatis mapper方法名可以一样吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.13.2.4.</span> <span class="nav-text">MyBatis配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E6%AF%94JDBC%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="nav-number">1.13.2.5.</span> <span class="nav-text">MyBatis比JDBC有什么优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84"><span class="nav-number">1.13.2.6.</span> <span class="nav-text">MyBatis如何映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.13.2.7.</span> <span class="nav-text">MyBatis的运行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.2.8.</span> <span class="nav-text">MyBatis原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E5%A6%82%E4%BD%95%E5%88%86%E9%A1%B5"><span class="nav-number">1.13.2.9.</span> <span class="nav-text">MyBatis如何分页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SQL%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98"><span class="nav-number">1.13.2.10.</span> <span class="nav-text">MyBatis如何解决SQL注入问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">1.13.2.11.</span> <span class="nav-text">什么是数据库连接池，为什么要连接池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis-%E5%92%8Chibernate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.2.12.</span> <span class="nav-text">MyBatis 和hibernate的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.2.13.</span> <span class="nav-text">数据字典是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E5%87%BA%E7%8E%B0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="nav-number">1.13.2.14.</span> <span class="nav-text">MyBatis出现连接超时如何排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyBatis%E9%BB%98%E8%AE%A4%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">1.13.2.15.</span> <span class="nav-text">MyBatis默认连接数是多少</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-number">1.13.3.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="nav-number">1.13.3.1.</span> <span class="nav-text">IP地址如何在数据库中存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%AD-%E5%92%8C-%E6%98%AF%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.3.2.</span> <span class="nav-text">MySQL中#和$是什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%ADchar%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.3.3.</span> <span class="nav-text">MySQL中char和varchar的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="nav-number">1.13.3.4.</span> <span class="nav-text">普通索引和唯一索引的效率比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%BE%88%E9%AB%98%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%E5%A6%82%E4%BD%95%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.13.3.5.</span> <span class="nav-text">深度很高的树结构如何存入数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9E%8B%E8%A1%A8%E5%A6%82%E4%BD%95%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%8A"><span class="nav-number">1.13.3.6.</span> <span class="nav-text">一个大型表如何移动到另一个表上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%9F%A5%E8%AF%A2%E7%AA%81%E7%84%B6%E5%8F%98%E6%85%A2%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90"><span class="nav-number">1.13.3.7.</span> <span class="nav-text">SQL查询突然变慢如何分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90SLECT-FROM"><span class="nav-number">1.13.3.8.</span> <span class="nav-text">为什么不推荐SLECT * FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">1.13.3.9.</span> <span class="nav-text">SQL如何有效使用复合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exist%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.3.10.</span> <span class="nav-text">Exist和in的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.3.11.</span> <span class="nav-text">主键索引唯一索引区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%83%E4%B8%87DB%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.13.3.12.</span> <span class="nav-text">千万DB数据分页怎么处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">1.13.3.13.</span> <span class="nav-text">怎样防止SQL注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="nav-number">1.13.3.14.</span> <span class="nav-text">SQL查询的索引覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E8%BF%99%E4%B8%AA%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.13.3.15.</span> <span class="nav-text">数据库索引的实现，为什么选择这个实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.3.16.</span> <span class="nav-text">索引底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8CB-TREE%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E6%AF%94"><span class="nav-number">1.13.3.17.</span> <span class="nav-text">MySQL索引数据结构，B-TREE与二叉树对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">1.13.3.18.</span> <span class="nav-text">创建索引的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.13.3.19.</span> <span class="nav-text">表设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8"><span class="nav-number">1.13.3.20.</span> <span class="nav-text">联合索引什么时候使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%85%B3%E9%94%AE%E5%AD%97%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.13.3.21.</span> <span class="nav-text">SQL语句执行关键字顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E6%98%AF%E5%88%A9%E7%94%A8%E4%BA%86B-%E6%A0%91%E7%9A%84%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="nav-number">1.13.3.22.</span> <span class="nav-text">MySQL的最左匹配原则是利用了B+树的什么特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JOIN%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.3.23.</span> <span class="nav-text">JOIN的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.3.24.</span> <span class="nav-text">MySQL体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.3.25.</span> <span class="nav-text">MySQL 范围查询原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9FMyISAM%E4%B8%8EInnoDB%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.13.3.26.</span> <span class="nav-text">MySQL存储引擎？MyISAM与InnoDB区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E7%94%A8%E4%B8%BB%E9%94%AEID%E6%9F%A5%E6%89%BE%E6%97%B6-B-Tree%E5%92%8CB-Tree%E5%93%AA%E4%B8%AA%E5%BF%AB"><span class="nav-number">1.13.3.27.</span> <span class="nav-text">只用主键ID查找时 B+Tree和B-Tree哪个快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree%E6%A0%91%E8%8A%82%E7%82%B9%E5%85%B7%E4%BD%93%E5%AD%98%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.3.28.</span> <span class="nav-text">B+Tree树节点具体存什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E6%98%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E5%AE%9A%E6%98%AF%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E9%80%92%E5%A2%9E%E7%9A%84%E4%B9%88"><span class="nav-number">1.13.3.29.</span> <span class="nav-text">B+树是数据的顺序一定是从左到右递增的么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%88%86%E8%A3%82%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%8CB-%E6%A0%91%E7%9A%84%E5%80%92%E6%95%B0%E5%BA%95%E5%B1%82%E5%B1%82%E5%8F%AF%E4%BB%A5%E9%A1%B5%E5%88%86%E8%A3%82%E4%B9%88"><span class="nav-number">1.13.3.30.</span> <span class="nav-text">页分裂伪代码，B+树的倒数底层层可以页分裂么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%80%E9%A1%B5%E6%9C%80%E5%A4%A7%E5%AD%98%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE"><span class="nav-number">1.13.3.31.</span> <span class="nav-text">MySQL一页最大存多少数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%913%E5%B1%82%E7%9A%84%E8%AF%9D%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E9%87%8F%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.13.3.32.</span> <span class="nav-text">B+树3层的话可以存放多少量级的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96MySQL%E7%9A%84%E9%A1%B5%E5%88%86%E8%A3%82%E7%AE%97%E6%B3%95"><span class="nav-number">1.13.3.33.</span> <span class="nav-text">如何优化MySQL的页分裂算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%ADInnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">1.13.3.34.</span> <span class="nav-text">Mysql中InnoDB中的索引有什么特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E4%BA%8C%E6%AC%A1%E5%86%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.3.35.</span> <span class="nav-text">InnoDB二次写是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%AD%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.3.36.</span> <span class="nav-text">Mysql中聚簇索引和非聚簇索引的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%BA%93%E8%BF%98%E6%98%AF%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%A1%A8"><span class="nav-number">1.13.3.37.</span> <span class="nav-text">MySQL索引是作用于库还是作用于表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.3.38.</span> <span class="nav-text">建立联合索引的时候要注意什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.3.39.</span> <span class="nav-text">索引下推是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">1.13.3.40.</span> <span class="nav-text">MySQL执行语句流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BA%94%E8%AF%A5%E9%81%B5%E5%AE%88%E5%90%97%EF%BC%9F"><span class="nav-number">1.13.3.41.</span> <span class="nav-text">数据库设计三大范式？开发中应该遵守吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.13.3.42.</span> <span class="nav-text">MySQL乐观锁悲观锁实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E8%A1%A8%E9%94%81%E3%80%81%E9%A1%B5%E9%9D%A2%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.13.3.43.</span> <span class="nav-text">MySQL表锁、页面锁、行锁的作用及优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-5-6-17%E5%90%8E%E5%8A%A0%E7%B4%A2%E5%BC%95%E6%97%B6%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97"><span class="nav-number">1.13.3.44.</span> <span class="nav-text">MySQL 5.6.17后加索引时会锁表吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E6%88%96%E5%AD%97%E6%AE%B5%E6%97%B6%E4%BC%9A%E9%80%A0%E6%88%90%E9%94%81%E8%A1%A8"><span class="nav-number">1.13.3.45.</span> <span class="nav-text">MySQL为什么添加索引或字段时会造成锁表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E8%A1%8C%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.13.3.46.</span> <span class="nav-text">MySQL行锁怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81-%E4%BA%92%E6%96%A5%E5%90%97"><span class="nav-number">1.13.3.47.</span> <span class="nav-text">MySQL 行锁和表锁 互斥吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.13.3.48.</span> <span class="nav-text">MySQL读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E6%8E%92%E5%AE%83%E9%94%81%EF%BC%9F"><span class="nav-number">1.13.3.49.</span> <span class="nav-text">MySQL？什么时候会触发排它锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E9%97%B4%E9%9A%99%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.3.50.</span> <span class="nav-text">MySQL间隙锁是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%94%81%E8%A1%8C"><span class="nav-number">1.13.3.51.</span> <span class="nav-text">数据库什么时候会锁行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.13.3.52.</span> <span class="nav-text">MySQL死锁的解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%ADdistinct%E5%92%8Cgroup-by%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">1.13.3.53.</span> <span class="nav-text">MySQL中distinct和group by性能比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%E5%8F%AA%E4%B8%8E%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%9C%89%E5%85%B3%E5%90%97%EF%BC%9F%E9%82%A3%E5%AF%B9%E4%B8%BB%E9%94%AEid%E5%81%9A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E7%9A%84%E4%BB%80%E4%B9%88%E9%94%81%EF%BC%9F%E6%AF%94%E5%A6%82id-%EF%BC%9E7-for-update"><span class="nav-number">1.13.3.54.</span> <span class="nav-text">临键锁只与非唯一索引有关吗？那对主键id做范围查询的时候加的什么锁？比如id ＞7 for update</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93MySQL%E4%B8%ADredo-log%E3%80%81binlog%E3%80%81undo-log-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.13.3.55.</span> <span class="nav-text">你知道MySQL中redo log、binlog、undo log 区别与作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E7%9D%80%E6%89%8B%E7%82%B9"><span class="nav-number">1.13.3.56.</span> <span class="nav-text">SQL优化有哪些着手点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">1.13.3.57.</span> <span class="nav-text">索引失效场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%83%E4%B8%87%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E8%A1%A8%E6%AF%8F%E6%97%A5ETL%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.13.3.58.</span> <span class="nav-text">千万数据量的表每日ETL定时同步，如何优化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.13.3.59.</span> <span class="nav-text">什么是数据库事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.13.3.60.</span> <span class="nav-text">脏读，不可重复读和幻读主要有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%AD%E7%9A%84GTID%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.13.3.61.</span> <span class="nav-text">MySQL中的GTID是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GTID%E5%8F%AF%E4%BB%A5%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80Seata"><span class="nav-number">1.13.3.62.</span> <span class="nav-text">GTID可以全局事务，为什么还需Seata</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81MVCC"><span class="nav-number">1.13.3.63.</span> <span class="nav-text">说说你了解的数据库的隔离级别、MVCC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-MySQL-%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9FMySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E6%98%AF%E5%95%A5%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-MySQL-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">1.13.3.64.</span> <span class="nav-text">如何实现 MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决 MySQL 主从同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.13.3.65.</span> <span class="nav-text">为什么要设计事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Text-Blod%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95"><span class="nav-number">1.13.3.66.</span> <span class="nav-text">Text&#x2F;Blod如何索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E5%A4%8D%E5%88%B6%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.13.3.67.</span> <span class="nav-text">MySQL复制有几种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.13.3.68.</span> <span class="nav-text">MySQL主从延迟如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%92%8C%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.3.69.</span> <span class="nav-text">如何设计表和表结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%A4%A7%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B-%E9%9C%80%E8%A6%81%E5%85%88%E4%BB%8Edb%E4%B8%AD%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%8E%BB%E6%9F%A5%E8%AF%A2redis%E4%B8%AD%E5%85%B3%E8%81%94%E7%9A%84%E7%94%A8%E6%88%B7%E5%85%B3%E8%81%94%E4%BF%A1%E6%81%AF-%E8%BF%99%E9%87%8C%E5%BF%BD%E7%95%A5OOM%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8E%BB%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%91%A2"><span class="nav-number">1.13.3.70.</span> <span class="nav-text">数据量很大的情況下,需要先从db中查询用户基础信息然后根据用户基本信息去查询redis中关联的用户关联信息,这里忽略OOM的情况下 ,有什么办法去提升性能呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0%E8%A1%A8-%E5%AE%87%E6%AE%B5%E5%8C%85%E5%90%AB-%E6%96%87%E7%AB%A0%E7%B1%BB%E5%9E%8B-%E5%8F%91%E5%B8%83%E6%97%B6%E9%97%B4-%EF%BC%8C%E6%9F%A5%E8%AF%A2%E4%B8%AA%E5%8F%91%E5%B8%83%E6%97%B6%E9%97%B4%E6%AE%B5%E5%86%85%E7%89%B9%E5%AE%9A%E6%96%87%E7%AB%A0%E7%B1%BB%E5%9E%8B%E6%96%87%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%88%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%88%E6%96%87%E7%AB%A0%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8F%91%E5%B8%83%E6%97%B6%E9%97%B4%EF%BC%89%EF%BC%89"><span class="nav-number">1.13.3.71.</span> <span class="nav-text">一个文章表 宇段包含 文章类型 发布时间 ，查询个发布时间段内特定文章类型文章 如何建立索引（联合索引（文章类型，发布时间））</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#limit-1000000-%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%E5%91%A2"><span class="nav-number">1.13.3.72.</span> <span class="nav-text">limit 1000000 加载很慢的话，你是怎么解决的呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Select-for-update%E4%BD%9C%E7%94%A8"><span class="nav-number">1.13.3.73.</span> <span class="nav-text">Select for update作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E8%A1%8C%E7%9A%84%E5%9F%BA%E4%BA%8Elocality-%E7%9A%84%E9%A1%B5%E7%BC%93%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B6%B3%EF%BC%9F"><span class="nav-number">1.13.3.74.</span> <span class="nav-text">现行的基于locality 的页缓存有什么不足？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%93%E5%90%88%E6%9F%A5%E8%AF%A2%E5%99%A8-%E4%BC%98%E5%8C%96%E5%99%A8%E6%9D%A5%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="nav-number">1.13.3.75.</span> <span class="nav-text">如何结合查询器&#x2F; 优化器来优化缓存配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E5%88%92%E7%BC%93%E5%AD%98%E8%AF%B4%E4%B8%8B%E3%80%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E5%88%92%E7%BC%93%E5%AD%98select%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84"><span class="nav-number">1.13.3.76.</span> <span class="nav-text">数据库表达式计划缓存说下。表达式计划缓存select怎么生成的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#union-all-%E5%9C%A8MvSQL5-7%E9%87%8C%E6%94%B9%E8%BF%9B%E4%BA%86%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.13.3.77.</span> <span class="nav-text">union all 在MvSQL5.7里改进了哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%8D%83%E5%A4%9A%E4%B8%87%E7%9A%84%E8%A1%A8A-%E5%92%8C%E4%B8%A4%E5%8D%83%E4%B8%87%E7%9A%84%E8%A1%A8b-%E8%A6%81%E6%B1%82%E6%8A%8Ab%E6%9C%89a%E6%B2%A1%E6%9C%89%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8A%8Aa%E6%95%B0%E6%8D%AE%E5%92%8Cb%E6%9C%89%E5%B7%AE%E5%BC%82%E7%9A%84%E7%AD%9B%E9%80%89%E5%87%BA%E6%9D%A5%E3%80%82%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%AA%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">1.13.3.78.</span> <span class="nav-text">一千多万的表A 和两千万的表b,要求把b有a没有的插入，同时把a数据和b有差异的筛选出来。有什么个方案？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%8C%E8%AF%BB%E5%8F%8C%E5%86%99%E5%85%B7%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">1.13.3.79.</span> <span class="nav-text">迁移过程中双读双写具体是什么样的方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%86%99%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AA%E5%86%99%E6%88%90%E5%8A%9F%E4%BA%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA-DB%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%99%E7%94%A8%E6%88%B7%E6%8A%A5%E9%94%99%EF%BC%8C%E9%82%A3%E6%98%AF%E5%90%A6%E4%BC%9A%E5%AD%98%E5%9C%A8%E8%84%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">1.13.3.80.</span> <span class="nav-text">双写过程中只写成功了其中一个 DB，返回给用户报错，那是否会存在脏数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E8%AF%BB%E5%85%B7%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%AF%BB%E6%88%90%E5%8A%9F%E4%BA%86%E5%B0%B1%E8%BF%94%E5%9B%9E%E8%BF%98%E6%98%AF%E8%A6%81%E4%B8%A4%E4%B8%AA%E9%83%BD%E8%AF%BB%E6%88%90%E5%8A%9F%E6%89%8D%E5%8F%AF%E4%BB%A5"><span class="nav-number">1.13.3.81.</span> <span class="nav-text">双读具体是什么方案，其中一个读成功了就返回还是要两个都读成功才可以</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%95%E6%9C%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.13.3.82.</span> <span class="nav-text">数据宕机如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-ISAM-InnoDB-%E5%A2%9E%E9%95%BF%E4%B8%BB%E9%94%AE-%E5%BD%93%E7%AA%81%E7%84%B6%E6%96%AD%E7%94%B5%E5%81%9C%E6%9C%BA%E5%90%8E%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%90%AF%EF%BC%8C%E4%B8%A4%E4%B8%AA%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%BC%9A%E8%BF%9E%E7%BB%AD%E5%90%97"><span class="nav-number">1.13.3.83.</span> <span class="nav-text">MySQL ISAM InnoDB,增长主键,当突然断电停机后进行重启，两个引擎中的自增主键会连续吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.13.3.84.</span> <span class="nav-text">存储过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oracle"><span class="nav-number">1.13.4.</span> <span class="nav-text">Oracle</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Oracle%E4%B8%B4%E6%97%B6%E8%A1%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.13.4.1.</span> <span class="nav-text">Oracle临时表有哪些</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-%E6%8B%86%E8%A1%A8"><span class="nav-number">1.13.5.</span> <span class="nav-text">分布式 &amp;&amp; 拆表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88"><span class="nav-number">1.13.5.1.</span> <span class="nav-text">分库分表方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.13.5.2.</span> <span class="nav-text">分库分表可能遇到的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7%E6%9C%8D%E5%8A%A1%E5%8D%95%E8%A1%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%A4%9A%E8%A1%A8%EF%BC%8C%E4%B8%94%E6%96%B0%E6%97%A7%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C"><span class="nav-number">1.13.5.3.</span> <span class="nav-text">旧服务单表，如何改造新服务多表，且新旧服务同时运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A1%A8%E5%88%86%E9%94%99%E4%BA%86%E5%90%8E%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="nav-number">1.13.5.4.</span> <span class="nav-text">分表分错了后如何排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8B%86%E8%A1%A8%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.13.5.5.</span> <span class="nav-text">如何拆表，优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%88%E4%B8%9A%E5%8A%A1%E4%BE%A7%EF%BC%89%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%88%E6%95%B0%E6%8D%AE%E4%BE%A7%EF%BC%89"><span class="nav-number">1.13.5.6.</span> <span class="nav-text">我们为什么要做分库分表（业务侧）我们为什么要做分库分表（数据侧）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.13.5.7.</span> <span class="nav-text">分库分表之后，id 主键如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E6%8B%86%E5%88%86%E5%90%8E%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.13.5.8.</span> <span class="nav-text">表拆分后如何查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8D%E6%8E%A8%E8%8D%90JOIN"><span class="nav-number">1.13.5.9.</span> <span class="nav-text">为什么分布式不推荐JOIN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TiDB"><span class="nav-number">1.13.6.</span> <span class="nav-text">TiDB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch%E7%9B%B8%E5%85%B3"><span class="nav-number">1.14.</span> <span class="nav-text">ElasticSearch相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ES%E5%80%92%E6%8E%92%E8%A1%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.14.0.1.</span> <span class="nav-text">ES倒排表压缩算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES-%E7%B4%A2%E5%BC%95%E8%BF%87%E7%A8%8B"><span class="nav-number">1.14.0.2.</span> <span class="nav-text">ES 索引过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9E%AC%E9%97%B4%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2"><span class="nav-number">1.14.0.3.</span> <span class="nav-text">如何瞬间完成海量数据检索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB%E5%88%86%E8%AF%8D%E6%90%9C%E7%B4%A2%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">1.14.0.4.</span> <span class="nav-text">ES如何加快分词搜索速度，倒排索引原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98"><span class="nav-number">1.14.0.5.</span> <span class="nav-text">ES脑裂问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E4%BC%98-1"><span class="nav-number">1.14.0.6.</span> <span class="nav-text">调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E8%A6%81%E6%80%8E%E4%B9%88%E5%86%99"><span class="nav-number">1.14.0.7.</span> <span class="nav-text">ES模糊查询要怎么写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Click-House"><span class="nav-number">1.14.1.</span> <span class="nav-text">Click House</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network%E7%9B%B8%E5%85%B3"><span class="nav-number">1.15.</span> <span class="nav-text">Network相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%AF%8F%E5%B1%82%E4%BD%9C%E7%94%A8"><span class="nav-number">1.15.0.1.</span> <span class="nav-text">OSI七层模型，每层作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.15.0.2.</span> <span class="nav-text">TCP如何实现可靠连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%9C%BA%E5%88%B6"><span class="nav-number">1.15.0.3.</span> <span class="nav-text">TCP的拥塞机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%B1%82"><span class="nav-number">1.15.0.4.</span> <span class="nav-text">TCP在网络中的第几层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.15.0.5.</span> <span class="nav-text">TCP长连接的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="nav-number">1.15.0.6.</span> <span class="nav-text">TCP协议头多少字节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.15.0.7.</span> <span class="nav-text">TCP三次握手四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E6%8C%A5%E6%89%8B%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E8%B5%B7%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">1.15.0.8.</span> <span class="nav-text">TCP四次挥手，挥手从服务端发起会怎么样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FIN-WAIT-2%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%9A%84"><span class="nav-number">1.15.0.9.</span> <span class="nav-text">FIN-WAIT-2是什么时候的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E7%B2%98%E5%8C%85%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.15.0.10.</span> <span class="nav-text">TCP 粘包怎么解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%BA0%E7%9A%84%E6%83%85%E5%86%B5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.15.0.11.</span> <span class="nav-text">TCP滑动窗口为0的情况什么时候出现，如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">1.15.0.12.</span> <span class="nav-text">TCP如何保证传输过程的正确性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP%E5%8C%BA%E5%88%AB"><span class="nav-number">1.15.0.13.</span> <span class="nav-text">TCP UDP区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.15.0.14.</span> <span class="nav-text">列举几个网络通信协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.15.0.15.</span> <span class="nav-text">HTTP请求类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CTCP%E7%9A%84%E5%85%B3%E8%81%94"><span class="nav-number">1.15.0.16.</span> <span class="nav-text">HTTP和TCP的关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.15.0.17.</span> <span class="nav-text">HTTP和HTTPS的主要区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B"><span class="nav-number">1.15.0.18.</span> <span class="nav-text">HTTPS交互过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%8E%9F%E7%90%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-HTTPS%E8%BF%99%E4%B8%AA%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.15.0.19.</span> <span class="nav-text">HTTPS 原理，怎么实现 HTTPS这个协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTLS"><span class="nav-number">1.15.0.20.</span> <span class="nav-text">什么是TLS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%94%B6%E5%88%B0%E5%BE%88%E5%A4%9A%E7%9A%84TIME-WAIT%E7%8A%B6%E6%80%81%E5%8C%85%EF%BC%8C%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.15.0.21.</span> <span class="nav-text">网络收到很多的TIME_WAIT状态包，原因以及解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8FCLOSE-WAIT%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.15.0.22.</span> <span class="nav-text">服务端出现大量CLOSE_WAIT原因及解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9CIO%E7%9A%84%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.15.0.23.</span> <span class="nav-text">网络IO的五种模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-HTTP%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.15.0.24.</span> <span class="nav-text">RPC HTTP区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.15.0.25.</span> <span class="nav-text">输入一个URL会发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%98%AF%E5%90%A6%E6%98%AF%E5%BC%82%E6%AD%A5"><span class="nav-number">1.15.0.26.</span> <span class="nav-text">IO多路复用是否是异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.15.0.27.</span> <span class="nav-text">IO多路复用的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RTMP%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.15.0.28.</span> <span class="nav-text">RTMP是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%BD%91%E9%A1%B5%E4%B8%80%E4%B8%AAHttp%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%88%B0%E5%90%8E%E7%AB%AF%E7%9A%84%E6%95%B4%E4%B8%AA%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="nav-number">1.15.0.29.</span> <span class="nav-text">描述网页一个Http请求，到后端的整个请求过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.15.0.30.</span> <span class="nav-text">长连接的方式有哪些</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty"><span class="nav-number">1.15.1.</span> <span class="nav-text">Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.15.1.1.</span> <span class="nav-text">Netty的线程模型，零拷贝实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hardware"><span class="nav-number">1.15.2.</span> <span class="nav-text">Hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.15.2.1.</span> <span class="nav-text">路由器和交换机的工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Middleware-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.16.</span> <span class="nav-text">Middleware 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx"><span class="nav-number">1.16.1.</span> <span class="nav-text">Nginx</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%8C%E7%9B%B8%E5%85%B3%E5%9C%BA%E6%99%AF"><span class="nav-number">1.16.1.1.</span> <span class="nav-text">Nginx负载均衡策略，相关场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E7%A7%BB%E5%8A%A8%E7%AB%AFPC%E7%AB%AF"><span class="nav-number">1.16.1.2.</span> <span class="nav-text">Nginx如何识别移动端PC端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.16.1.3.</span> <span class="nav-text">Nginx动静分离如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E5%A2%9E%E5%8A%A0work-connections%E9%85%8D%E7%BD%AE%E6%A8%AA%E5%90%91%E6%8B%93%E5%B1%95Nginx%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.16.1.4.</span> <span class="nav-text">Nginx做负载均衡，增加work_connections配置横向拓展Nginx实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat"><span class="nav-number">1.16.2.</span> <span class="nav-text">Tomcat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="nav-number">1.16.3.</span> <span class="nav-text">链路追踪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%AF%BB%E5%8F%96%E5%88%86%E5%89%B2%E8%AE%B0%E5%BD%95%E5%B9%B6%E4%BF%9D%E6%8C%81%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.16.3.1.</span> <span class="nav-text">大文件怎么读取分割记录并保持顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tools-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.17.</span> <span class="nav-text">Tools 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.17.0.1.</span> <span class="nav-text">分布式锁在项目上的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Theory-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.18.</span> <span class="nav-text">Theory 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAP%E5%AE%9A%E7%90%86%E5%92%8CBASE%E7%90%86%E8%AE%BA"><span class="nav-number">1.18.0.1.</span> <span class="nav-text">CAP定理和BASE理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFServerless"><span class="nav-number">1.18.0.2.</span> <span class="nav-text">什么是Serverless</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%91%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%81%E6%98%8E%E4%BD%A0%E5%81%9A%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">1.18.0.3.</span> <span class="nav-text">如何向面试官证明你做的系统是高可用的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UV-PV"><span class="nav-number">1.18.0.4.</span> <span class="nav-text">UV&#x2F;PV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="nav-number">1.18.0.5.</span> <span class="nav-text">什么是灰度发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%99%A4%E4%BA%86%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%88%AB%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%9F%E7%94%9F%E4%BA%A7%E6%95%88%E7%8E%87"><span class="nav-number">1.18.0.6.</span> <span class="nav-text">解释型语言和编译型语言的区别？除了运行速度别的角度？生产效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E6%89%BE%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%B8%B8%E6%95%B0"><span class="nav-number">1.18.0.7.</span> <span class="nav-text">哈希表为什么查找复杂度是常数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD"><span class="nav-number">1.19.</span> <span class="nav-text">DDD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-number">1.19.0.1.</span> <span class="nav-text">设计思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.19.0.2.</span> <span class="nav-text">核心解决的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="nav-number">1.19.0.3.</span> <span class="nav-text">分层架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.19.0.4.</span> <span class="nav-text">优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-number">1.20.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BTCP%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.20.0.1.</span> <span class="nav-text">如何查看TCP连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes"><span class="nav-number">1.21.</span> <span class="nav-text">Kubernetes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Front-End"><span class="nav-number">1.22.</span> <span class="nav-text">Front-End</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.22.1.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ajax"><span class="nav-number">1.22.2.</span> <span class="nav-text">Ajax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Layui"><span class="nav-number">1.22.3.</span> <span class="nav-text">Layui</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jQuery"><span class="nav-number">1.22.4.</span> <span class="nav-text">jQuery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React"><span class="nav-number">1.22.5.</span> <span class="nav-text">React</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Freemarker"><span class="nav-number">1.22.5.1.</span> <span class="nav-text">Freemarker</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Angular"><span class="nav-number">1.22.6.</span> <span class="nav-text">Angular</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Angular%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%8F%8C%E9%87%8D%E7%BB%91%E5%AE%9A%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.22.6.1.</span> <span class="nav-text">Angular介绍下双重绑定的机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Other-1"><span class="nav-number">1.23.</span> <span class="nav-text">Other</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO-Channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.23.0.1.</span> <span class="nav-text">NIO Channel底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%BF%E5%88%B0%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82%E4%BD%A0%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="nav-number">1.23.0.2.</span> <span class="nav-text">拿到一个需求你会做哪些事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%B0%E7%AE%97%E6%9F%90%E5%9F%8E%E5%B8%82%E7%9A%84%E4%BE%BF%E5%88%A9%E5%BA%97%E6%95%B0%E9%87%8F"><span class="nav-number">1.23.0.3.</span> <span class="nav-text">估算某城市的便利店数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E5%8D%A0%E7%94%A8%E7%AA%81%E7%84%B6%E5%8D%87%E9%AB%98%E8%AF%A5%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90"><span class="nav-number">1.23.0.4.</span> <span class="nav-text">CPU占用突然升高该怎么分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%81%87%E6%AD%BB%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.23.0.5.</span> <span class="nav-text">线程假死怎么排查，如何处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E4%B8%8D%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.23.0.6.</span> <span class="nav-text">对称加密和不对称加密的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88"><span class="nav-number">1.23.0.7.</span> <span class="nav-text">常用的高可用方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9BMHA%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">1.23.0.8.</span> <span class="nav-text">有哪些MHA结构的方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E8%A1%A8%E8%BE%BE%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81"><span class="nav-number">1.23.0.9.</span> <span class="nav-text">怎样表达滑动窗口限流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3%E8%B0%83%E4%BC%98%EF%BC%8C%E4%B8%8D%E7%94%A8%E7%BC%93%E5%AD%98%E4%B8%94%E8%A6%81%E6%B1%82%E5%AE%9E%E6%97%B6%E6%80%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98"><span class="nav-number">1.23.0.10.</span> <span class="nav-text">查询接口调优，不用缓存且要求实时性，如何调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8A%E4%B8%8B%E6%B8%B8%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8sign%E8%80%8C%E4%B8%8D%E6%98%AFoauth%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%88%90key"><span class="nav-number">1.23.0.11.</span> <span class="nav-text">服务上下游为什么用sign而不是oauth协议生成key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.23.0.12.</span> <span class="nav-text">操作系统的悲观锁、乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%8C%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84"><span class="nav-number">1.23.0.13.</span> <span class="nav-text">如何实现高可用，项目如何实现高可用的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8C%E8%A6%86%E7%9B%96%E7%8E%87%E5%A6%82%E4%BD%95"><span class="nav-number">1.23.0.14.</span> <span class="nav-text">如何单元测试，覆盖率如何</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MapReduce%E5%8E%9F%E7%90%86"><span class="nav-number">1.23.0.15.</span> <span class="nav-text">MapReduce原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%B5%81%E9%87%8F"><span class="nav-number">1.23.0.16.</span> <span class="nav-text">怎么解决高并发下流量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B20%EF%BC%8C%E6%9C%80%E5%A4%A7600%EF%BC%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97200%EF%BC%8C%E5%BD%93QPS-200%E6%97%B6%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%88%E6%98%AF%E4%B8%80%E4%B8%AA%E9%95%BF%E6%97%B6%E9%97%B4%E9%98%BB%E5%A1%9E%E4%BB%BB%E5%8A%A1%EF%BC%89%EF%BC%8C%E4%B8%8D%E5%8A%A0%E6%9C%BA%E5%99%A8%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.23.0.17.</span> <span class="nav-text">核心线程20，最大600，阻塞队列200，当QPS 200时，请求调用第三方（是一个长时间阻塞任务），不加机器情况下，如何提高吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E4%B8%94%E8%A6%81%E6%B1%82%E5%AE%9E%E6%97%B6%E6%80%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98"><span class="nav-number">1.23.0.18.</span> <span class="nav-text">查询接口，不使用缓存且要求实时性，如何调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E9%99%8D%E7%BA%A7%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%85%9C%E5%BA%95"><span class="nav-number">1.23.0.19.</span> <span class="nav-text">用户查询一张表，流量控制降级时，如何兜底</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95%E6%8C%89%E4%BB%80%E4%B9%88%E8%87%AA%E5%8A%A8%E5%88%86%E8%A1%A8%EF%BC%8C%E5%88%86%E8%A1%A8%E5%90%8E%E5%A6%82%E4%BD%95%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E6%AE%B5%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E5%86%85%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95"><span class="nav-number">1.23.0.20.</span> <span class="nav-text">用户订单按什么自动分表，分表后如何按照时间段查询指定时间段内所有用户订单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.23.0.21.</span> <span class="nav-text">Channel的底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#channel-%E5%92%8C-select%E7%9A%84%E4%B8%80%E5%B0%8F%E6%AE%B5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AE%A9%E8%AF%B4%E5%87%BA%E6%89%93%E5%8D%B0%E5%86%85%E5%AE%B9"><span class="nav-number">1.23.0.22.</span> <span class="nav-text">channel 和 select的一小段代码，让说出打印内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2content%EF%BC%8C%E6%88%91%E5%8F%AA%E8%AF%B4%E4%BA%86%E4%B8%8Bwithtimeout%E8%B6%85%E6%97%B6%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9Bkv%E5%80%BC%EF%BC%8C%E4%BE%9B%E5%90%8E%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.23.0.23.</span> <span class="nav-text">上下文切换content，我只说了下withtimeout超时时，使用，或者记录一些kv值，供后面的方法使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E6%B7%98%E5%AE%9D%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E5%88%92%E5%88%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.23.0.24.</span> <span class="nav-text">如果你来设计一个类似淘宝的系统，你怎么划分微服务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BA%BA%E4%BB%96%E4%BC%AA%E9%80%A0%E4%BA%86%E5%BE%88%E5%A4%9A%E5%90%88%E6%B3%95%E7%9A%84QQ%E5%8F%B7%E5%B9%B6%E4%B8%94%E5%A4%9A%E5%8F%B0%E4%B8%BB%E6%9C%BA%E6%9D%A5%E6%94%BB%E5%87%BB%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.23.0.25.</span> <span class="nav-text">如果有一个人他伪造了很多合法的QQ号并且多台主机来攻击怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9F%BA%E7%AB%99%EF%BC%8C%E7%BD%91%E7%BB%9C%E5%87%BA%E5%8F%A3%E5%8F%AF%E8%83%BD%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E9%94%81%E5%AE%9AIP%E8%AF%AF%E4%BC%A4%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.23.0.26.</span> <span class="nav-text">连接相同的基站，网络出口可能是相同的，锁定IP误伤怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.23.0.27.</span> <span class="nav-text">超卖问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E4%B8%AA%E7%9B%92%E5%AD%901%E4%B8%AA%E6%9C%8990%E5%85%8B-%E5%89%A9%E4%B8%8B%E7%9A%84100%E5%85%8B-%E6%9C%80%E5%B0%91%E8%83%BD%E7%94%A8%E5%87%A0%E6%AC%A1%E7%A7%B0%E5%87%BA90%E5%85%8B%E7%9A%84"><span class="nav-number">1.23.0.28.</span> <span class="nav-text">9个盒子1个有90克 剩下的100克 最少能用几次称出90克的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.23.0.29.</span> <span class="nav-text">常见的索引结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%A4%A7%E9%87%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%97%B6%E5%87%BA%E7%8E%B0session%E8%BF%9E%E6%8E%A5%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4%E7%94%A8%E6%88%B7%E8%A2%AB%E7%99%BB%E5%87%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">1.23.0.30.</span> <span class="nav-text">系统大量用户登录时出现session连接过多导致用户被登出，如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84"><span class="nav-number">1.23.0.31.</span> <span class="nav-text">接口幂等是如何保证的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="nav-number">1.23.0.32.</span> <span class="nav-text">技术选型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E6%B5%81%E9%87%8F%E7%9A%84%E5%BD%95%E5%88%B6%E5%B7%A5%E5%85%B7%E4%B8%BB%E8%A6%81%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2"><span class="nav-number">1.23.0.33.</span> <span class="nav-text">HTTP 流量的录制工具主要是做什么用呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%80%E4%BA%9B%E7%99%BB%E9%99%86%E6%80%81%E7%9A%84%E5%A4%84%E7%90%86%E5%90%97"><span class="nav-number">1.23.0.34.</span> <span class="nav-text">HTTP 流量录制会涉及到一些登陆态的处理吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%8F%AF%E8%A7%81%E4%B8%8E%E4%B8%8D%E5%8F%AF%E8%A7%81"><span class="nav-number">1.23.0.35.</span> <span class="nav-text">微信朋友圈设计，朋友圈可见与不可见</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%8B%E7%82%B9%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.23.0.36.</span> <span class="nav-text">埋点如何设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B7%B2%E8%8E%B7%E5%BE%97%E9%93%BE%E6%8E%A5%E5%92%8C%E5%AF%86%E9%92%A5"><span class="nav-number">1.23.0.37.</span> <span class="nav-text">实现百度翻译接口，已获得链接和密钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">1.23.0.38.</span> <span class="nav-text">二级计算器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#100%E7%99%BE%E5%8F%AA%E7%AE%AD%E3%80%81A%E3%80%81B%E4%BA%A4%E6%9B%BF%E5%B0%84%E7%AE%AD%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%B0%84%E5%87%BA1%E3%80%812%E4%B8%AA%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%B0%84%E5%87%BA%E7%9A%84%E4%BA%BA%E8%8E%B7%E8%83%9C%EF%BC%8C%E9%97%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81A%E4%B8%80%E5%AE%9A%E8%83%BD%E8%B5%A2"><span class="nav-number">1.23.0.39.</span> <span class="nav-text">100百只箭、A、B交替射箭，每次可以射出1、2个，最后一个射出的人获胜，问如何保证A一定能赢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%91%8A%E7%9A%84%E8%87%AA%E7%AE%97%E6%94%B6%E5%85%A5%E5%92%8C%E4%B8%89%E6%96%B9%E6%94%B6%E5%85%A5%E6%A0%A1%E6%AD%A3"><span class="nav-number">1.23.0.40.</span> <span class="nav-text">如何实现广告的自算收入和三方收入校正</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%96%E8%AE%B8%E5%A4%9A%E8%AE%B0%E5%BD%95%E6%AF%8F%E8%A1%8C%E8%AE%B0%E5%BD%95%E5%8C%85%E6%8B%ACid%EF%BC%8Cdad-id-%E6%8A%8A%E8%BF%99%E4%BA%9B%E8%AE%B0%E5%BD%95%E8%BD%AC%E5%8C%96%E4%B8%BAtree%E3%80%82"><span class="nav-number">1.23.0.41.</span> <span class="nav-text">从数据库取许多记录每行记录包括id，dad_ id,把这些记录转化为tree。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50%E5%AE%B6%E4%BA%BA%E5%AE%B6%EF%BC%8C%E6%AF%8F%E5%AE%B6%E4%B8%80%E6%9D%A1%E7%8B%97%E3%80%82%E6%9C%89%E4%B8%80%E5%A4%A9%E8%AD%A6%E5%AF%9F%E9%80%9A%E7%9F%A5%EF%BC%8C50%E6%9D%A1%E7%8B%97%E5%BD%93%E4%B8%AD%E6%9C%89%E7%97%85%E7%8B%97%EF%BC%8C%E8%A1%8C%E4%B8%BA%E5%92%8C%E6%AD%A3%E5%B8%B8%E7%8B%97%E4%B8%8D%E4%B8%80%E6%A0%B7%E3%80%82%E6%AF%8F%E4%BA%BA%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E8%A7%82%E5%AF%9F%E5%88%AB%E4%BA%BA%E5%AE%B6%E7%9A%84%E7%8B%97%E6%9D%A5%E5%88%A4%E6%96%AD%E8%87%AA%E5%B7%B1%E5%AE%B6%E7%9A%84%E7%8B%97%E6%98%AF%E5%90%A6%E7%94%9F%E7%97%85%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E7%9C%8B%E8%87%AA%E5%B7%B1%E5%AE%B6%E7%9A%84%E7%8B%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%A4%E6%96%AD%E5%87%BA%E8%87%AA%E5%B7%B1%E5%AE%B6%E7%9A%84%E7%8B%97%E7%97%85%E4%BA%86%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E5%BD%93%E5%A4%A9%E4%B8%80%E6%9E%AA%E6%89%93%E6%AD%BB%E8%87%AA%E5%B7%B1%E5%AE%B6%E7%9A%84%E7%8B%97%E3%80%82%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%AC%AC%E4%B8%80%E5%A4%A9%E6%B2%A1%E6%9C%89%E6%9E%AA%E5%A3%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%A4%A9%E6%B2%A1%E6%9C%89%E6%9E%AA%E5%A3%B0%EF%BC%8C%E7%AC%AC%E4%B8%89%E5%A4%A9%E5%BC%80%E5%A7%8B%E4%B8%80%E9%98%B5%E6%9E%AA%E5%93%8D%EF%BC%8C%E9%97%AE%EF%BC%9A%E4%B8%80%E5%85%B1%E6%AD%BB%E4%BA%86%E5%87%A0%E6%9D%A1%E7%8B%97%EF%BC%9F"><span class="nav-number">1.23.0.42.</span> <span class="nav-text">50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有枪声，第二天没有枪声，第三天开始一阵枪响，问：一共死了几条狗？</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">205</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '713a28a3ad93f2aa2323',
      clientSecret: '39dc40bb09b422ca4c99a748b5984a4d205e91be',
      repo        : 'swzxsyh.github.io',
      owner       : 'swzxsyh',
      admin       : ['swzxsyh'],
      id          : 'a575401425808f5fa284c37e7200c0cd',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
