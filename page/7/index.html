<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="swzxsyh">
<meta property="og:url" content="https://swzxsyh.github.io/page/7/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swzxsyh.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/03/DDD%E4%B8%8E%E4%B8%AD%E5%8F%B0%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/03/DDD%E4%B8%8E%E4%B8%AD%E5%8F%B0%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">DDD与中台、微服务的关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-03 15:09:23" itemprop="dateCreated datePublished" datetime="2022-07-03T15:09:23+08:00">2022-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 00:44:23" itemprop="dateModified" datetime="2022-08-02T00:44:23+08:00">2022-08-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DDD与中台、微服务的关系"><a href="#DDD与中台、微服务的关系" class="headerlink" title="DDD与中台、微服务的关系"></a>DDD与中台、微服务的关系</h1><ul>
<li>什么是中台</li>
<li>企业中台组成</li>
<li>基于DDD的微服务设计</li>
<li>微服务拆分和设计原则</li>
<li>中台、微服务与DDD的关系</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/03/DDD%E4%B8%8E%E4%B8%AD%E5%8F%B0%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/Java-AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/Java-AQS/" class="post-title-link" itemprop="url">Java-AQS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 19:22:05" itemprop="dateCreated datePublished" datetime="2022-07-02T19:22:05+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><ul>
<li><p>用途：是并发包的一个基础组件，用来实现各种锁，各种同步组件。ReentrantLock就是用AQS实现的</p>
<p>比如，Semaphore用它来表现剩余的许可数，ReentrantLock用它来表现拥有它的线程已经请求了多少次锁；FutureTask用它来表现任务的状态等。</p>
<p>使用 AQS 来实现一个同步器需要覆盖实现如下几个方法，并且使用<code>getState</code>、<code>setState</code>和<code>compareAndSetState</code>这三个方法来操作状态。</p>
</li>
<li><p>AQS全称：AbstractQueuedSynchrinizer，抽象队列同步器。</p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/02/Java-AQS/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/Spring-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/Spring-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/" class="post-title-link" itemprop="url">Spring-事务失效</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 19:21:01" itemprop="dateCreated datePublished" datetime="2022-07-02T19:21:01+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-事务失效"><a href="#Spring-事务失效" class="headerlink" title="Spring-事务失效"></a>Spring-事务失效</h1><h2 id="访问权限问题"><a href="#访问权限问题" class="headerlink" title="访问权限问题"></a>访问权限问题</h2><p>例如：private修饰的方法，Spring要求被代理的方法必须是public的</p>
<h2 id="方法用final修饰"><a href="#方法用final修饰" class="headerlink" title="方法用final修饰"></a>方法用final修饰</h2><h2 id="方法内部调用：同一个类中a方法调用有事务注解的b方法"><a href="#方法内部调用：同一个类中a方法调用有事务注解的b方法" class="headerlink" title="方法内部调用：同一个类中a方法调用有事务注解的b方法"></a>方法内部调用：同一个类中a方法调用有事务注解的b方法</h2><p>Spring在扫描Bean的时候会自动为标注了@Transactional注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于this.B()，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</p>
<ul>
<li>解决方法：<ul>
<li>1）将B方法移到另一个service中	</li>
<li>2）在service中注入自己	</li>
<li>3）通过aopContent类：在该service类中调用AopContent.currentProx()获取代理对象</li>
</ul>
</li>
</ul>
<h2 id="类未被spring管理"><a href="#类未被spring管理" class="headerlink" title="类未被spring管理"></a>类未被spring管理</h2><h2 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h2><h2 id="表不支持事务"><a href="#表不支持事务" class="headerlink" title="表不支持事务"></a>表不支持事务</h2><h2 id="未开启事务"><a href="#未开启事务" class="headerlink" title="未开启事务"></a>未开启事务</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">MySQL-主从复制原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 18:47:44" itemprop="dateCreated datePublished" datetime="2022-07-02T18:47:44+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>mysql主从复制原理：</p>
<p>1.从库生成两个线程，一个IO线程一个SQL线程</p>
<p>2.IO线程会去请求主库binlog，并将得到的binlog写到本地的relay-log（中继日志）文件中</p>
<p>3.主库会生成一个log dump线程，用来给从库IO线程传送binlog</p>
<p>4.SQL线程会读取relay-log文件中的日志，并解析成SQL逐一执行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/DataBase%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/DataBase%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="post-title-link" itemprop="url">DataBase分库分表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 18:35:42" itemprop="dateCreated datePublished" datetime="2022-07-02T18:35:42+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:48" itemprop="dateModified" datetime="2022-07-15T01:25:48+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、分库分表"><a href="#一、分库分表" class="headerlink" title="一、分库分表"></a>一、分库分表</h1><ul>
<li><p>分库场景：如果数据库的查询QPS过高，就要考虑拆库，比如：查询QPS为3500，假设单库可以支撑1000个连接数，那么就考虑拆分成4个库，来分散查询压力。</p>
</li>
<li><p>分库分表场景：</p>
<table>
<thead>
<tr>
<th>切分方案</th>
<th>解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td>只分库不分表</td>
<td>数据库读&#x2F;写 QPS过高，数据库连接数不足</td>
</tr>
<tr>
<td>只分表不分库</td>
<td>单表数据量过大，存储性能遇到瓶颈</td>
</tr>
<tr>
<td>既分库又分表</td>
<td>连接数不足+存储性能遇到瓶颈</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="二、数据切分方法"><a href="#二、数据切分方法" class="headerlink" title="二、数据切分方法"></a>二、数据切分方法</h1><ul>
<li><p>水平切分</p>
<p>这是一种按业务维度切分的方式，比如，常见的按会员维度进行切分，根据一定规则，把不同会员的数据散落在不同的库表中。</p>
</li>
<li><p>垂直切分</p>
<p>垂直切分可以理解为：把一张表的不同字段拆分到不同的表中</p>
</li>
</ul>
<h1 id="三-分库分表后会遇到哪些坑"><a href="#三-分库分表后会遇到哪些坑" class="headerlink" title="三 分库分表后会遇到哪些坑"></a>三 分库分表后会遇到哪些坑</h1><ul>
<li><p>事务一致性</p>
<p>解决办法：XA协议、两阶段提交、TCC，通常使用最终一致性的方案，采用事务补偿的方式</p>
</li>
<li><p>分页、排序问题</p>
<p>1）如果排序字段恰好是分片字段，通过分片规则就可以定位到分片的位置；如果排序字段是非分片字段，就需要在不同的分片点中将数据进行排序再返回；然后不同分片的数据汇集到一起再进行汇总和排序，最终返回给用户。</p>
<p>2）用ES</p>
</li>
<li><p>全局唯一主键问题</p>
<p>分布式id生产方案</p>
</li>
</ul>
<h1 id="四-分库分表后历史数据如何做迁移"><a href="#四-分库分表后历史数据如何做迁移" class="headerlink" title="四 分库分表后历史数据如何做迁移"></a>四 分库分表后历史数据如何做迁移</h1><p>一般采用【双写】的方式进行迁移</p>
<p>1.增量的消息往新表和老表各写一份</p>
<p>2.将旧表的数据迁移至新库</p>
<p>3.迟早新表的数据会赶上旧表的数据</p>
<p>4.校验新表数据和老表数据是否对得上</p>
<p>5.开启双读（一部分流量走新表，一部分流量走老表），相当于灰度的过程</p>
<p>6.读流量全部切换至新表，停止旧表的写入</p>
<p>7.提前准备回滚机制，临时切换失败能恢复正常业务以及修复数据的相关程序</p>
<h1 id="五-分库分表中间件对比"><a href="#五-分库分表中间件对比" class="headerlink" title="五 分库分表中间件对比"></a>五 分库分表中间件对比</h1><p>Sharding-jdbc：client层方案</p>
<ul>
<li><p>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高（<strong>轻便，维护成本低，比较推荐中小型公司项目使用</strong>）</p>
</li>
<li><p>缺点：如果遇到升级，各个系统都需要重新升级版本再发布，各个系统都需要耦合Sharding-jdbc的依赖</p>
</li>
</ul>
<p>Mycat：proxy层方案</p>
<ul>
<li>缺点：	需要部署，自己要运维一套中间件，运维成本高</li>
<li>优点：对于各个项目都是透明的，如果遇到升级问题，自己中间件搞定就行了（推荐大型公司项目使用）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/MySQL-%E5%A0%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/MySQL-%E5%A0%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">MySQL-堆排序问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 18:23:47" itemprop="dateCreated datePublished" datetime="2022-07-02T18:23:47+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL-堆排序查询慢"><a href="#MySQL-堆排序查询慢" class="headerlink" title="MySQL-堆排序查询慢"></a>MySQL-堆排序查询慢</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>根据主键排序，获取一条时，查询异常缓慢，测试260万数据需2.8s-3s</p>
<p>如果根据唯一键排序，则需要6s</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>由于MySQL 5.6的 priority queue ，在5.7 出现问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY id DESC LIMIT 1</span><br></pre></td></tr></table></figure>

<p>此问题应仅发生在MySQL 5.7版本 ORDERBY 排序 配合 LIMIT 1 使用时发生。测试分页以及批量暂未发生相同异常</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ul>
<li><p>使用FORCE INDEX 可修复部分问题，但需针对性加索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 强制使用索引</span></span><br><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>	`table_name` </span><br><span class="line">FORCE INDEX (`index_name`)</span><br><span class="line"><span class="keyword">WHERE</span>	(`conditions`) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `id` <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p>根据 主键 &amp;&amp; 唯一键 排序, 全表条件查询可缩短至0.3s,增加条件筛选可在0.03左右查询结束</p>
<p>ORDER BY id,code DESC LIMIT 1</p>
</li>
</ul>
<p>具体原因: </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wolfchenxing/article/details/88947577">https://blog.csdn.net/wolfchenxing/article/details/88947577</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">MessageQueue-面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 18:05:01" itemprop="dateCreated datePublished" datetime="2022-07-02T18:05:01+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 03:14:23" itemprop="dateModified" datetime="2022-08-02T03:14:23+08:00">2022-08-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么使用MQ"><a href="#为什么使用MQ" class="headerlink" title="为什么使用MQ"></a>为什么使用MQ</h2><ul>
<li>解耦</li>
<li>异步</li>
<li>削峰</li>
</ul>
<h2 id="MQ选型"><a href="#MQ选型" class="headerlink" title="MQ选型"></a>MQ选型</h2><p><strong>Kafka：</strong>追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务，大型公司建议可以选用，如果有日志采集功能，肯定是首选 Kafka。</p>
<p><strong>RocketMQ：</strong>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。</p>
<p>RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>
<p><strong>RabbitMQ：</strong>结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。</p>
<p><strong>ActiveMQ：</strong>官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用。</p>
<h2 id="Kafka-会不会丢消息"><a href="#Kafka-会不会丢消息" class="headerlink" title="Kafka 会不会丢消息"></a>Kafka 会不会丢消息</h2><p>消息丢失会发生在Broker，Producer和Consumer三种</p>
<h3 id="Producer丢失消息的情况"><a href="#Producer丢失消息的情况" class="headerlink" title="Producer丢失消息的情况"></a>Producer丢失消息的情况</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul>
<li><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
</li>
<li><p>为了提升效率，减少IO，producer在发送数据时可以将多个请求进行合并后发送。被合并的请求咋发送一线缓存在本地buffer中。</p>
<p>一旦producer被非法的停止了，那么buffer中的数据将丢失，broker将无法收到该部分数据。又或者，当Producer客户端内存不够时，如果采取的策略是丢弃消息（另一种策略是block阻塞），消息也会被丢失。抑或，消息产生（异步产生）过快，导致挂起线程过多，内存不足，导致程序崩溃，消息丢失。</p>
</li>
</ul>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul>
<li>为了确定消息是发送成功，我们要判断消息发送的结果。可以采用为其添加回调函数的形式</li>
<li>为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3</li>
<li>异步发送消息改为同步发送消。或者service产生消息时，使用阻塞的线程池，并且线程数有一定上限。整体思路是控制消息产生速度。</li>
<li>扩大Buffer的容量配置。这种方式可以缓解该情况的出现，但不能杜绝。</li>
<li>service不直接将消息发送到buffer（内存），而是将消息写到本地的磁盘中（数据库或者文件），由另一个（或少量）生产线程进行消息发送。相当于是在buffer和service之间又加了一层空间更加富裕的缓冲层。</li>
</ul>
<h3 id="Consumer丢失消息的情况"><a href="#Consumer丢失消息的情况" class="headerlink" title="Consumer丢失消息的情况"></a>Consumer丢失消息的情况</h3><p>Consumer消费消息有下面几个步骤：</p>
<ul>
<li>接收消息</li>
<li>处理消息</li>
<li>反馈“处理完毕”（commited）</li>
</ul>
<p>Consumer的消费方式主要分为两种：</p>
<ul>
<li>自动提交offset，Automatic Offset Committing</li>
<li>手动提交offset，Manual Offset Control</li>
</ul>
<h4 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h4><p>Consumer自动提交的机制是根据一定的时间间隔，将收到的消息进行commit。commit过程和消费消息的过程是异步的。也就是说，可能存在消费过程未成功（比如抛出异常），commit消息已经提交了。此时消息就丢失了。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset </p>
<h3 id="Broker丢失消息的情况"><a href="#Broker丢失消息的情况" class="headerlink" title="Broker丢失消息的情况"></a>Broker丢失消息的情况</h3><p>Broker丢失消息是由于Kafka本身的原因造成的，kafka为了得到更高的性能和吞吐量，将数据异步批量的存储在磁盘中。消息的刷盘过程，为了提高性能，减少刷盘次数，kafka采用了批量刷盘的做法。即，按照一定的消息量，和时间间隔进行刷盘。这种机制也是由于linux操作系统决定的。将<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdcs?from=10680">数据存储</a>到linux操作系统种，会先存储到页缓存（Page cache）中，按照时间或者其他条件进行刷盘（从page cache到file），或者通过fsync命令强制刷盘。数据在page cache中时，如果系统挂掉，数据会丢失。</p>
<p><img src="/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/28r5mhz90v.png"></p>
<p>Broker在linux服务器上高速读写以及同步到Replica</p>
<p>上图简述了broker写数据以及同步的一个过程。broker写数据只写到PageCache中，而pageCache位于内存。这部分数据在断电后是会丢失的。pageCache的数据通过linux的flusher程序进行刷盘。刷盘触发条件有三：</p>
<ul>
<li>主动调用sync或fsync函数</li>
<li>可用内存低于阀值</li>
<li>dirty data时间达到阀值。dirty是pagecache的一个标识位，当有数据写入到pageCache时，pagecache被标注为dirty，数据刷盘以后，dirty标志清除。</li>
</ul>
<p>Broker配置刷盘机制，是通过调用fsync函数接管了刷盘动作。从单个Broker来看，pageCache的数据会丢失。</p>
<p>理论上，要完全让kafka保证单个broker不丢失消息是做不到的，只能通过调整刷盘机制的参数缓解该情况。比如，减少刷盘间隔，减少刷盘数据量大小。时间越短，性能越差，可靠性越好（尽可能可靠）。这是一个选择题。</p>
<p>为了解决该问题，kafka通过producer和broker协同处理单个broker丢失参数的情况。一旦producer发现broker消息丢失，即可自动进行retry。除非retry次数超过阀值（可配置），消息才会丢失。此时需要生产者客户端手动处理该情况。那么producer是如何检测到数据丢失的呢？是通过ack机制，类似于http的三次握手的方式。</p>
<ul>
<li>acks&#x3D;0，producer不等待broker的响应，效率最高，但是消息很可能会丢。</li>
<li>acks&#x3D;1，leader broker收到消息后，不等待其他follower的响应，即返回ack。也可以理解为ack数为1。此时，如果follower还没有收到leader同步的消息leader就挂了，那么消息会丢失。按照上图中的例子，如果leader收到消息，成功写入PageCache后，会返回ack，此时producer认为消息发送成功。但此时，按照上图，数据还没有被同步到follower。如果此时leader断电，数据会丢失。</li>
<li>acks&#x3D;-1，leader broker收到消息后，挂起，等待所有ISR列表中的follower返回结果后，再返回ack。-1等效与all。这种配置下，只有leader写入数据到pagecache是不会返回ack的，还需要所有的ISR返回“成功”才会触发ack。如果此时断电，producer可以知道消息没有被发送成功，将会重新发送。如果在follower收到数据以后，成功返回ack，leader断电，数据将存在于原来的follower中。在重新选举以后，新的leader会持有该部分数据。数据从leader同步到follower，需要2步：</li>
<li><ul>
<li>数据从pageCache被刷盘到disk。因为只有disk中的数据才能被同步到replica。</li>
<li>数据同步到replica，并且replica成功将数据写入PageCache。在producer得到ack后，哪怕是所有机器都停电，数据也至少会存在于leader的磁盘内。</li>
</ul>
</li>
</ul>
<p>上面第三点提到了ISR的列表的follower，需要配合另一个参数才能更好的保证ack的有效性。ISR是Broker维护的一个“可靠的follower列表”，in-sync Replica列表，broker的配置包含一个参数：min.insync.replicas。该参数表示ISR中最少的副本数。如果不设置该值，ISR中的follower列表可能为空。此时相当于acks&#x3D;1。</p>
<p><img src="/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/o8vnpl786j.png"></p>
<p>如上图中：</p>
<ul>
<li>acks&#x3D;0，总耗时f(t) &#x3D; f(1)。</li>
<li>acks&#x3D;1，总耗时f(t) &#x3D; f(1) + f(2)。</li>
<li>acks&#x3D;-1，总耗时f(t) &#x3D; f(1) + max( f(A) , f(B) ) + f(2)。</li>
</ul>
<p>性能依次递减，可靠性依次升高。</p>
<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><h3 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h3><p><strong>已经消费了数据，但是offset没有成功提交。其中很大一部分原因在于发生了再均衡。</strong></p>
<ul>
<li>消费者宕机、重启等。导致消息已经消费但是没有提交offset。</li>
<li>消费者使用自动提交offset，但当还没有提交的时候，有新的消费者加入或者移除，发生了rebalance。再次消费的时候，消费者会根据提交的偏移量来，于是重复消费了数据。</li>
<li>消息处理耗时，或者消费者拉取的消息量太多，处理耗时，超过了max.poll.interval.ms的配置时间，导致认为当前消费者已经死掉，触发再均衡。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>乐观锁：每个数据都有一个版本号，和当前版本号相同时进行更新操作</li>
<li>去重表（缓存）：唯一索引，如果已存在值，就不进行更新了</li>
</ul>
<h2 id="Kafka-consumer-是推还是拉？"><a href="#Kafka-consumer-是推还是拉？" class="headerlink" title="Kafka consumer 是推还是拉？"></a>Kafka consumer 是推还是拉？</h2><p>customer 应该从 brokes 拉取消息还是 brokers 将消息推送到 consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从broker 拉取消息。</p>
<h2 id="Kafka-的设计架构"><a href="#Kafka-的设计架构" class="headerlink" title="Kafka 的设计架构"></a>Kafka 的设计架构</h2><ul>
<li>Producer</li>
<li>Consumer</li>
<li>Topic</li>
<li>Consumer Group</li>
<li>Broker </li>
<li>Partition</li>
<li>Offset</li>
</ul>
<h2 id="Kafka-分区的目的"><a href="#Kafka-分区的目的" class="headerlink" title="Kafka 分区的目的"></a>Kafka 分区的目的</h2><p>实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率。</p>
<h2 id="Kafka-是如何做到消息的有序性"><a href="#Kafka-是如何做到消息的有序性" class="headerlink" title="Kafka 是如何做到消息的有序性"></a>Kafka 是如何做到消息的有序性</h2><p>kafka 中的每个 partition 中的消息在写入时都是有序的，而且单独一个 partition 只能由一个消费者去消费，可以在里面保证消息的顺序性。但是分区之间的消息是不保证有序的。</p>
<h2 id="ISR、OSR、AR-是什么"><a href="#ISR、OSR、AR-是什么" class="headerlink" title="ISR、OSR、AR 是什么"></a>ISR、OSR、AR 是什么</h2><p>ISR：In-Sync Replicas 副本同步队列<br>OSR：Out-of-Sync Replicas<br>AR：Assigned Replicas 所有副本</p>
<p>ISR是由leader维护，follower从leader同步数据有一些延迟（具体可以参见 图文了解 Kafka 的副本复制机制），超过相应的阈值会把 follower 剔除出 ISR, 存入OSR（Out-of-Sync Replicas ）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</p>
<h2 id="Kafka-数据一致性原理"><a href="#Kafka-数据一致性原理" class="headerlink" title="Kafka 数据一致性原理"></a>Kafka 数据一致性原理</h2><p>一致性就是说不论是老的 Leader 还是新选举的 Leader，Consumer 都能读到一样的数据。</p>
<p><img src="/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%80%E8%87%B4%E6%80%A7.png"></p>
<p>假设分区的副本为3，其中副本0是 Leader，副本1和副本2是 follower，并且在 ISR 列表里面。虽然副本0已经写入了 Message4，但是 Consumer 只能读取到 Message2。因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，对应于上图的副本2，这个很类似于木桶原理。</p>
<p>这样做的原因是还没有被足够多副本复制的消息被认为是“不安全”的，如果 Leader 发生崩溃，另一个副本成为新 Leader，那么这些消息很可能丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。试想，一个消费者从当前 Leader（副本0） 读取并处理了 Message4，这个时候 Leader 挂掉了，选举了副本1为新的 Leader，这时候另一个消费者再去从新的 Leader 读取消息，发现这个消息其实并不存在，这就导致了数据不一致性问题。</p>
<p>当然，引入了 High Water Mark 机制，会导致 Broker 间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会随之变长（因为我们会先等待消息复制完毕）。延迟时间可以通过参数 replica.lag.time.max.ms 参数配置，它指定了副本在复制消息时可被允许的最大延迟时间。</p>
<h2 id="Kafka-消费者是否可以消费指定分区消息"><a href="#Kafka-消费者是否可以消费指定分区消息" class="headerlink" title="Kafka 消费者是否可以消费指定分区消息"></a>Kafka 消费者是否可以消费指定分区消息</h2><p>Kafa consumer消费消息时，向broker发出fetch请求去消费特定分区的消息，consumer指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer拥有了offset的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的</p>
<h2 id="Kafka-的再均衡"><a href="#Kafka-的再均衡" class="headerlink" title="Kafka 的再均衡"></a>Kafka 的再均衡</h2><p>在Kafka中，当有新消费者加入或者订阅的topic数发生变化时，会触发Rebalance(再均衡：在同一个消费者组当中，分区的所有权从一个消费者转移到另外一个消费者)机制，Rebalance顾名思义就是重新均衡消费者消费。Rebalance的过程如下：<br>第一步：所有成员都向coordinator发送请求，请求入组。一旦所有成员都发送了请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader。<br>第二步：leader开始分配消费方案，指明具体哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案发给coordinator。coordinator接收到分配方案之后会把方案发给各个consumer，这样组内的所有成员就都知道自己应该消费哪些分区了。<br>所以对于Rebalance来说，Coordinator起着至关重要的作用</p>
<h2 id="kafka-维护消费状态跟踪的方法有什么"><a href="#kafka-维护消费状态跟踪的方法有什么" class="headerlink" title="kafka 维护消费状态跟踪的方法有什么"></a>kafka 维护消费状态跟踪的方法有什么</h2><p>Kafka 采用了不同的策略。Topic 被分成了若干分区，每个分区在同一时间只被一个 consumer 消费。这意味着每个分区被消费的消息在日志中的位置仅仅是一个简单的整数：offset。这样就很容易标记每个分区消费状态就很容易了，仅仅需要一个整数而已。这样消费状态的跟踪就很简单了。</p>
<p>这带来了另外一个好处：consumer 可以把 offset 调成一个较老的值，去重新消费老的消息。</p>
<h2 id="Kafka主从同步"><a href="#Kafka主从同步" class="headerlink" title="Kafka主从同步"></a>Kafka主从同步</h2><p>Kafka允许topic的分区拥有若干副本，这个数量是可以配置的，你可以为每个topic配置副本的数量。Kafka会自动在每个个副本上备份数据，所以当一个节点down掉时数据依然是可用的。</p>
<p>Kafka的副本功能不是必须的，你可以配置只有一个副本，这样其实就相当于只有一份数据。</p>
<h2 id="Zookeeper-对于-Kafka-的作用是什么"><a href="#Zookeeper-对于-Kafka-的作用是什么" class="headerlink" title="Zookeeper 对于 Kafka 的作用是什么"></a>Zookeeper 对于 Kafka 的作用是什么</h2><p>Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。</p>
<p>Zookeeper 主要用于在集群中不同节点之间进行通信</p>
<p>在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。</p>
<h2 id="Kafka数据传输的事务定义有哪三种"><a href="#Kafka数据传输的事务定义有哪三种" class="headerlink" title="Kafka数据传输的事务定义有哪三种"></a>Kafka数据传输的事务定义有哪三种</h2><p>和 MQTT 的事务定义一样都是 3 种。</p>
<p>（1）最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输</p>
<p>（2）最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.</p>
<p>（3）精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的</p>
<h2 id="Kafka-判断一个节点是否还存活条件"><a href="#Kafka-判断一个节点是否还存活条件" class="headerlink" title="Kafka 判断一个节点是否还存活条件"></a>Kafka 判断一个节点是否还存活条件</h2><p>（1）节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接</p>
<p>（2）如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久</p>
<h2 id="Kafka-与传统-MQ-消息系统之间有什么区别"><a href="#Kafka-与传统-MQ-消息系统之间有什么区别" class="headerlink" title="Kafka 与传统 MQ 消息系统之间有什么区别"></a>Kafka 与传统 MQ 消息系统之间有什么区别</h2><p>(1).Kafka 持久化日志，这些日志可以被重复读取和无限期保留</p>
<p>(2).Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性</p>
<p>(3).Kafka 支持实时的流式处理</p>
<h2 id="消费者故障，出现活锁问题如何解决"><a href="#消费者故障，出现活锁问题如何解决" class="headerlink" title="消费者故障，出现活锁问题如何解决"></a>消费者故障，出现活锁问题如何解决</h2><p>出现“活锁”的情况，是它持续的发送心跳，但是没有处理。为了预防消费者在这种情况下一直持有分区，我们使用 max.poll.interval.ms 活跃检测机制。 在此基础上，如果你调用的 poll 的频率大于最大间隔，则客户端将主动地离开组，以便其他消费者接管该分区。 发生这种情况时，你会看到 offset 提交失败。这是一种安全机制，保障只有活动成员能够提交 offset。所以要留在组中，你必须持续调用 poll。</p>
<h2 id="Kafka如何控制消费的位置"><a href="#Kafka如何控制消费的位置" class="headerlink" title="Kafka如何控制消费的位置"></a>Kafka如何控制消费的位置</h2><p>kafka 使用 seek(TopicPartition, long)指定新的消费位置。用于查找服务器保留的最早和最新的 offset 的特殊的方法也可用（seekToBeginning(Collection) 和seekToEnd(Collection)）</p>
<h2 id="Kafka-的高可用机制是什么"><a href="#Kafka-的高可用机制是什么" class="headerlink" title="Kafka 的高可用机制是什么"></a>Kafka 的高可用机制是什么</h2><p>多副本冗余的高可用机制 </p>
<p>producer、broker 和 consumer 都会拥有多个</p>
<p>分区选举机制 、 消息确认机制</p>
<h2 id="Kafka-是如何实现高吞吐率的"><a href="#Kafka-是如何实现高吞吐率的" class="headerlink" title="Kafka 是如何实现高吞吐率的"></a>Kafka 是如何实现高吞吐率的</h2><p>Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。kafka主要使用了以下几个方式实现了超高的吞吐率：</p>
<ul>
<li>顺序读写；</li>
<li>零拷贝</li>
<li>文件分段</li>
<li>批量发送</li>
<li>数据压缩。</li>
</ul>
<h2 id="如何为Kafka集群选择合适的Topics-x2F-Partitions数量"><a href="#如何为Kafka集群选择合适的Topics-x2F-Partitions数量" class="headerlink" title="如何为Kafka集群选择合适的Topics&#x2F;Partitions数量"></a>如何为Kafka集群选择合适的Topics&#x2F;Partitions数量</h2><h2 id="Kafka-分区数可以增加或减少吗"><a href="#Kafka-分区数可以增加或减少吗" class="headerlink" title="Kafka 分区数可以增加或减少吗"></a>Kafka 分区数可以增加或减少吗</h2><p>只能增加，不能减少</p>
<h2 id="消息如何分发"><a href="#消息如何分发" class="headerlink" title="消息如何分发"></a>消息如何分发</h2><p>若该队列⾄少有⼀个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给⼀个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p>
<h2 id="Consumer-commit机制是什么"><a href="#Consumer-commit机制是什么" class="headerlink" title="Consumer commit机制是什么"></a>Consumer commit机制是什么</h2><p>偏移量的确认，在push模式下是通过ack来确定，如果失败进去重试队列，在pull模式下可以自动确认也可手动确认，但是异常就没办法进入重试队列</p>
<h2 id="RocketMQ实现原理"><a href="#RocketMQ实现原理" class="headerlink" title="RocketMQ实现原理"></a>RocketMQ实现原理</h2><p>RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成，它的架构原理是这样的：</p>
<ol>
<li>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li>
<li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li>
<li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li>
</ol>
<p><img src="/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/RocketMQ.jpg"></p>
<h2 id="为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a>为什么RocketMQ不使用Zookeeper作为注册中心呢？</h2><p>我认为有以下几个点是不使用zookeeper的原因：</p>
<ol>
<li>根据CAP理论，同时最多只能满足两个点，而zookeeper满足的是CP，也就是说zookeeper并不能保证服务的可用性，zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</li>
<li>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而zookeeper的写是不可扩展的，而zookeeper要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</li>
<li>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</li>
<li>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</li>
</ol>
<h2 id="RocketMQ-Broker怎么保存数据"><a href="#RocketMQ-Broker怎么保存数据" class="headerlink" title="RocketMQ Broker怎么保存数据"></a>RocketMQ Broker怎么保存数据</h2><p>RocketMQ主要的存储文件包括commitlog文件、consumequeue文件、indexfile文件。</p>
<p>Broker在收到消息之后，会把消息保存到commitlog的文件当中，而同时在分布式的存储当中，每个broker都会保存一部分topic的数据，同时，每个topic对应的messagequeue下都会生成consumequeue文件用于保存commitlog的物理位置偏移量offset，indexfile中会保存key和offset的对应关系。</p>
<h2 id="RocketMQ中Master和Slave间怎么同步数据"><a href="#RocketMQ中Master和Slave间怎么同步数据" class="headerlink" title="RocketMQ中Master和Slave间怎么同步数据"></a>RocketMQ中Master和Slave间怎么同步数据</h2><p>消息在master和slave之间的同步是根据raft协议来进行的：</p>
<ol>
<li>在broker收到消息后，会被标记为uncommitted状态</li>
<li>然后会把消息发送给所有的slave</li>
<li>slave在收到消息之后返回ack响应给master</li>
<li>master在收到超过半数的ack之后，把消息标记为committed</li>
<li>发送committed消息给所有slave，slave也修改状态为committed</li>
</ol>
<h2 id="RocketMQ为什么速度快"><a href="#RocketMQ为什么速度快" class="headerlink" title="RocketMQ为什么速度快"></a>RocketMQ为什么速度快</h2><p>是因为使用了顺序存储、Page Cache和异步刷盘。</p>
<ol>
<li>我们在写入commitlog的时候是顺序写入的，这样比随机写入的性能就会提高很多</li>
<li>写入commitlog的时候并不是直接写入磁盘，而是先写入操作系统的PageCache</li>
<li>最后由操作系统异步将缓存中的数据刷到磁盘</li>
</ol>
<h2 id="什么是事务、半事务消息？怎么实现的？"><a href="#什么是事务、半事务消息？怎么实现的？" class="headerlink" title="什么是事务、半事务消息？怎么实现的？"></a>什么是事务、半事务消息？怎么实现的？</h2><p>事务消息就是MQ提供的类似XA的分布式事务能力，通过事务消息可以达到分布式事务的最终一致性。</p>
<p>半事务消息就是MQ收到了生产者的消息，但是没有收到二次确认，不能投递的消息。</p>
<p>实现原理如下：</p>
<ol>
<li>生产者先发送一条半事务消息到MQ</li>
<li>MQ收到消息后返回ack确认</li>
<li>生产者开始执行本地事务</li>
<li>如果事务执行成功发送commit到MQ，失败发送rollback</li>
<li>如果MQ长时间未收到生产者的二次确认commit或者rollback，MQ对生产者发起消息回查</li>
<li>生产者查询事务执行最终状态</li>
<li>根据查询事务状态再次提交二次确认</li>
</ol>
<p>最终，如果MQ收到二次确认commit，就可以把消息投递给消费者，反之如果是rollback，消息会保存下来并且在3天后被删除。</p>
<p><img src="/2022/07/02/MessageQueue-%E9%9D%A2%E8%AF%95%E9%A2%98/RocketMQ_Transaction.jpg"></p>
<h2 id="RabbitMQ消息基于什么传输"><a href="#RabbitMQ消息基于什么传输" class="headerlink" title="RabbitMQ消息基于什么传输"></a>RabbitMQ消息基于什么传输</h2><p>RabbitMQ使⽤信道的⽅式来传输数据。信道是建⽴在真实的TCP连接内的虚拟连接，且每条</p>
<p>TCP连接上的信道数量没有限制。</p>
<ol>
<li>RabbitMQ采⽤类似NIO（Non-blocking I&#x2F;O）做法，选择TCP连接复⽤，不仅可以减少性能开销，同时也便于管理。</li>
<li>每个线程把持⼀个信道，所以信道服⽤了Connection的TCP连接。同时RabbitMQ可以确保每个线程的私密性，就像拥有独立的连接一样。</li>
</ol>
<h2 id="RabbitMQ消息怎么路由"><a href="#RabbitMQ消息怎么路由" class="headerlink" title="RabbitMQ消息怎么路由"></a>RabbitMQ消息怎么路由</h2><p>从概念上来说，消息路由必须有三部分：交换器、路由、绑定。⽣产者把消息发布到交换器上；绑定决定了消息如何从交换器路由到特定的队列；消息最终到达队列，并被消费者接收。</p>
<ol>
<li>消息发布到交换器时，消息将拥有⼀个路由键（routing key），在消息创建时设定。</li>
<li>通过队列路由键，可以把队列绑定到交换器上。</li>
<li>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。</li>
<li>如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进⼊ “⿊洞”。</li>
</ol>
<h2 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h2><p>在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p>
<h2 id="RocketMQ-的高可用性"><a href="#RocketMQ-的高可用性" class="headerlink" title="RocketMQ 的高可用性"></a>RocketMQ 的高可用性</h2><ul>
<li>多master 模式</li>
<li>多master多slave异步复制模式</li>
<li>多 master多slave同步双写模式</li>
</ul>
<p>多master多slave模式通信过程如下</p>
<p>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p>
<h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<h2 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h2><ul>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>
</ul>
<h2 id="RabbitMQ设置过期时间，部分消息丢失"><a href="#RabbitMQ设置过期时间，部分消息丢失" class="headerlink" title="RabbitMQ设置过期时间，部分消息丢失"></a>RabbitMQ设置过期时间，部分消息丢失</h2><p>批量重导</p>
<h2 id="MQ磁盘写满"><a href="#MQ磁盘写满" class="headerlink" title="MQ磁盘写满"></a>MQ磁盘写满</h2><p>代表已经积压过度。添加新消费者，或记录SEEK 号后，接入新程序消费后丢弃，空闲时刻重新SEEK消费</p>
<h2 id="如何设计MQ"><a href="#如何设计MQ" class="headerlink" title="如何设计MQ"></a>如何设计MQ</h2><ul>
<li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li>
<li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li>
<li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li>
<li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li>
</ul>
<h2 id="Redis做消息队列与其他消息队列相比有什么不同"><a href="#Redis做消息队列与其他消息队列相比有什么不同" class="headerlink" title="Redis做消息队列与其他消息队列相比有什么不同"></a>Redis做消息队列与其他消息队列相比有什么不同</h2><h3 id="Redis作为消息队列"><a href="#Redis作为消息队列" class="headerlink" title="Redis作为消息队列"></a>Redis作为消息队列</h3><ul>
<li>如果你的需求是快产快消的即时消费场景，并且生产的消息立即被消费者消费掉。</li>
<li>如果速度是你十分看重的，比如慢了一秒好几千万这种。</li>
<li>如果允许出现消息丢失的场景。</li>
<li>如果你不需要系统保存你发送过的消息。</li>
<li>如果需要处理的数据量并不是那么巨大。</li>
</ul>
<h3 id="其他消息队列"><a href="#其他消息队列" class="headerlink" title="其他消息队列"></a>其他消息队列</h3><ul>
<li>如果你想要稳定的消息队列。</li>
<li>如果你想要你发送过的消息可以保留一定的时间，并不是无迹可寻的时候。</li>
<li>如果你无法忍受数据的丢失。</li>
<li>如果速度不需要那么的快。</li>
<li>如果需要处理数据量巨大的时候。</li>
</ul>
<h3 id="应用场景分析"><a href="#应用场景分析" class="headerlink" title="应用场景分析"></a>应用场景分析</h3><p>Redis：轻量级，高并发，延迟敏感<br>即时数据分析、秒杀计数器、缓存等。</p>
<p>其他MQ：重量级，高并发，异步<br>批量数据异步处理、并行任务串行化，高负载任务的负载均衡等。</p>
<h6 id="来源"><a href="#来源" class="headerlink" title="来源:"></a>来源:</h6><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904094021189639">https://juejin.cn/post/6844904094021189639</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1757914">https://cloud.tencent.com/developer/article/1757914</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangyongjie/p/14675119.html">https://www.cnblogs.com/yangyongjie/p/14675119.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368773517">https://zhuanlan.zhihu.com/p/368773517</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127589/2679155">https://blog.51cto.com/u_15127589/2679155</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/282993811">https://zhuanlan.zhihu.com/p/282993811</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helios-fz/p/12119727.html">https://www.cnblogs.com/helios-fz/p/12119727.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6973662966331736101">https://juejin.cn/post/6973662966331736101</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/JAVA%E9%9D%A2%E8%AF%95%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/JAVA%E9%9D%A2%E8%AF%95%E6%80%9D%E8%B7%AF/" class="post-title-link" itemprop="url">JAVA面试思路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 17:09:01" itemprop="dateCreated datePublished" datetime="2022-07-02T17:09:01+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><ul>
<li><p>提问走向 – 优点、缺点、匹配点</p>
<ul>
<li><p>各自优缺点，项目为何选用某一种</p>
<ul>
<li><p>List</p>
<p>ArrayList、LinkedList</p>
</li>
<li><p>Map</p>
<p>HashMap、LinkedHshMap、TreeMap、ConcurrentHashMap</p>
</li>
<li><p>JUC</p>
</li>
<li><p>GC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul>
<li>CURD<ul>
<li>多次Create<ul>
<li>幂等性</li>
</ul>
</li>
<li>批量Delete<ul>
<li>如何删除大量数据，分批次？另起Job删？</li>
</ul>
</li>
<li>并发Update<ul>
<li>保证变更顺序，避免对账异常</li>
</ul>
</li>
<li>海量Require<ul>
<li>索引相关</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><ul>
<li>各自优缺点、为何选型</li>
</ul>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul>
<li>集群、分布式特性<ul>
<li>集群</li>
<li>分布式<ul>
<li>CAP</li>
<li>不同Middleware复合CAP中的哪一部分，以及优缺点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SpringBoot如何与中间件集成"><a href="#SpringBoot如何与中间件集成" class="headerlink" title="SpringBoot如何与中间件集成"></a>SpringBoot如何与中间件集成</h3><h2 id="DesignPattern"><a href="#DesignPattern" class="headerlink" title="DesignPattern"></a>DesignPattern</h2><ul>
<li><p>Spring、Middleware使用哪些设计模式</p>
</li>
<li><p>是否Singleton</p>
<ul>
<li>配置类一般是Singleton</li>
</ul>
</li>
<li><p>是否线程安全</p>
</li>
</ul>
<h1 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h1><h2 id="业务量"><a href="#业务量" class="headerlink" title="业务量"></a>业务量</h2><ul>
<li><p>UV – 独立访问量</p>
</li>
<li><p>PV</p>
</li>
<li><p>QPS</p>
<ul>
<li>每小时最大UV &#x2F; 3600 &#x3D; QPS</li>
</ul>
</li>
<li><p>TPS</p>
</li>
<li><p>访问量激增时如何搭建高并发系统</p>
<ul>
<li>页面缓存</li>
<li>Nginx Cache</li>
<li>Load Balance</li>
<li>Server Cache</li>
<li>读写DB</li>
<li>分库分表</li>
</ul>
</li>
</ul>
<h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><ul>
<li>上下游</li>
<li>优化、重构<ul>
<li>读多写少、写多读少</li>
<li>实时性要求</li>
</ul>
</li>
</ul>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul>
<li>思路</li>
<li>影响力</li>
</ul>
<h6 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h6><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KU4y1L7JA">https://www.bilibili.com/video/BV1KU4y1L7JA</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/issues/1909">https://github.com/alibaba/spring-cloud-alibaba/issues/1909</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/JVM-ZGC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/JVM-ZGC/" class="post-title-link" itemprop="url">JVM-ZGC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 17:04:39" itemprop="dateCreated datePublished" datetime="2022-07-02T17:04:39+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id><a href="#" class="headerlink" title></a></h6><p><a target="_blank" rel="noopener" href="https://rumenz.com/rumenbiji/jvm-zgc.html">https://rumenz.com/rumenbiji/jvm-zgc.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2022/07/02/JVM-G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/JVM-G1/" class="post-title-link" itemprop="url">JVM-G1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-02 17:04:33" itemprop="dateCreated datePublished" datetime="2022-07-02T17:04:33+08:00">2022-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><h2 id="G1垃圾收集器简介"><a href="#G1垃圾收集器简介" class="headerlink" title="G1垃圾收集器简介"></a>G1垃圾收集器简介</h2><blockquote>
<p>Garbage First(简称:G1)收集器是垃圾收集器技术发展历史上的一个里程碑,它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式.</p>
<p>G1是一款主要面向服务端应用的垃圾收集器,HotSpot开发团队赋予它的期望是未来可以替换掉JDK5中发布的CMS收集器. JDK9发布之日,G1宣布取代了<code>Parallel Scavenge</code>加<code>Parallel Old</code>的组合,成为服务端模式下默认的垃圾收集器,而CMS则被声明为(Deprecate)使用的收集器.</p>
<p>G1收集器兼顾<code>低延迟</code>和<code>高吞吐</code>在服务端运行,HotSpot团队期望取代<code>CMS</code>收集器。也就是在满足停顿时间的情况下获取最大的吞度量。有两种收集模式<code>Young GC</code>和Mixed GC。G1收集器将堆内存划分成大小相等的<code>Region</code>,新生代,老年代也就成了逻辑概念。整体上采用的是<code>标记-整理</code>算法,局部采用了<code>复制算法</code>。</p>
<p>G1实现了可控停顿时间的垃圾收集器,通过<code>-XX:MaxGCPauseMillis</code>参数进行设置，默认是200ms。</p>
<p>G1是jdk1.9的默认垃圾收集器,-XX:+UseG1GC开启</p>
</blockquote>
<p><img src="/2022/07/02/JVM-G1/1606304961.png" alt="image"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/02/JVM-G1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
