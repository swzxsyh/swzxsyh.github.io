<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="swzxsyh">
<meta property="og:url" content="https://swzxsyh.github.io/page/13/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swzxsyh.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/06/01/Spring-XML-Annotation-JDBCTemplate-Transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Spring-XML-Annotation-JDBCTemplate-Transaction/" class="post-title-link" itemprop="url">Spring XML & Annotation,JDBCTemplate & Transaction</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 01:43:52" itemprop="dateCreated datePublished" datetime="2020-06-01T01:43:52+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.基于XML的AOP开发<br>1.1 XML配置详解<br>1.1.1 切点表达式<br>1<br>execution([修饰符] 返回值类型 包名.类名.方法名(参数列表))<br>访问修饰符可以省略</p>
<p>返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意</p>
<p>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p>
<p>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p>
<p>版本	<br>版本一	控制目标对象中，返回值类型void且public修饰的所有方法<br>execution(public void com.test.service.impl.AccountServiceImpl.<em>(..))<br>版本二	控制目标对象中，任意修饰符任意返回值的所有方法<br>execution(</em> com.test.service.impl.AccountServiceImpl.<em>(..))<br>版本三	版本三：控制service层所有对象的方法<br>execution(</em> com.test.service…(..))<br>切点表达式抽取</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemalocation="
           http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p>
  <!--开启注解组件扫描-->
<p>  &lt;context:component-scan base-package&#x3D;”com.test”&#x2F;&gt;</p>
<p>  <bean id="myAdvice" class="com.test.advice.MyAdvice"></bean><br>  <!--aop配置--><br>  <a href="aop:config">aop:config</a><br>    <!--切面--><br>    &lt;aop:aspect ref&#x3D;”myAdvice”&gt;<br>      <!--抽取切点表达式--><br>      &lt;aop:pointcut id&#x3D;”myPointcut” expression&#x3D;”execution(* com.test.service..*.*(..))”&#x2F;&gt;<br>      <!--织入过程...
            method="通知方法" 通知方法
            pointcut="切点表达式"
            execution([修饰符] 返回值类型  包名.类名.方法名(参数列表))
            --><br>      &lt;aop:before method&#x3D;”before” pointcut-ref&#x3D;”myPointcut”&gt;<br>    <br>  <br><br>1.2.2 通知类型<br>通知的配置语法</p>
<p>1<br>&lt;aop:通知类型 method&#x3D;”通知类中方法名” pointcut&#x3D;”切点表达式”&gt;&lt;&#x2F;aop:通知类型&gt;<br>四大通知</p>
<p>名称	标签	说明<br>前置通知	<a href="aop:before">aop:before</a>	在切入点方法之前执行<br>后置通知	<a href="aop:afterReturning">aop:afterReturning</a>	在切入点方法正常运行之后执行<br>异常通知	<a href="aop:afterThrowing">aop:afterThrowing</a>	在切点方法发生异常的时候执行<br>最终通知	<a href="aop:after">aop:after</a>	无论切入点方法执行时是否有异常，都会执行<br>Myadvice</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>@Component<br>public class MyAdvice {</p>
<pre><code>// 前置增强
public void before() &#123;
    System.out.println(&quot;Advance Notice&quot;);
&#125;

// 后置增强
public void afterReturning()&#123;
    System.out.println(&quot;Post Notification&quot;);
&#125;

// 异常增强
public void afterThrowing()&#123;
    System.out.println(&quot;Exception Notification&quot;);
&#125;

// 最终增强
public void after()&#123;
    System.out.println(&quot;Final Notice&quot;);
&#125;
</code></pre>
<p>}<br>applicationContext.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</p>
<!--开启注解组件扫描-->
<p>&lt;context:component-scan base-package&#x3D;”com.test”&#x2F;&gt;</p>
<p><bean id="myAdvice" class="com.test.advice.MyAdvice"></bean></p>
<!--aop配置-->
<p><a href="aop:config">aop:config</a><br>  <!--切面--><br>  &lt;aop:aspect ref&#x3D;”myAdvice”&gt;<br>    <!--抽取切点表达式--><br>    &lt;aop:pointcut id&#x3D;”myPointcut” expression&#x3D;”execution(* com.test.service..*.*(..))”&#x2F;&gt;<br>    <!--织入过程...
            method="通知方法" 通知方法
            pointcut="切点表达式"
            execution([修饰符] 返回值类型  包名.类名.方法名(参数列表))
            --><br>    &lt;aop:before method&#x3D;”before” pointcut-ref&#x3D;”myPointcut”&#x2F;&gt;<br>    &lt;aop:after-returning method&#x3D;”afterReturning” pointcut-ref&#x3D;”myPointcut”&#x2F;&gt;<br>    &lt;aop:after-throwing method&#x3D;”afterThrowing” pointcut-ref&#x3D;”myPointcut”&#x2F;&gt;<br>    &lt;aop:after method&#x3D;”after” pointcut-ref&#x3D;”myPointcut”&#x2F;&gt;<br>  <br><br>注意：四大通知一般单独使用，因为xml配置顺序可能会打乱我们执行计划，建议使用环绕通知</p>
<p>环绕通知(强无敌)</p>
<p>名称	标签	说明<br>环绕通知	<a href="aop:around">aop:around</a>	可以灵活实现四大通知的所有效果<br>环绕通知的代码编写，更贴近于动态代理的底层代码</p>
<p>注意：测试环绕通知，需要注释掉四大通知</p>
<p>Myadvice</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>&#x2F;&#x2F; 环绕通知<br>&#x2F;&#x2F; Proceeding（运行）JoinPoint（连接点）  &#x3D; 切点<br>public void around(ProceedingJoinPoint proceedingJoinPoint) {<br>    try {<br>        System.out.println(“Advance notice”);<br>        &#x2F;&#x2F; 执行切点(调用目标对象原有的方法)<br>        proceedingJoinPoint.proceed();</p>
<pre><code>    System.out.println(&quot;Post Notification&quot;);
&#125; catch (Throwable throwable) &#123;
    throwable.printStackTrace();
    System.out.println(&quot;Exception Notification&quot;);
&#125; finally &#123;
    System.out.println(&quot;Final Notice&quot;);
&#125;
</code></pre>
<p>}<br>1<br>&lt;aop:around method&#x3D;”around” pointcut-ref&#x3D;”myPointcut”&gt;<br>1.2 知识小结<br>aop织入的配置<br>1<br>2<br>3<br>4<br>5<br><a href="aop:config">aop:config</a><br>    &lt;aop:aspect ref&#x3D;“通知类”&gt;<br>        &lt;aop:before method&#x3D;“通知方法名称” pointcut&#x3D;“切点表达式”&gt;&lt;&#x2F;aop:before&gt;<br>    <br><br>通知的类型</p>
<p>前置通知、后置通知、异常通知、最终通知</p>
<p>环绕通知</p>
<p>切点表达式</p>
<p>1<br>execution([修饰符] 返回值类型 包名.类名.方法名(参数列表))<br>二.基于注解的AOP开发<br>2.1 快速入门<br>复制上面的xml工程</p>
<p>目标对象</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@Service<br>public class AccountServiceImpl implements AccountService {<br>    @Override<br>    public void transfer() {<br>        System.out.println(“Transfer”);<br>    }</p>
<pre><code>@Override
public void save() &#123;
    System.out.println(&quot;Save&quot;);
&#125;
</code></pre>
<p>}<br>通知对象</p>
<p>1<br>2<br>3<br>&#x2F;&#x2F;通知类(增强)<br>@Component<br>public class MyAdvice {<br>开启Spring的AOP注解支持</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemalocation="
           http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p>
<pre><code>&lt;!--开启注解组件扫描--&gt;
&lt;context:component-scan base-package=&quot;com.test&quot;/&gt;

&lt;!-- 开启Spring的AOP注解支持 --&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>

将通知升级为切面(通知+切点= 切面)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>&#x2F;&#x2F;通知类(增强)<br>@Component<br>&#x2F;&#x2F;升级为切面<br>@Aspect<br>public class MyAdvice {</p>
<pre><code>@Pointcut(&quot;execution(* com.test.service..*.*(..))&quot;)
public void myPointcut()&#123;&#125;

// 前置增强
@Before(&quot;MyAdvice.myPointcut()&quot;)
public void before() &#123;
    System.out.println(&quot;Advance notice&quot;);
&#125;

// 后置增强
@AfterReturning(&quot;MyAdvice.myPointcut()&quot;)
public void afterReturning() &#123;
    System.out.println(&quot;Post Notification&quot;);
&#125;

// 异常增强
@AfterThrowing(&quot;MyAdvice.myPointcut()&quot;)
public void afterThrowing() &#123;
    System.out.println(&quot;Exception Notification&quot;);
&#125;

// 最终增强
@After(&quot;MyAdvice.myPointcut()&quot;)
public void after() &#123;
    System.out.println(&quot;Final Notice&quot;);
&#125;
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class AccountTest {</p>
<pre><code>// 配置了aop之后，这就是代理对象
@Autowired
private AccountService accountService;

@Test
public void testAOP() throws Exception&#123;
    accountService.transfer();
&#125;
</code></pre>
<p>}<br>2.2 注解配置详解<br>2.2.1 切点表达式<br>1<br>execution([修饰符] 返回值类型 包名.类名.方法名(参数列表))<br>访问修饰符可以省略<br>返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意<br>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类<br>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>&#x2F;&#x2F;切面类中抽取表达式<br>@Pointcut(“execution(* com.test.service..<em>.</em>(..))”)<br>public void myPointcut(){}</p>
<p>&#x2F;&#x2F;上面代码替代了XML文件中的<br>&lt;aop:pointcut id&#x3D;”myPointcut” expression&#x3D;”execution(* com.test.service..*.*(..))”&#x2F;&gt;</p>
<hr>
<p>  &#x2F;&#x2F;直接调用<br>  @Before(“MyAdvice.myPointcut()”)<br>2.2.2 通知类型<br>四大通知</p>
<p>名称	标签	说明<br>前置通知	@Before	在切入点方法之前执行<br>后置通知	@AfterReturning	在切入点方法正常运行之后执行<br>异常通知	@AfterThrowing	在切点方法发生异常的时候执行<br>最终通知	@After	无论切入点方法执行时是否有异常，都会执行<br>注意:使用注解时，四大通知同时开启的顺序：@Before – &gt; @After –&gt; @AfterReturning(异常则@AfterThrowing)</p>
<p>​ 与XML版本相同，大于等于2个通知时，建议使用环绕通知</p>
<p>环绕通知(强无敌)</p>
<p>名称	标签	说明<br>环绕通知	@Around	可以灵活实现四大通知的所有效果<br>注意：测试时，注释掉四大通知的注解</p>
<p>当切点同时符合切点规则和环绕规则时，顺序：</p>
<p>@Around – &gt;@Before – &gt; @After –&gt; @Around 执行proceedingJoinPoint.proceed()后的动作–&gt; @AfterReturning(异常则@AfterThrowing)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>&#x2F;&#x2F;通知类(增强)<br>@Component<br>&#x2F;&#x2F;升级为切面<br>@Aspect<br>public class MyAdvice {</p>
<pre><code>@Pointcut(&quot;execution(* com.test.service..*.*(..))&quot;)
public void myPointcut()&#123;&#125;

// 环绕通知
// Proceeding（运行）JoinPoint（连接点）  = 切点
@Around(&quot;MyAdvice.myPointcut()&quot;)
public void around(ProceedingJoinPoint proceedingJoinPoint) &#123;
    try &#123;
        System.out.println(&quot;Advance notice&quot;);
        // 执行切点(调用目标对象原有的方法)
        proceedingJoinPoint.proceed();

        System.out.println(&quot;Post Notification&quot;);
    &#125; catch (Throwable throwable) &#123;
        throwable.printStackTrace();
        System.out.println(&quot;Exception Notification&quot;);
    &#125; finally &#123;
        System.out.println(&quot;Final Notice&quot;);
    &#125;
&#125;
</code></pre>
<p>}<br>2.3 纯注解配置<br>删除Spring的配置文件</p>
<p>写出Spring配置类SpringConfig</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>@Configuration<br>@ComponentScan(“com.test”)<br>@EnableAspectJAutoProxy&#x2F;&#x2F;<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a><br>public class SpringConfig {</p>
<p>}<br>修改测试代码</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration(classes &#x3D; SpringConfig.class)<br>public class AccountTest {</p>
<pre><code>// 配置了aop之后，这就是代理对象
@Autowired
private AccountService accountService;

@Test
public void testAOP() throws Exception&#123;
    accountService.transfer();
&#125;
</code></pre>
<p>}<br>2.4 知识小结<br>使用注解	作用<br>使用@Aspect注解	标注切面类<br>使用@Before等注解	标注通知方法<br>使用@Pointcut注解	抽取切点表达式<br>配置aop自动代理	<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a> 或 @EnableAspectJAutoProxy<br>三.AOP优化转账案例<br>需求</p>
<p>依然使用前面的转账案例，将两个代理工厂对象直接删除！改为spring的aop思想来实现</p>
<p>3.1 XML实现<br>新建Java模块，配置依赖</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br><?xml version="1.0" encoding="UTF-8"?><br><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelVersion>4.0.0</modelVersion></project></p>
<pre><code>&lt;groupId&gt;com.test&lt;/groupId&gt;
&lt;artifactId&gt;Spring_online_Day04_04_transfer_XML&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

&lt;!--依赖管理--&gt;

&lt;dependencies&gt;
    &lt;!--mysql--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--druid--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.1.15&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--dbUtils--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;
        &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;
        &lt;version&gt;1.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--spring核心--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--aspectj--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--spring整合junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 设置编译版本为1.8 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

Domain,Dao层对象

<p>1<br>2<br>3<br>4<br>5<br>6<br>public class Account {<br>    private Integer id;<br>    private String name;<br>    private Double money;</p>
<p>&#x2F;&#x2F;此处省略getter&#x2F;setter&#x2F;toString<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>public interface AccountDao {</p>
<pre><code>//转出
void outUser(String outUser, Double money);

//转入
void inUser(String inUser, Double money);

List&lt;Account&gt; findAll();

//转出
void outUser(Connection connection,String outUser, Double money);

//转入
void inUser(Connection connection,String inUser, Double money);
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<pre><code>@Autowired
private QueryRunner queryRunner;

@Autowired
private ConnectionUtils connectionUtils;

@Override
public void outUser(String outUser, Double money) &#123;

    try &#123;
        // 1.编写sql
        String sql = &quot;UPDATE account SET money=money-? WHERE name = ?&quot;;
        // 获取当前线程内的 conn
        Connection threadConnection = connectionUtils.getThreadConnection();
        // 2.执行sql
        queryRunner.update(threadConnection,sql, money, outUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;

&#125;

@Override
public void inUser(String inUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money+? WHERE name = ?&quot;;
        Connection threadConnection = connectionUtils.getThreadConnection();
        queryRunner.update(threadConnection,sql, money, inUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

@Override
public List&lt;Account&gt; findAll() &#123;

    List&lt;Account&gt; list = null;

    try &#123;
        String sql = &quot;SELECT * FROM account&quot;;
        list=queryRunner.query(sql,new BeanListHandler&lt;&gt;(Account.class));
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;

    return list;
&#125;

@Override
public void outUser(Connection connection, String outUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money-? WHERE name = ?&quot;;
        queryRunner.update(connection,sql, money, outUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

@Override
public void inUser(Connection connection, String inUser, Double money) &#123;
    try &#123;
        String sql = &quot;UPDATE account SET money=money+? WHERE name = ?&quot;;
        queryRunner.update(connection,sql, money, inUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>}<br>目标对象</p>
<p>1<br>2<br>3<br>4<br>public interface AccountService {<br>    &#x2F;&#x2F;转账<br>    void transfer(String outUser,String inUser,Double money);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>// 依赖AccountDao
@Autowired
private AccountDao accountDao;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;
    accountDao.outUser(outUser,money);
    accountDao.inUser(inUser,money);
&#125;
</code></pre>
<p>}</p>
<p>通知对象</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>@Component<br>public class TransactionManager {</p>
<pre><code>@Autowired
private ConnectionUtils connectionUtils;

// 1.开启事务
public void beginTransaction()&#123;
    try &#123;
        connectionUtils.getThreadConnection().setAutoCommit(false);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

// 2.提交事务
public void commit()&#123;
    try &#123;
        connectionUtils.getThreadConnection().commit();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

// 3.回滚事务
public void rollback()&#123;
    try &#123;
        connectionUtils.getThreadConnection().rollback();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

// 4.释放资源
public void release()&#123;

    try &#123;
        // 恢复自动提交
        connectionUtils.getThreadConnection().setAutoCommit(true);
        // 归还到连接池
        connectionUtils.getThreadConnection().close();
        // 从当前线程删除conn对象
        connectionUtils.removeThreadConnection();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

//环绕通知
public void aroundTx(ProceedingJoinPoint proceedingJoinPoint)&#123;
    try &#123;
        beginTransaction();
        proceedingJoinPoint.proceed();
        commit();
    &#125; catch (Throwable throwable) &#123;
        throwable.printStackTrace();
        rollback();
    &#125; finally &#123;
        release();
    &#125;
&#125;
</code></pre>
<p>}<br>配置xml的切面</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p>
  <!-- 开启注解组件扫描 -->
<p>  &lt;context:component-scan base-package&#x3D;”com.test”&#x2F;&gt;</p>
  <!-- 加载第三方配置文件 -->
<p>  &lt;context:property-placeholder location&#x3D;”classpath:jdbc.properties”&#x2F;&gt;</p>
  <!--druid连接交给ioc容器,第三方类目前仅能用bean标签-->
  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="${jdbc.driver}">
    <property name="url" value="${jdbc.url}">
    <property name="username" value="${jdbc.username}">
    <property name="password" value="${jdbc.password}">
  </property></property></property></property></bean>

  <!--queryRunner交给ioc容器,第三方类目前仅能用bean标签-->
  <bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner">
    <constructor-arg name="ds" ref="dataSource">
  </constructor-arg></bean>

<p>  <a href="aop:config">aop:config</a><br>    &lt;aop:aspect ref&#x3D;”transactionManager”&gt;<br>      &lt;aop:pointcut id&#x3D;”myPointcut” expression&#x3D;”execution(* com.test.service..*.*(..))”&#x2F;&gt;<br>      &lt;aop:around method&#x3D;”aroundTx” pointcut-ref&#x3D;”myPointcut”&gt;<br>    <br>  <br></p>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class AccountTest {<br>    @Autowired<br>    private AccountService accountService;</p>
<pre><code>@Test
public void testTransferXML() throws Exception&#123;
    accountService.transfer(&quot;jerry&quot;,&quot;tom&quot;,100.0);
&#125;
</code></pre>
<p>}</p>
<p>3.2 注解实现<br>复制java模块</p>
<p>目标对象</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>// 依赖AccountDao
@Autowired
private AccountDao accountDao;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;
    accountDao.outUser(outUser,money);
    accountDao.inUser(inUser,money);
&#125;
</code></pre>
<p>}<br>通知对象</p>
<p>1<br>2<br>@Component<br>public class TransactionManager<br>开启AOP注解支持</p>
<p>SpringConfig</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>@Configuration<br>@ComponentScan(“com.test”)<br>@PropertySource(“classpath:jdbc.properties”)<br>@EnableAspectJAutoProxy<br>@Import({DataSourceConfig.class})<br>public class SpringConfig<br>将通知升级为切面</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>@Component<br>@Aspect<br>public class TransactionManager {</p>
<p>  @Autowired<br>  private ConnectionUtils connectionUtils;</p>
<pre><code>  ......
......
......

@Pointcut(&quot;execution(* com.test.service..*.*(..))&quot;)
public void myPointcut()&#123;&#125;
</code></pre>
<p>  &#x2F;&#x2F;环绕通知<br>  @Around(“TransactionManager.myPointcut()”)<br>  public void aroundTx(ProceedingJoinPoint proceedingJoinPoint){<br>    try {<br>      beginTransaction();<br>      proceedingJoinPoint.proceed();<br>      commit();<br>    } catch (Throwable throwable) {<br>      throwable.printStackTrace();<br>      rollback();<br>    } finally {<br>      release();<br>    }<br>  }<br>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@RunWith(SpringRunner.class)<br>&#x2F;&#x2F;@ContextConfiguration(“classpath:applicationContext.xml”)<br>@ContextConfiguration(classes &#x3D; SpringConfig.class)<br>public class AccountTest {<br>    @Autowired<br>    private AccountService accountService;</p>
<pre><code>@Test
public void testTransferANNO() throws Exception&#123;
    accountService.transfer(&quot;jerry&quot;,&quot;tom&quot;,100d);
&#125;
</code></pre>
<p>}<br>四.Spring的JdbcTemplate<br>4.1 JdbcTemplate是什么<br>JdbcTemplate是Spring的一款用于简化Dao代码的工具包，它底层封装了JDBC技术。</p>
<p>核心对象</p>
<p>1<br>JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(DataSource dataSource);<br>核心方法</p>
<p>方法	作用<br>int update();	执行增、删、改语句<br>List<T> query();	查询多个<br>T queryForObject();	查询一个<br>RowMapper&lt;&gt;();	ORM映射接口<br>new BeanPropertyRowMapper&lt;&gt;();	实现ORM映射封装子类<br>例</T></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class JdbcTemplateTest {<br>  @Test<br>  public void testFindAll() throws Exception {<br>    &#x2F;&#x2F; 创建核心对象<br>    JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(JdbcUtils.getDataSource());<br>    &#x2F;&#x2F; 编写sql<br>    String sql &#x3D; “select * from account”;<br>    &#x2F;&#x2F; 执行sql<br>    List<Account> list &#x3D; jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt; (Account.class));<br>  }<br>}<br>4.2 快速入门<br>创建maven的java模块</Account></p>
<p>导入依赖坐标</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39</p>
<!--依赖管理-->
<dependencies>
    <!--mysql驱动-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <!--druid连接池-->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.15</version>
    </dependency>
    <!--spring-jdbc-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
    <!--spring核心-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
    <!--junit-->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <!--spring整合junit-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
</dependencies>
复制JDBC连接池工具类和配置文件

<p>1<br>public class JdbcUtils<br>编写新增代码</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>public class JdbcTemplateTest {<br>    &#x2F;&#x2F; 新增<br>    @Test<br>    public void testJdbcTemplate() throws Exception{</p>
<pre><code>    // 1.创建JdbcTemplate核心对象
    JdbcTemplate jdbcTemplate = new JdbcTemplate(JdbcUtils.getDataSource());

    // 2.编写sql
    String sql = &quot;INSERT INTO account(name,money) VALUES (?,?)&quot;;

    // 3.执行sql
    int i = jdbcTemplate.update(sql, &quot;testJdbcTemplate&quot;, 1000d);
&#125;
</code></pre>
<p>}<br>查询</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class JdbcTemplateTest {</p>
<pre><code>@Autowired
private AccountService accountService;

// 新增
@Test
public void testJdbcTemplate() throws Exception&#123;

    // 1.创建JdbcTemplate核心对象
    JdbcTemplate jdbcTemplate = new JdbcTemplate(JdbcUtils.getDataSource());

    // 2.编写sql
    String sql = &quot;INSERT INTO account(name,money) VALUES (?,?)&quot;;

    // 3.执行sql
    int i = jdbcTemplate.update(sql, &quot;testJdbcTemplate&quot;, 1000d);
&#125;
</code></pre>
<p>  }<br>4.3 Spring整合JdbcTemplate<br>编写AccountDao</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public interface AccountDao {</p>
<pre><code>List&lt;Account&gt; findAll();


void save(Account account);
void update(Account account);
void delete(Integer id);
Account findById(Integer id);
</code></pre>
<p>}<br>编写AccountDaoImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41</p>
<p>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<pre><code>@Autowired
private JdbcTemplate jdbcTemplate;


@Override
public void save(Account account) &#123;
    String sql = &quot;INSERT INTO account (name, money) VALUES(?,?)&quot;;
    jdbcTemplate.update(sql,account.getName(),account.getMoney());

&#125;

@Override
public void update(Account account) &#123;
    String sql = &quot;UPDATE account SET name = ?,money = ? WHERE id=?&quot;;
    jdbcTemplate.update(sql, account.getName(),account.getMoney(),account.getId());

&#125;

@Override
public void delete(Integer id) &#123;
    String sql = &quot;DELETE FROM account WHERE id = ?&quot;;
    jdbcTemplate.update(sql, id);

&#125;

@Override
public Account findById(Integer id) &#123;
    String sql = &quot;SELECT * FROM account WHERE id = ?&quot;;
    return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), id);
&#125;

@Override
public List&lt;Account&gt; findAll() &#123;
    String sql = &quot;SELECT * FROM account&quot;;
    return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class));
&#125;
</code></pre>
<p>}<br>编写AccountService</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>public interface AccountService {</p>
<pre><code>List&lt;Account&gt; findAll();

void save(Account account);

void update(Account account);

void delete(Integer id);

Account findById(Integer id);
</code></pre>
<p>}<br>编写AccountServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>@Autowired
private AccountDao accountDao;

@Override
public void save(Account account) &#123;
    accountDao.save(account);
&#125;

@Override
public void update(Account account) &#123;
    accountDao.update(account);
&#125;

@Override
public void delete(Integer id) &#123;
    accountDao.delete(id);
&#125;

@Override
public Account findById(Integer id) &#123;
    return accountDao.findById(id);
&#125;

@Override
public List&lt;Account&gt; findAll() &#123;
    return accountDao.findAll();
&#125;
</code></pre>
<p>}<br>编写Spring的配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="
       http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"></beans></p>
<pre><code>&lt;!--加载第三方配置文件--&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
&lt;!--开启注解组件扫描--&gt;
&lt;context:component-scan base-package=&quot;com.test&quot;/&gt;
&lt;!--druid交给ioc--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
&lt;/bean&gt;

&lt;!--jdbcTemplate交给ioc--&gt;
&lt;bean  id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class JdbcTemplateTest {</p>
<pre><code>@Autowired
private AccountService accountService;


// 新增
@Test
public void testJdbcTemplate() throws Exception&#123;

    // 1.创建JdbcTemplate核心对象
    JdbcTemplate jdbcTemplate = new JdbcTemplate(JdbcUtils.getDataSource());

    // 2.编写sql
    String sql = &quot;INSERT INTO account(name,money) VALUES (?,?)&quot;;

    // 3.执行sql
    int i = jdbcTemplate.update(sql, &quot;testJdbcTemplate&quot;, 1000d);
&#125;

@Test
public void testJdbcFindByID() throws Exception&#123;
    JdbcTemplate jdbcTemplate = new JdbcTemplate(JdbcUtils.getDataSource());

    String sql = &quot;SELECT * FROM account WHERE id = ?&quot;;

    Account account = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), 5);

    System.out.println(account);
&#125;

@Test
public void testJdbcFindAll() throws Exception&#123;

    List&lt;Account&gt; list = accountService.findAll();

    for (Account account : list) &#123;
        System.out.println(account);
    &#125;
&#125;

@Test
public void testJdbcFindById() throws Exception&#123;

    Account byId = accountService.findById(4);
    System.out.println(byId);
&#125;

@Test
public void testJdbcDelete() throws Exception&#123;
    accountService.delete(4);
&#125;

@Test
public void testJdbcUpdate() throws Exception&#123;
    Account account = new Account();
    account.setId(5);
    account.setName(&quot;K&quot;);
    account.setMoney(100d);
    accountService.update(account);
&#125;

@Test
public void testJdbcCreate() throws Exception&#123;
    Account account = new Account();
    account.setName(&quot;K&quot;);
    account.setMoney(100d);
    accountService.save(account);
&#125;
</code></pre>
<p>}<br>4.4 实现转账案例<br>Spring当时在设计时，就要求事务交给spring控制,因此无法操作自定义的事务管理器</p>
<p>AccountDao</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>public interface AccountDao {</p>
<pre><code>List&lt;Account&gt; findAll();


void outUser(String outUser,Double money);
void inUser(String inUser,Double money);
</code></pre>
<p>}<br>AccountDaoImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<p>  @Autowired<br>  private JdbcTemplate jdbcTemplate;</p>
<p>  @Override<br>  public void outUser(String outUser, Double money) {<br>    String sql &#x3D; “update account set money &#x3D; money - ? where name &#x3D; ?”;<br>    jdbcTemplate.update(sql,money,outUser);<br>  }</p>
<p>  @Override<br>  public void inUser(String inUser, Double money) {<br>    String sql &#x3D; “update account set money &#x3D; money + ? where name &#x3D; ?”;<br>    jdbcTemplate.update(sql,money,inUser);</p>
<p>  }<br>  @Override<br>  public List<Account> findAll() {<br>    String sql &#x3D; “SELECT * FROM account”;<br>    return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class));<br>  }<br>}<br>AccountService</Account></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>public interface AccountService {</p>
<pre><code>void transfer(String outUser,String inUser,Double money);

List&lt;Account&gt; findAll();
</code></pre>
<p>}<br>AccountServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<p>  @Autowired<br>  private AccountDao accountDao;</p>
<p>  @Override<br>  public void transfer(String outUser, String inUser, Double money) {<br>    accountDao.outUser(outUser,money);<br>    accountDao.inUser(inUser,money);<br>  }<br>  @Override<br>  public List<Account> findAll() {<br>    return accountDao.findAll();<br>  }<br>}<br>测试</Account></p>
<p>1<br>2<br>3<br>4<br>@Test<br>public void testJdbcTransfer() throws Exception{<br>    accountService.transfer(“tom”,”jerry”,100d);<br>}<br>五.Spring的事务<br>Spring的事务控制可以分为编程式事务控制和声明式事务控制。</p>
<p>编程式事务</p>
<p>就是将业务代码和事务代码放在一起书写,它的耦合性太高,开发中不使用</p>
<p>声明式事务</p>
<p>将事务代码（spring内置）和业务代码隔离开发, 然后通过一段配置让他们组装运行, 最后达到事务控制的目的.</p>
<p>声明式事务就是通过AOP原理实现的.</p>
<p>5.1 编程式事务<br>5.1.1 Platform TransactionManager<br>spring事务管理器的顶级接口，里面提供了我们常用的操作事务的方法(需要坐标 spring-orm)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>    <!--spring的orm--><br>    <dependency><br>        <groupId>org.springframework</groupId><br>        <artifactId>spring-orm</artifactId><br>        <version>5.1.5.RELEASE</version><br>    </dependency><br></p>
<p>事务	功能<br>TransactionStatus getTransaction(TransactionDefinition definition);	获取事务的状态信息<br>void commit(TransactionStatus status)；	提交事务<br>void rollback(TransactionStatus status)；	回滚事务<br>5.1.2 TransactionDefinition<br>Spring事务定义参数的接口，例如定义：事务隔离级别、事务传播行为等</p>
<p>事务隔离级别</p>
<p>事务的隔离级别	<br>ISOLATION_DEFAULT	使用数据库默认级别<br>MySQL可重复读;Oracle读已提交<br>ISOLATION_READ_UNCOMMITTED	读未提交<br>ISOLATION_READ_COMMITTED	读已提交<br>ISOLATION_REPEATABLE_READ	可重复读<br>ISOLATION_SERIALIZABLE	串行化<br>事务传播行为</p>
<p>事务传播行为指的就是当一个业务方法 被 另一个业务方法调用时，应该如何进行事务控制。</p>
<p>行为	说明<br>REQUIRED（默认传播行为）	如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。<br>如果单独调用方法B时，没有事务，spring就给当前方法创建一个新事物<br>如果方法A中已经存在了事务，调用方法B时，方法B加方法A的事务中<br>SUPPORTS	支持当前事务，如果当前没有事务，就以非事务方式执行<br>如果单独调用方法B时没有事务，咱们就以非事务方法运行<br>如果方法A中已经存在了事务，调用方法B时，方法B加方法A的事务中<br>MANDATORY	使用当前的事务，如果当前没有事务，就抛出异常<br>REQUERS_NEW	新建事务，如果当前在事务中，把当前事务挂起<br>NOT_SUPPORTED	以非事务方式执行操作，如果当前存在事务，就把当前事务挂起<br>NEVER	以非事务方式运行，如果当前存在事务，抛出异常<br>NESTED	如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</p>
<p>是否只读</p>
<p>是否只读	<br>read-only	只读事务(增 删 改不能使用,只能查询使用)<br>超时时间</p>
<p>超时时间	<br>timeout	默认值是-1，没有超时限制。如果有，以秒为单位进行设置<br>5.1.3 TransactionStatus<br>获取spring当前事务运行的状态</p>
<p>5.1.4 知识小结<br>Spring中的事务控制主要就是通过这三个API实现的</p>
<p>API	<br>PlatformTransactionManager	负责事务的管理，它是个接口，其子类负责具体工作<br>TransactionDefinition	定义了事务的一些相关参数<br>TransactionStatus	代表事务运行的一个实时状态<br>可以简单的理解三者的关系:事务管理器通过读取事务定义参数进行事务管理，然后会产生一系列的事务状态。</p>
<p>5.2 使用编程式事务<br>5.2.1 配置事务管理器<br>1<br>2<br>3<br>4</p>
<!--事务管理器-->
<p><bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource"><br></property></bean><br>5.2.2 修改service层代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>@Service<br>public class xxxServiceImpl implements xxxService{<br>  @Autowired<br>  private PlatformTransactionManager transactionManager;<br>  public void method() {<br>    DefaultTransactionDefinition def &#x3D; new DefaultTransactionDefinition();<br>    &#x2F;&#x2F; 设置是否只读，为false才支持事务<br>    def.setReadOnly(false);<br>    &#x2F;&#x2F; 设置隔离级别<br>    def.setIsolationLevel(TransactionDefinition.ISOLATION_DEFAULT);<br>    &#x2F;&#x2F; 设置事务的传播行为<br>    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);<br>    &#x2F;&#x2F; 对事务管理器进行配置<br>    TransactionStatus status &#x3D; transactionManager.getTransaction(def);<br>    try {<br>      &#x2F;&#x2F; 业务操作<br>      &#x2F;&#x2F; 提交事务<br>      transactionManager.commit(status);<br>    } catch (Exception e) {<br>      e.printStackTrace(); &#x2F;&#x2F; 回滚事务<br>      transactionManager.rollback(status); }<br>  }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>// 依赖dao
@Autowired
private AccountDao accountDao;

@Override
public List&lt;Account&gt; findAll() &#123;
    return accountDao.findAll();
&#125;


@Autowired
private PlatformTransactionManager transactionManager;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    // 设置是否只读，为false才支持事务
    def.setReadOnly(false);
    // 设置隔离级别
    def.setIsolationLevel(TransactionDefinition.ISOLATION_DEFAULT);
    // 设置事务的传播行为
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    // 对事务管理器进行配置
    TransactionStatus status = transactionManager.getTransaction(def);
    try &#123;
        // 核心业务
        accountDao.outUser(outUser, money);
        // 模拟异常..
        int i = 1/0;
        accountDao.inUser(inUser, money);

        // 提交事务
        transactionManager.commit(status);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
        // 回滚事务
        transactionManager.rollback(status);
    &#125;
&#125;
</code></pre>
<p>}<br>总结</p>
<h1 id="spring04"><a href="#spring04" class="headerlink" title="spring04"></a>spring04</h1><h2 id="一-基于XML的AOP开发"><a href="#一-基于XML的AOP开发" class="headerlink" title="一 基于XML的AOP开发"></a>一 基于XML的AOP开发</h2><h3 id="aop织入的配置"><a href="#aop织入的配置" class="headerlink" title="aop织入的配置"></a>aop织入的配置</h3><ul>
<li>aop:config</li>
</ul>
<p>​ &lt;aop:aspect ref&#x3D;“通知类”&gt;</p>
<p>​ &lt;aop:before method&#x3D;“通知方法名称” pointcut&#x3D;“切点表达式”&gt;</p>
<p>​</p>
<h3 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h3><ul>
<li>&lt;aop:pointcut id&#x3D;”myPointcut” expression&#x3D;”execution(* com.test.service…(..))”&gt;</li>
</ul>
<h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><ul>
<li><p>aop:before</p>
</li>
<li><p>aop:after-returning</p>
</li>
<li><p>aop:after-throwing</p>
</li>
<li><p>aop:after</p>
</li>
<li><p>aop:around</p>
</li>
</ul>
<h2 id="二-基于注解的AOP开发"><a href="#二-基于注解的AOP开发" class="headerlink" title="二 基于注解的AOP开发"></a>二 基于注解的AOP开发</h2><h3 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h3><ul>
<li>@Aspect</li>
</ul>
<p>public class MyAdvice {}</p>
<h3 id="切点表达式-1"><a href="#切点表达式-1" class="headerlink" title="切点表达式"></a>切点表达式</h3><ul>
<li>@Pointcut(“execution(void com.test.service…(..))”)</li>
</ul>
<p>public void myPoint(){}</p>
<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><ul>
<li><p>@Before</p>
</li>
<li><p>@AfterReturning</p>
</li>
<li><p>@AfterThrowing</p>
</li>
<li><p>@After</p>
</li>
<li><p>@Around</p>
</li>
</ul>
<h3 id="AOP自动代理"><a href="#AOP自动代理" class="headerlink" title="AOP自动代理"></a>AOP自动代理</h3><ul>
<li><p>aop:aspectj-autoproxy&#x2F;</p>
</li>
<li><p>@EnableAspectJAutoProx</p>
</li>
</ul>
<h2 id="三-AOP优化转账案例"><a href="#三-AOP优化转账案例" class="headerlink" title="三 AOP优化转账案例"></a>三 AOP优化转账案例</h2><h3 id="xml配置实现"><a href="#xml配置实现" class="headerlink" title="xml配置实现"></a>xml配置实现</h3><h3 id="注解配置实现"><a href="#注解配置实现" class="headerlink" title="注解配置实现"></a>注解配置实现</h3><h2 id="四-Spring的JdbcTemplate"><a href="#四-Spring的JdbcTemplate" class="headerlink" title="四 Spring的JdbcTemplate"></a>四 Spring的JdbcTemplate</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>JdbcTemplate是Spring的一款用于简化Dao代码的工具，它底层封装了JDBC技术</p>
</li>
<li><p>核心对象</p>
</li>
</ul>
<p>​ - JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(DataSource dataSource);</p>
<ul>
<li>核心方法</li>
</ul>
<p>​ - DML</p>
<p>​ - int update();</p>
<p>​ - DQL</p>
<p>​ - List query();</p>
<p>​ - T queryForObject();</p>
<p>​ - 查询ORM映射处理实现类</p>
<p>​ - BeanPropertyRowMapper&lt;&gt;(Class 字节码对象)</p>
<h3 id="Spring整合JdbcTemplate"><a href="#Spring整合JdbcTemplate" class="headerlink" title="Spring整合JdbcTemplate"></a>Spring整合JdbcTemplate</h3><h3 id="实现转账案例"><a href="#实现转账案例" class="headerlink" title="实现转账案例"></a>实现转账案例</h3><ul>
<li>我们发现了无法使用自己定义的事务管理器（LOW）、需要引出spring内置事务管理器</li>
</ul>
<h2 id="五-Spring的事务"><a href="#五-Spring的事务" class="headerlink" title="五 Spring的事务"></a>五 Spring的事务</h2><h3 id="编程式事务控制（了解）"><a href="#编程式事务控制（了解）" class="headerlink" title="编程式事务控制（了解）"></a>编程式事务控制（了解）</h3><ul>
<li><p>开发者直接把事务的代码和业务代码耦合到一起，在实际开发中不用。</p>
</li>
<li><p>相关对象</p>
</li>
</ul>
<p>​ - PlatformTransactionManager</p>
<p>​ - DataSourceTransactionManager</p>
<p>​ - TransactionDefinition</p>
<p>​ - 隔离级别</p>
<p>​ - 传播行为</p>
<p>​ - REQUIRED</p>
<p>​ - SUPPORTS</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/31/Spring-Transaction-CGlib-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Spring-Transaction-CGlib-AOP/" class="post-title-link" itemprop="url">Spring Transaction,CGlib & AOP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 01:42:58" itemprop="dateCreated datePublished" datetime="2020-05-31T01:42:58+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.转账案例基础<br>需求</p>
<p>使用Spring框架整合DbUtils技术，实现用户转账功能</p>
<p>1.1 转账基础功能<br>Java环境与数据库准备</p>
<p>IDEA new moudle&#x3D;&#x3D;&gt;MAVEN&#x3D;&#x3D;&gt;创建moudle&#x3D;&#x3D;&gt;导入包，复制applicationContext.xml和jdbc.properties</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39</p>
<!--依赖管理-->
<dependencies>
    <!--mysql-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <!--druid-->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.15</version>
    </dependency>
    <!--dbUtils-->
    <dependency>
        <groupId>commons-dbutils</groupId>
        <artifactId>commons-dbutils</artifactId>
        <version>1.6</version>
    </dependency>
    <!--spring核心-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
    <!--junit-->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <!--spring整合junit-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
</dependencies>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
<!-- 省略约束 -->

  <!-- 开启注解组件扫描 -->
<pre><code>  &lt;context:component-scan base-package=&quot;com.test&quot;/&gt;

  &lt;!-- 加载第三方配置文件 --&gt;
  &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;

  &lt;!--druid连接交给ioc容器,第三方类目前仅能用bean标签--&gt;
  &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
      &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
      &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
      &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
  &lt;/bean&gt;

  &lt;!--queryRunner交给ioc容器,第三方类目前仅能用bean标签--&gt;
  &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt;
      &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;/&gt;
  &lt;/bean&gt;
</code></pre>
  
编写AccountDao

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public interface AccountDao {</p>
<pre><code>//转出
void outUser(String outUser, Double money);

//转入
void inUser(String inUser, Double money);
</code></pre>
<p>}<br>AccountDaoImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<pre><code>@Autowired
private QueryRunner queryRunner;

@Override
public void outUser(String outUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money-? WHERE name = ?&quot;;
        queryRunner.update(sql, money, outUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;

&#125;

@Override
public void inUser(String inUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money+? WHERE name = ?&quot;;
        queryRunner.update(sql, money, inUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>}<br>编写AccountService</p>
<p>1<br>2<br>3<br>4<br>5<br>public interface AccountService {<br>    &#x2F;&#x2F;转账<br>    void transfer(String outUser,String inUser,Double money);<br>}</p>
<p>AccountServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>@Autowired
private AccountDao accountDao;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;

    accountDao.outUser(outUser,money);
    accountDao.inUser(inUser,money);
&#125;
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration({“classpath:applicationContext.xml”})<br>public class AccountTest {</p>
<pre><code>@Autowired
private AccountService accountService;

@Test
public void testTransfer() throws Exception&#123;
    accountService.transfer(&quot;tom&quot;,&quot;jerry&quot;,100d);
&#125;
</code></pre>
<p>}<br>目前问题</p>
<p>若服务器出现宕机等事故，事务无回滚，导致只执行一半的问题</p>
<p>1.2 事务控制<br>解决方案</p>
<p>将service方法的多个dao层代码，看做一个事务，要么都成功，要么都失败</p>
<p>Version_1:手动控制事务，通过一个connection来操作核心业务</p>
<p>修改AccountServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>// 依赖dataSource
@Autowired
private AccountDao accountDao;

//Version_1
@Autowired
private DataSource dataSource;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;
    Connection connection = null;

    try &#123;
        // 获取conn手动控制事务
        connection = dataSource.getConnection();
        connection.setAutoCommit(false);
        // 业务代码-------- start
        // 转出
        accountDao.outUser(connection, outUser, money);

        // 转入
        accountDao.inUser(connection, inUser, money);
        // 提交事务
        connection.commit();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
        try &#123;
            // 回滚事务
            connection.rollback();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125; finally &#123;
        try &#123;
            // 再改为自动提交
            connection.setAutoCommit(true);
            // 释放资源
            connection.close();
        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>  }<br>修改AccountDao</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<pre><code>@Autowired
private QueryRunner queryRunner;

@Autowired
private ConnectionUtils connectionUtils;

@Override
public void outUser(String outUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money-? WHERE name = ?&quot;;
        Connection threadConnection = connectionUtils.getThreadConnection();
        queryRunner.update(threadConnection,sql, money, outUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;

&#125;

@Override
public void inUser(String inUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money+? WHERE name = ?&quot;;
        Connection threadConnection = connectionUtils.getThreadConnection();
        queryRunner.update(threadConnection,sql, money, inUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

@Override
public List&lt;Account&gt; findAll() &#123;

    List&lt;Account&gt; list = null;

    try &#123;
        String sql = &quot;SELECT * FROM account&quot;;
        list=queryRunner.query(sql,new BeanListHandler&lt;&gt;(Account.class));
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;

    return list;
&#125;

@Override
public void outUser(Connection connection, String outUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money-? WHERE name = ?&quot;;
        queryRunner.update(connection,sql, money, outUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

@Override
public void inUser(Connection connection, String inUser, Double money) &#123;
    try &#123;
        String sql = &quot;UPDATE account SET money=money+? WHERE name = ?&quot;;
        queryRunner.update(connection,sql, money, inUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration({“classpath:applicationContext.xml”})<br>public class AccountTest {</p>
<p>  @Test<br>  public void testTransferVersionOne() throws Exception{<br>    accountService.transfer(“tom”,”jerry”,100d);<br>  }<br>}<br>问题</p>
<p>不应该将service的conn对象传递到dao层，这种方式，就产生了dao层与service的耦合性问题</p>
<p>1.3 ThreadLocal<br>解决方案</p>
<p>ThreadLocal是一个线程的局部变量,此处用作线程K-V 线程map集合的存取</p>
<p>编写ConnectionUtils</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&#x2F;*<br>ThreadLocal操作的工具类</p>
<ol>
<li>从当前线程内绑定并获取conn对象</li>
<li>移除当前线程的conn对象<br>*&#x2F;</li>
</ol>
<p>&#x2F;&#x2F; 交给ioc容器<br>@Component<br>public class ConnectionUtils {<br>    @Autowired<br>    private DataSource dataSource;</p>
<pre><code>// 线程隔离
private static final ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();

// 1.从当前线程内绑定并获取conn对象
public Connection getThreadConnection()&#123;
    // 第一次执行get，肯定获取不到
    Connection connection = tl.get();
    if(connection==null)&#123;

        try &#123;
            connection = dataSource.getConnection();
            tl.set(connection);
        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;
    &#125;
    return connection;
&#125;
// 2.移除当前线程的conn对象
public void removeThreadConnection()&#123;
    tl.remove();
&#125;
</code></pre>
<p>}<br>修改AccountServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<p>  &#x2F;&#x2F; 依赖dataSource<br>  @Autowired<br>  private AccountDao accountDao;</p>
<p>  &#x2F;&#x2F;Version_2</p>
<p>  @Autowired<br>  private ConnectionUtils connectionUtils;</p>
<p>  @Override<br>  public void transfer(String outUser, String inUser, Double money) {<br>    Connection connection&#x3D;null;</p>
<pre><code>try &#123;
  // 获取conn手动控制事务
  connection = connectionUtils.getThreadConnection();
  connection.setAutoCommit(false);
  // 业务代码-------- start
  // 转出
  accountDao.outUser(outUser,money);
  // 转入
  accountDao.inUser(inUser,money);
  // 业务代码-------- end
  // 提交事务
  connection.commit();
&#125; catch (SQLException throwables) &#123;
  throwables.printStackTrace();
  try &#123;
    // 回滚事务
    connection.rollback();
  &#125; catch (SQLException e) &#123;
    e.printStackTrace();
  &#125;
&#125;finally &#123;
  try &#123;
    // 再改为自动提交
    connection.setAutoCommit(true);
    // 释放资源
    connection.close();
  &#125; catch (SQLException throwables) &#123;
    throwables.printStackTrace();
  &#125;
&#125;
</code></pre>
<p>  }<br>}<br>修改AccountDao</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<pre><code>@Autowired
private QueryRunner queryRunner;

@Autowired
private ConnectionUtils connectionUtils;

@Override
public void outUser(String outUser, Double money) &#123;

    try &#123;
        // 1.编写sql
        String sql = &quot;UPDATE account SET money=money-? WHERE name = ?&quot;;
        // 获取当前线程内的 conn
        Connection threadConnection = connectionUtils.getThreadConnection();
        // 2.执行sql
        queryRunner.update(threadConnection,sql, money, outUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;

&#125;

@Override
public void inUser(String inUser, Double money) &#123;

    try &#123;
        String sql = &quot;UPDATE account SET money=money+? WHERE name = ?&quot;;
        Connection threadConnection = connectionUtils.getThreadConnection();
        queryRunner.update(threadConnection,sql, money, inUser);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>  }<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration({“classpath:applicationContext.xml”})<br>public class AccountTest {</p>
<p>  @Autowired<br>  private AccountService accountService;</p>
<p>  @Test<br>  public void testTransferVersionTwo() throws Exception{<br>    accountService.transfer(“tom”,”jerry”,100d);<br>  }<br>}<br>翻看源码</p>
<p>向当前线程map集合存值</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public void set(T value) {<br>    Thread t &#x3D; Thread.currentThread();<br>    ThreadLocalMap map &#x3D; getMap(t);<br>    if (map !&#x3D; null)<br>        map.set(this, value);<br>    else<br>        createMap(t, value);<br>}<br>当前线程map取值</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public T get() {<br>    Thread t &#x3D; Thread.currentThread();<br>    ThreadLocalMap map &#x3D; getMap(t);<br>    if (map !&#x3D; null) {<br>        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);<br>        if (e !&#x3D; null) {<br>            @SuppressWarnings(“unchecked”)<br>            T result &#x3D; (T)e.value;<br>            return result;<br>        }<br>    }<br>    return setInitialValue();<br>}<br>从当前线程map移出值</p>
<p>1<br>2<br>3<br>4<br>5<br>public void remove() {<br>  ThreadLocalMap m &#x3D; getMap(Thread.currentThread());<br>  if (m !&#x3D; null)<br>    m.remove(this);<br>}<br>问题</p>
<p>在企业开发时，我们基础每一个业务层方法都需要进行事务的控制，这部分代码属于公共业务且重复 的，出现了大量的代码冗余</p>
<p>1.4 事务管理器<br>解决方案</p>
<p>这时候我们可以把这部分代码抽取到工具类(事务管理器)</p>
<p>编写TransactionManager</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>@Component<br>public class TransactionManager {</p>
<pre><code>@Autowired
private ConnectionUtils connectionUtils;

// 1.开启事务
public void beginTransaction()&#123;
    try &#123;
        connectionUtils.getThreadConnection().setAutoCommit(false);
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

// 2.提交事务
public void commit()&#123;
    try &#123;
        connectionUtils.getThreadConnection().commit();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

// 3.回滚事务
public void rollback()&#123;
    try &#123;
        connectionUtils.getThreadConnection().rollback();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;

// 4.释放资源
public void release()&#123;

    try &#123;
        // 恢复自动提交
        connectionUtils.getThreadConnection().setAutoCommit(true);
        // 归还到连接池
        connectionUtils.getThreadConnection().close();
        // 从当前线程删除conn对象
        connectionUtils.removeThreadConnection();
    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>}<br>修改AccountService</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>//Version_3

@Autowired
private TransactionManager transactionManager;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;

    try &#123;
        // 开启事务
        transactionManager.beginTransaction();
        // 业务代码-------- start
        // 转出
        accountDao.outUser(outUser,money);
        // 转入
        accountDao.inUser(inUser,money);
        // 业务代码-------- end
        // 提交事务
        transactionManager.commit();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
        // 回滚事务
        transactionManager.rollback();
    &#125; finally &#123;
        // 释放资源
        transactionManager.release();
    &#125;
&#125;
</code></pre>
<p>   }<br>测试</p>
<p>1<br>2<br>3<br>4<br>@Test<br>public void testTransferVersionThree() throws Exception{<br>    accountService.transfer(“tom”,”jerry”,100d);<br>}<br>问题</p>
<p>所有事务都不可避免使用事务管理器控制<br>事务管理器属于通用业务，与核心代码产生耦合性<br>二.转账案例进阶<br>可以将业务代码和事务代码进行拆分，通过动态代理的方式，对业务方法进行事务的增强。这样就 不会对业务层产生影响，解决了耦合性的问题</p>
<p>常用的动态代理技术</p>
<p>JDK 代理 : 基于接口的动态代理技术</p>
<p>CGLIB代理:基于父类的动态代理技术</p>
<p>修改AccountService代码</p>
<p>企业开发时业务层，只有核心业务代码，不会出现事务相关代码</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>// 依赖dataSource
@Autowired
private AccountDao accountDao;

@Override
public void transfer(String outUser, String inUser, Double money) &#123;
    accountDao.outUser(outUser,money);
    accountDao.inUser(inUser,money);
&#125;
</code></pre>
<p>}<br>2.1 JDK动态代理<br>思想</p>
<p>JDKProxyFactory工厂，生产多个代理对象，进行事务增强</p>
<p>目标对象——目标接口——基于接口，创建代理对象(method.invoke调用目标对象原有功能进行增强)</p>
<p>目标对象</p>
<p>1<br>public class AccountServiceImpl implements AccountService<br>编写JdkProxyFactory</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>&#x2F;*<br>基于jdk，实现对目标对象，进行事务的增强<br>*&#x2F;<br>@Component<br>public class JdkProxyFactory {</p>
<pre><code>@Autowired
private TransactionManager transactionManager;

public Object createJDKProxyTx(Object target) &#123;
    Object proxy = null;


    // 使用sun公司提供的jdk代理工具类
</code></pre>
<p>&#x2F;*<br>        1.目标对象类加器<br>        2.目标对象接口数组<br>        3.实现增强的业务逻辑(匿名内部类、lambda)<br>                *&#x2F;</p>
<pre><code>    //目标对象类 加载器
    ClassLoader classLoader = target.getClass().getClassLoader();
    // 目标对象实现的接口数组
    Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
    proxy = Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() &#123;

        /*
</code></pre>
<p>invoke 方法是代理对象的入口<br>proxy:jdk工具类生产的代理对象 method:当前用户执行的某个具体方法<br>args:当前用户执行的某个具体方法传递的实际参数列表<br>*&#x2F;<br>            @Override<br>            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>                Object result &#x3D; null;</p>
<pre><code>            try &#123;
                // 开启事务
                transactionManager.beginTransaction();
                // 执行目标对象原有的功能
                result = method.invoke(target, args);

                // 提交事务
                transactionManager.commit();
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
                // 回滚事务
                transactionManager.rollback();
            &#125; finally &#123;
                // 释放资源
                transactionManager.release();
            &#125;
            return result;
        &#125;
    &#125;);
    // 返回增强后的代理对象
    return proxy;
&#125;
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration({“classpath:applicationContext.xml”})<br>public class AccountTest {</p>
<pre><code>// 目标对象
@Autowired
private AccountService accountService;

// jdk生产代理对象工厂
@Autowired
private JdkProxyFactory jdkProxyFactory;

@Test
public void testJDKProxy() throws Exception&#123;
    // 目标对象没有事务增强
    // accountService.transfer(&quot;tom&quot;, &quot;jerry&quot;, 100d);
    // 使用jdk对目标对象事务增强
    AccountService jdkProxy = (AccountService) jdkProxyFactory.createJDKProxyTx(accountService);
    jdkProxy.transfer(&quot;tom&quot;,&quot;jerry&quot;,100d);
&#125;
</code></pre>
<p>  }<br>2.2 CGLIB动态代理<br>问题</p>
<p>进入公司，可能有些代码没有接口，但又需要动态代理进行增强，这时候sun公司提供jdk工具就无法实 现了</p>
<p>解决方案</p>
<p>基于CGLIB技术，对普通java类型实现代理增强(第三方，需导包)</p>
<p>代理对象获取父对象所有方法(method.invoke)，用户访问代理增强对象即可</p>
<p>目标对象</p>
<p>1<br>public class AccountServiceImpl implements AccountService<br>编写CglibProxyFactory</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>&#x2F;*<br>基于cglib，实现对目标对象，进行事务的增强<br>*&#x2F;<br>@Component<br>public class CglibProxyFactory {</p>
<pre><code>@Autowired
private TransactionManager transactionManager;

public Object createCglibProxyTx(Object target) &#123;
    Object proxy = null;


    // 使用cglib提供的工具类
    /*
    1. 目标对象class类
    2. 实现增强的业务逻辑(匿名内部类、lambda) */

    proxy = Enhancer.create(target.getClass(), new MethodInterceptor() &#123;
        /*
        intercept 代理对象方法入口
        1.o cglib生产出来的代理对象
        2.method 执行代理对象(子)，被拦截的方法
        3.objects 执行代理对象，被拦截的方法的参数列表
        4.methodProxy 目标对象(父)，被拦截的方法，功能与method一样的
        */
        @Override
        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
            Object result = null;

            try &#123;
                // 开启事务
                transactionManager.beginTransaction();
                // 调用目标对象原有的功能
                result=method.invoke(target,objects);
                // 提交事务
                transactionManager.commit();
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
                // 回滚事务
                transactionManager.rollback();
            &#125; finally &#123;
                // 释放资源
                transactionManager.release();
            &#125;

            return result;
        &#125;
    &#125;);
    // 返回增强后的代理对象
    return proxy;
&#125;
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration({“classpath:applicationContext.xml”})<br>public class AccountTest {</p>
<p>  &#x2F;&#x2F; 目标对象<br>  @Autowired<br>  private AccountService accountService;</p>
<p>  @Autowired<br>  private CglibProxyFactory cglibProxyFactory;</p>
<p>  @Test<br>  public void testCglibProxy() throws Exception{<br>    &#x2F;&#x2F; 使用cglib对目标对象事务增强<br>    AccountService jdkProxy &#x3D; (AccountService) cglibProxyFactory.createCglibProxyTx(accountService);<br>    jdkProxy.transfer(“tom”,”jerry”,100d);<br>  }<br>2.3 总结<br>2.3.1 jdk和cglib两种代理方式的选择?<br>优先使用jdk，性能高于cglib</p>
<p>如果目标对象有接口，一定使用jdk创建代理对象</p>
<p>如果目标对象没有接口，没办法只能使用cglib创建代理对象</p>
<p>2.3.2 当核心业务(转账)和通用业务(事务、日志)同时出现时?<br>开发阶段</p>
<p>拆分(核心业务在service，事务管理在单独工具类中):解耦</p>
<p>运行阶段</p>
<p>通过动态代理技术，进行组合:功能增强</p>
<p>三.SpringAOP简介<br>3.1 概述<br>AOP( 面向切面编程 )是一种思想, 它的目的就是在不修改源代码的基础上,对原有功能进行增强。 Spring AOP是对AOP思想的一种实现, Spring底层同时支持jdk和cglib动态代理。</p>
<p>优势<br>在程序运行期间，在不修改源码的情况下对方法进行功能增强<br>逻辑清晰，开发核心业务的时候，不必关注增强业务的代码<br>减少重复代码，提高开发效率，便于后期维护<br>Spring会根据被代理的类是否有接口自动选择代理方式<br>如果有接口,就采用jdk动态代理<br>没有接口就采用cglib的方式<br>3.2 相关术语<br>术语	解释	目标对象<br>Target	目标对象	service层的核心业务<br>JoinPoint	连接点	目标对象中的所有方法<br>Pointcut	切点	目标对象需要增强的方法<br>Advice	通知(增强)	实现增强的功能的<br>Weaving	织入	将通知和切点进行织入(动作)<br>Aspect	切面(spring术语)	通知 + 切点 &#x3D; 切面<br>Proxy	代理对象(底层实现)	通知 + 切点 &#x3D; 代理对象<br>3.3 明确注意事项<br>开发阶段</p>
<p>编写核心业务代码(开发主线):要求熟悉业务需求。<br>把公用代码抽取出来，制作成通知，要求熟悉AOP思想。<br>在配置文件中，声明切入点与通知间的关系，即切面，要求熟悉AOP思想。<br>运行阶段(Spring框架完成的)</p>
<p>Spring读取配置文件中的切面信息，根据切面中的描述，将增强功能增加在目标对象的切点方法上，动 态创建代理对象，最后将经过代理之后对象放入ioc容器中</p>
<p>必知必会</p>
<p>能够编写目标对象(转账)<br>能够看懂通知类(事务管理器)<br>能够配置aop切面(切点+通知)，spring自动创建代理对象<br>四.基于XML的AOP开发<br>4.1 快速入门<br>需求</p>
<p>实现对转账方法的增强</p>
<p>创建maven的java模块，导入坐标</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27</p>
<!--依赖管理-->
<dependencies>
  <!--spring的核心-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.1.5.RELEASE</version>
  </dependency>
  <!--aspectj-->
  <dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.5</version>
  </dependency>
  <!--junit-->
  <dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
  </dependency>
  <!--spring整合junit-->
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>5.1.5.RELEASE</version>
  </dependency>
</dependencies>
编写目标类(AccountService)

<p>1<br>2<br>3<br>4<br>public interface AccountService {<br>    void transfer();<br>    void save();<br>}<br>AccountServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@Service<br>public class AccountServiceImpl implements AccountService {<br>    @Override<br>    public void transfer() {<br>        System.out.println(“Transfer”);<br>    }</p>
<pre><code>@Override
public void save() &#123;
    System.out.println(&quot;Save&quot;);
&#125;
</code></pre>
<p>}<br>编写通知类(增强)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>&#x2F;&#x2F;通知类(增强)<br>public class MyAdvice {</p>
<pre><code>public void before()&#123;
    System.out.println(&quot;Advance notice&quot;);
&#125;
</code></pre>
<p>}<br>配置spring的AOP(切点+通知)</p>
<p>如果spring要使用aop，需要再引入schema约束+命名空间</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:p="http://www.springframework.org/schema/p" xsi:schemalocation="
           http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p>
<bean id="accountService" class="com.test.service.impl.AccountServiceImpl">
    </bean>

<pre><code>&lt;bean id=&quot;myAdvice&quot; class=&quot;com.test.advice.MyAdvice&quot;&gt;&lt;/bean&gt;

&lt;aop:config&gt;
    &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
        &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.test.service.impl.AccountServiceImpl.transfer())&quot;&gt;&lt;/aop:before&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@RunWith(SpringRunner.class)<br>@ContextConfiguration(“classpath:applicationContext.xml”)<br>public class AccountTest {</p>
<pre><code>// 配置了aop之后，这就是代理对象
@Autowired
private AccountService accountService;

@Test
public void testAOP() throws Exception&#123;
    accountService.transfer();
&#125;
</code></pre>
<p>}<br>4.2 xml配置详解<br>4.2.1 切点表达式<br>表达式语法</p>
<p>1<br>execution([修饰符] 返回值类型 包名.类名.方法名(参数列表))<br>访问修饰符可以省略</p>
<p>返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意</p>
<p>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</p>
<p>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</p>
<p>4.2.2 通知类型<br>通知的配置语法</p>
<p>1<br>&lt;aop:通知类型 method&#x3D;”通知类中方法名” pointcut&#x3D;”切点表达式”&gt;&lt;&#x2F;aop:通知类型&gt;<br>四大通知</p>
<p>名称	标签	说明<br>前置通知	<a href="aop:before">aop:before</a>	在切入点方法之前执行<br>后置通知	<a href="aop:afterReturning">aop:afterReturning</a>	在切入点方法正常运行之后执行<br>异常通知	<a href="aop:afterThrowing">aop:afterThrowing</a>	在切点方法发生异常的时候执行<br>最终通知	<a href="aop:after">aop:after</a>	无论切入点方法执行时是否有异常，都会执行<br>环绕通知</p>
<p>名称	标签	说明<br>环绕通知	<a href="aop:around">aop:around</a>	可以灵活实现四大通知的所有效果<br>4.2.3 知识小结<br>aop织入的配置<br>1<br>2<br>3<br>4<br>5<br>6<br><a href="aop:config">aop:config</a></p>
<p>&lt;aop:aspect ref&#x3D;“通知类”&gt;<br>&lt;aop:before method&#x3D;“通知方法名称” pointcut&#x3D;“切点表达式”&gt;&lt;&#x2F;aop:before&gt;<br><br><br>通知的类型</p>
<p>前置通知、后置通知、异常通知、最终通知</p>
<p>环绕通知</p>
<p>切点表达式</p>
<p>1<br>execution([修饰符] 返回值类型 包名.类名.方法名(参数列表))<br>总结</p>
<h1 id="spring03"><a href="#spring03" class="headerlink" title="spring03"></a>spring03</h1><h2 id="一-转账案例基础"><a href="#一-转账案例基础" class="headerlink" title="一 转账案例基础"></a>一 转账案例基础</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><ul>
<li><p>转出</p>
</li>
<li><p>转入</p>
</li>
</ul>
<h3 id="传统事务控制"><a href="#传统事务控制" class="headerlink" title="传统事务控制"></a>传统事务控制</h3><ul>
<li>ConnectionUtils</li>
</ul>
<p>​ - ThreadLocal</p>
<p>​ - 线程局部变量，存储空间（Thread.ThreadLocalMap）</p>
<ul>
<li>TransactionManager</li>
</ul>
<p>​ - 事务管理器</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>核心业务 和 通用业务 产生了代码入侵</li>
</ul>
<h2 id="二-转账案例进阶"><a href="#二-转账案例进阶" class="headerlink" title="二 转账案例进阶"></a>二 转账案例进阶</h2><h3 id="代理事务控制"><a href="#代理事务控制" class="headerlink" title="代理事务控制"></a>代理事务控制</h3><ul>
<li><p>JDK</p>
</li>
<li><p>CGLIB</p>
</li>
</ul>
<h2 id="三-SpringAOP简介"><a href="#三-SpringAOP简介" class="headerlink" title="三 SpringAOP简介"></a>三 SpringAOP简介</h2><h3 id="AOP：面向切面编程"><a href="#AOP：面向切面编程" class="headerlink" title="AOP：面向切面编程"></a>AOP：面向切面编程</h3><ul>
<li>在不修改源代码情况下，实现对方法的增强</li>
</ul>
<h3 id="spring的AOP"><a href="#spring的AOP" class="headerlink" title="spring的AOP"></a>spring的AOP</h3><ul>
<li>简化了增强部分的配置，使开发者只关注业务本身</li>
</ul>
<h3 id="AOP底层实现"><a href="#AOP底层实现" class="headerlink" title="AOP底层实现"></a>AOP底层实现</h3><ul>
<li>动态代理</li>
</ul>
<h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><ul>
<li>Target</li>
</ul>
<p>​ - 目标对象</p>
<ul>
<li>Joinpoint</li>
</ul>
<p>​ - 连接点</p>
<ul>
<li>Pointcut</li>
</ul>
<p>​ - 切点</p>
<ul>
<li>Advice</li>
</ul>
<p>​ - 通知</p>
<ul>
<li>Weaving</li>
</ul>
<p>​ - 织入</p>
<ul>
<li>Aspect</li>
</ul>
<p>​ - 切面</p>
<ul>
<li>Proxy</li>
</ul>
<p>​ - 代理对象</p>
<h2 id="四-基于XML的AOP开发"><a href="#四-基于XML的AOP开发" class="headerlink" title="四 基于XML的AOP开发"></a>四 基于XML的AOP开发</h2><h3 id="aop织入的配置"><a href="#aop织入的配置" class="headerlink" title="aop织入的配置"></a>aop织入的配置</h3><ul>
<li>aop:config</li>
</ul>
<p>​ &lt;aop:aspect ref&#x3D;“通知类”&gt;</p>
<p>​ &lt;aop:before method&#x3D;“通知方法名称” pointcut&#x3D;“切点表达式”&gt;</p>
<p>​ </p>
<p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/29/Spring-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/29/Spring-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Spring 注解开发 & 单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-29 01:42:05" itemprop="dateCreated datePublished" datetime="2020-05-29T01:42:05+08:00">2020-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.DbUtils<br>1.1 DbUtils是什么<br>DbUtils是Apache的一款用于简化Dao层代码的工具类，它底层封装了JDBC技术。</p>
<p>核心对象</p>
<p>1<br>QueryRunner queryRunner &#x3D; new QueryRunner(DataSource dataSource);<br>核心方法</p>
<p>方法	<br>int update();	执行增、删、改语句<br>T query();<br>      ResultSetHandler<T>	执行查询语句<br>      这是一个接口，主要作用是将数据库返回的记录封装到实体对象<br>例</T></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>public class DbUtilsTest {<br>    @Test<br>    public void findAllTest() throws Exception {<br>        &#x2F;&#x2F; 创建DBUtils工具类，传入连接池<br>        QueryRunner queryRunner &#x3D; new QueryRunner(JdbcUtils.getDataSource());<br>        &#x2F;&#x2F; 编写sql<br>        String sql &#x3D; “select * from account”;<br>        &#x2F;&#x2F; 执行sql<br>        List<Account> list &#x3D; queryRunner.query(sql, new BeanListHandler<Account><br>                (Account.class));<br>        &#x2F;&#x2F; 打印结果<br>        for (Account account : list) {<br>            System.out.println(account);<br>        }<br>    }<br>}<br>1.2 DbUtils快速入门<br>准备数据库环境</Account></Account></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>CREATE DATABASE spring_db&#96; </p>
<p>USE <code>spring_db</code>;</p>
<p>DROP TABLE IF EXISTS <code>account</code>;</p>
<p>CREATE TABLE <code>account</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>name</code> varchar(32) DEFAULT NULL,<br>  <code>money</code> double DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8;</p>
<p>insert  into <code>account</code>(<code>id</code>,<code>name</code>,<code>money</code>) values (1,’tom’,1000),(2,’jerry’,1000);<br>创建maven的java模块</p>
<p>IDEA new moudle&#x3D;&#x3D;&gt;Maven&#x3D;&#x3D;&gt;moudle_name</p>
<p>导入相关jar包</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33</p>
<!--依赖管理-->
<dependencies>
    <!--mysql驱动-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <!--druid连接池-->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.15</version>
    </dependency>
    <!--dbUtils工具包-->
    <dependency>
        <groupId>commons-dbutils</groupId>
        <artifactId>commons-dbutils</artifactId>
        <version>1.6</version>
    </dependency>
    <!--junit单元测试-->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <!--spring核心-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
</dependencies>
JdbcUtils工具类(需组合jdbc.properties)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>public class JdbcUtils {</p>
<p>  private static DruidDataSource dc &#x3D;  new DruidDataSource();</p>
<p>  static {<br>    ResourceBundle bundle &#x3D; ResourceBundle.getBundle(“jdbc”);<br>    String driverClass &#x3D; bundle.getString(“jdbc.driver”);<br>    String jdbcUrl &#x3D; bundle.getString(“jdbc.url”);<br>    String username &#x3D; bundle.getString(“jdbc.username”);<br>    String password &#x3D; bundle.getString(“jdbc.password”);</p>
<pre><code>dc.setDriverClassName(driverClass);
dc.setUrl(jdbcUrl);
dc.setUsername(username);
dc.setPassword(password);
</code></pre>
<p>  }</p>
<p>  public static Connection getConnection() throws SQLException {<br>    return dc.getConnection();<br>  }</p>
<p>  public static DataSource getDataSource(){<br>    return dc;<br>  }<br>}<br>新增&#x2F;修改&#x2F;删除一条记录</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>public class DbUtilsTest {<br>  &#x2F;&#x2F; 新增记录<br>  @Test<br>  public void testCreate() throws Exception{<br>    &#x2F;&#x2F; 1.创建QueryRunner核心对象<br>    QueryRunner queryRunner &#x3D; new QueryRunner(JdbcUtils.getDataSource());<br>    &#x2F;&#x2F; 2.编写sql语句<br>    String sql &#x3D; “INSERT INTO account(name,money) VALUES(?,?)”;<br>    &#x2F;&#x2F; 3.执行sql<br>    queryRunner.update(sql,”TEST_CREATE”,0);<br>  }</p>
<p>  &#x2F;&#x2F; 修改记录<br>  @Test<br>  public void testUpdate() throws Exception{</p>
<pre><code>QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource());

String sql = &quot;UPDATE account SET name=?,money=? WHERE id = ?&quot;;
queryRunner.update(sql,&quot;test_Update&quot;,100,2 );
</code></pre>
<p>  }<br>  &#x2F;&#x2F; 删除记录<br>  @Test<br>  public void testDelete() throws Exception{</p>
<pre><code>QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource());
String sql = &quot;DELETE FROM account WHERE id = ?&quot;;
queryRunner.update(sql,3);
</code></pre>
<p>  }<br>}<br>查询记录</p>
<p>实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>package com.test.domain;</p>
<p>public class Account {<br>    private Integer id;<br>    private String name;<br>    private Double money;</p>
<p>&#x2F;&#x2F;省略getter&#x2F;setter，toString方法<br>api介绍</p>
<p>1<br>2<br>3<br>4<br>public <T> T query(String sql, ResultSetHandler<T> rsh, Object… params) throws SQLException {<br>  Connection conn &#x3D; this.prepareConnection();<br>  return this.query(conn, true, sql, rsh, params);<br>}<br>参数	说明<br>String sql	执行的sql语句<br>ResultSetHandler<T> rsh	返回查询结果的映射处理<br>Object… params	设置的实际参数<br>查询结果映射介绍</T></T></T></p>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;查询多条记录<br>public class BeanListHandler<T> implements ResultSetHandler&lt;List<T>&gt; </T></T></p>
<p>&#x2F;&#x2F;查询单条记录<br>public BeanHandler(Class<T> type)<br>测试代码</T></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>&#x2F;&#x2F; 根据id查询<br>@Test<br>public void testFindById() throws Exception{<br>  QueryRunner queryRunner &#x3D; new QueryRunner(JdbcUtils.getDataSource());</p>
<p>  String sql &#x3D; “SELECT * FROM account WHERE id &#x3D; ?”;</p>
<p>  Account query &#x3D; queryRunner.query(sql, new BeanHandler&lt;&gt;(Account.class),2);</p>
<p>  System.out.println(query);<br>}</p>
<p>&#x2F;&#x2F; 查询所有<br>@Test<br>public void testFindAll() throws Exception{<br>  QueryRunner queryRunner &#x3D; new QueryRunner(JdbcUtils.getDataSource());</p>
<p>  String sql &#x3D; “SELECT * FROM account”;</p>
<p>  List<Account> query &#x3D; queryRunner.query(sql, new BeanListHandler&lt;&gt;(Account.class));</Account></p>
<p>  System.out.println(query);<br>}<br>1.3 Spring的xml整合DbUtils<br>需求</p>
<p>基于Spring的xml配置实现账户的CRUD案例</p>
<p>编写AccountDao接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>public interface AccountDao {<br>    void save(Account account);<br>    void update(Account account);<br>    void delete(Integer id);<br>    List<Account> findAll();<br>    Account findById(Integer id);<br>}<br>AccountDaoImpl</Account></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>public class AccountDaoImpl implements AccountDao {</p>
<p>  &#x2F;&#x2F; 声明 QueryRunner 对象<br>  private QueryRunner queryRunner;</p>
<p>  public void setQueryRunner(QueryRunner queryRunner) {<br>    this.queryRunner &#x3D; queryRunner;<br>  }</p>
<p>  @Override<br>  public void save(Account account) {<br>    try {<br>      String sql &#x3D; “INSERT INTO account(name,money) VALUES(?,?)”;<br>      queryRunner.update(sql, account.getName(), account.getMoney());<br>    } catch (SQLException throwables) {<br>      throwables.printStackTrace();<br>    }<br>  }</p>
<p>  @Override<br>  public void update(Account account) {<br>    try {<br>      String sql &#x3D; “UPDATE account SET name&#x3D;?,money&#x3D;? WHERE id &#x3D; ?”;<br>      queryRunner.update(sql, account.getName(), account.getMoney(), account.getId());<br>    } catch (SQLException throwables) {<br>      throwables.printStackTrace();<br>    }<br>  }</p>
<p>  @Override<br>  public void delete(Integer id) {<br>    try {<br>      String sql &#x3D; “DELETE FROM account WHERE id &#x3D; ?”;<br>      queryRunner.update(sql, id);<br>    } catch (SQLException throwables) {<br>      throwables.printStackTrace();<br>    }<br>  }</p>
<p>  @Override<br>  public List<Account> findAll() {<br>    List<Account> list &#x3D; null;</Account></Account></p>
<pre><code>try &#123;
  String sql = &quot;SELECT * FROM account&quot;;
  list = queryRunner.query(sql, new BeanListHandler&lt;&gt;(Account.class));
&#125; catch (SQLException throwables) &#123;
  throwables.printStackTrace();
&#125;
return list;
</code></pre>
<p>  }</p>
<p>  @Override<br>  public Account findById(Integer id) {</p>
<pre><code>Account account = null;

try &#123;
  String sql = &quot;SELECT * FROM account WHERE id = ?&quot;;
  account = queryRunner.query(sql, new BeanHandler&lt;&gt;(Account.class), id);
&#125; catch (SQLException throwables) &#123;
  throwables.printStackTrace();
&#125;
return account;
</code></pre>
<p>  }<br>}<br>编写AccountService接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public interface AccountService {</p>
<pre><code>void save(Account account);
void update(Account account);
void delete(Integer id);
List&lt;Account&gt; findAll();
Account findById(Integer id);
</code></pre>
<p>}<br>AccountServiceImpl实现类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>private AccountDao accountDao;

public void setAccountDao(AccountDao accountDao) &#123;
    this.accountDao = accountDao;
&#125;

@Override
public void save(Account account) &#123;
    accountDao.save(account);
&#125;

@Override
public void update(Account account) &#123;
    accountDao.update(account);
&#125;

@Override
public void delete(Integer id) &#123;
    accountDao.delete(id);
&#125;

@Override
public List&lt;Account&gt; findAll() &#123;
    return accountDao.findAll();
&#125;

@Override
public Account findById(Integer id) &#123;
    return accountDao.findById(id);
&#125;
</code></pre>
<p>}<br>编写spring的核心配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;!--druid连接交给ioc容器--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;

&lt;!--queryRunner交给ioc容器--&gt;
&lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt;
    &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
&lt;!--accountDao交给ioc容器--&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;com.test.dao.impl.AccountDaoImpl&quot;&gt;
    &lt;property name=&quot;queryRunner&quot; ref=&quot;queryRunner&quot;/&gt;
&lt;/bean&gt;
&lt;!--accountService交给ioc容器--&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.test.service.impl.AccountServiceImpl&quot;&gt;
    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
&lt;/bean&gt;
</code></pre>

测试代码

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>public class AccountTest {</p>
<p>  @Test<br>  public void testCreate() throws Exception{<br>    ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    AccountService accountService &#x3D; app.getBean(AccountService.class);<br>    Account account &#x3D; new Account();<br>    account.setMoney(100.0);<br>    account.setName(“testCreate”);<br>    accountService.save(account);<br>  }<br>  @Test<br>  public void testUpdate() throws Exception{<br>    ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    AccountService accountService &#x3D; app.getBean(AccountService.class);<br>    Account account &#x3D; new Account();<br>    account.setId(4);<br>    account.setMoney(100.0);<br>    account.setName(“testUpdate”);<br>    accountService.update(account);<br>  }</p>
<p>  @Test<br>  public void testDelete() throws Exception{</p>
<pre><code>ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
AccountService accountService = app.getBean(AccountService.class);
accountService.delete(3);
</code></pre>
<p>  }<br>  @Test<br>  public void testFindAll() throws Exception{<br>    ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    AccountService accountService &#x3D; app.getBean(AccountService.class);<br>    List<Account> list &#x3D; accountService.findAll();</Account></p>
<pre><code>for (Account account : list) &#123;
  System.out.println(account);
&#125;
</code></pre>
<p>  }<br>  @Test<br>  public void testFindById() throws Exception{<br>    ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    AccountService accountService &#x3D; app.getBean(AccountService.class);<br>    Account byId &#x3D; accountService.findById(2);<br>    System.out.println(byId);<br>  }<br>}<br>1.4 jdbc配置文件抽取<br>引入context命名空间(约束)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd"><br>修改配置文件标签</beans></p>
<p>1<br>2</p>
<!-- 加载第三方配置文件 -->
<p>&lt;context:property-placeholder location&#x3D;”classpath:jdbc.properties”&#x2F;&gt;<br>二.Spring注解开发<br>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替</p>
<p>xml配置文件可以简化配置，提高开发效率。</p>
<p>2.1 Spring常用注解<br>Spring常用注解主要是替代 <bean> 的配置</bean></p>
<p>2.2.1 IOC:控制反转<br>注解	作用<br>@Component	相当于 <bean></bean><br>@Repository	专门处理dao层，交给ioc容器<br>@Service	专门处理service层，交给ioc容器<br>@Controller	专门处理web层，交给ioc容器<br>如果使用注解开发，必须开启注解组件扫描</p>
<p>1<br>2</p>
<!-- 开启注解组件扫描 -->
<p>&lt;context:component-scan base-package&#x3D;”com.test”&#x2F;&gt;<br>UserDaoImpl</p>
<p>1<br>2<br>3<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>&#x2F;&#x2F; @Component(“userDao”) value 属性相当于 id&#x3D;”userDao”<br>&#x2F;&#x2F; @Repository(“userDao”)<br>@Repository &#x2F;&#x2F; 如果我们在此处省略了value属性，那么id的默认值就是 类名首字母小写 userDaoImpl<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }<br>}<br>UserService</p>
<p>1<br>2<br>3<br>public interface UserService {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>@Service<br>public class UserServiceImpl implements UserService {</p>
<pre><code>private UserDao userDao;

public void setUserDao(UserDao userDao) &#123;
    this.userDao = userDao;
&#125;

@Override
public void save() &#123;
    userDao.save();
&#125;
</code></pre>
<p>}<br>2.2.2 DI:依赖注入<br>注解	作用<br>@Autowired	相当于 <property></property> ，根据类型注入<br>@Qualifies	与@Autowired一起使用，根据id查找同类型下的实例<br>@Resource	JDK提供的注解(@Autowired+@Qualifies)<br>UserServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>@Service<br>public class UserServiceImpl implements UserService {</p>
<p>  &#x2F;&#x2F;使用注解完成注入，代替set方法<br>  @Autowired<br>  private UserDao userDao;</p>
<p>  @Override<br>  public void save() {<br>    userDao.save();<br>  }<br>}<br>IOC容器结构图</p>
<p>Type	id	Class<br>UserDao	userDaoImpl	com.test.dao.impl.userDaoImpl<br>UserDao	userDaoImplPro	com.test.dao.impl.userDaoImplPro<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>@Service<br>public class UserServiceImpl implements UserService {</p>
<pre><code>//使用注解完成注入，代替set方法
@Autowired//根据类型注入
@Resource(name = &quot;userDaoImpl&quot;)//JDK提供，ID+类型
private UserDao userDao;

@Override
public void save() &#123;
    userDao.save();
&#125;
</code></pre>
<p>}<br>2.2.3 补充<br>注解	作用<br>@Scope	相当于 <bean scope="””"></bean><br>@PostConstruct	相当于 <bean init-method="””"></bean><br>@PreDestroy	相当于 <bean detroy-method="””"></bean><br>@Value	通过${} SPEL,从配置文件中获取数据<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>@Service<br>public class UserServiceImpl implements UserService {</p>
<p>  &#x2F;&#x2F;使用注解完成注入，代替set方法<br>  @Autowired&#x2F;&#x2F;根据类型注入<br>  @Resource(name &#x3D; “userDaoImpl”)&#x2F;&#x2F;JDK提供，ID+类型<br>  private UserDao userDao;</p>
<p>  @Value(“A”)<br>  private String name;</p>
<p>  @Value(“${jdbc.driver}”)<br>  private String driver;</p>
<p>  @Override<br>  public void save() {<br>    userDao.save();<br>  }</p>
<p>  @PostConstruct<br>  public void init(){<br>    System.out.println(“Init Run”);<br>  }<br>  @PreDestroy<br>  public void destory(){<br>    System.out.println(“Destory Run”);<br>  }<br>}<br>2.2 Spring常用注解整合DbUtils<br>复制java模块并改名导入</p>
<p>IDEA new&#x3D;&#x3D;&gt;Exist moudle&#x3D;&#x3D;&gt;SELECT Moudle&#x3D;&#x3D;&gt;Rename Moudle&#x3D;&#x3D;&gt;修改pom.xml</p>
<p>AccountDao</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>@Repository<br>public class AccountDaoImpl implements AccountDao {</p>
<pre><code>@Autowired
// 声明 QueryRunner 对象
private QueryRunner queryRunner;
</code></pre>
<p>AccountService</p>
<p>1<br>2<br>3<br>4<br>5<br>@Service<br>public class AccountServiceImpl implements AccountService {</p>
<pre><code>@Autowired
private AccountDao accountDao;
</code></pre>
<p>修改spring配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd"></beans></p>
<pre><code>&lt;!-- 开启注解组件扫描 --&gt;
&lt;context:component-scan base-package=&quot;com.test&quot;/&gt;

&lt;!-- 加载第三方配置文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;

&lt;!--druid连接交给ioc容器,第三方类目前仅能用bean标签--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
&lt;/bean&gt;

&lt;!--queryRunner交给ioc容器,第三方类目前仅能用bean标签--&gt;
&lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt;
    &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>@Test<br>public void testFindAll() throws Exception{<br>    ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>    AccountService accountService &#x3D; app.getBean(AccountService.class);<br>    List<Account> list &#x3D; accountService.findAll();</Account></p>
<pre><code>for (Account account : list) &#123;
    System.out.println(account);
&#125;
</code></pre>
<p>}<br>2.3 Spring新注解<br>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置</p>
<p>注解	作用<br>@Configuration	相当于applicationContext.xml<br>@Bean	加载第三方类(对象)，交给ioc容器<br>@PropertySource	相当于 &lt;context:property-placeholder location&#x3D;””&#x2F;&gt;<br>@ComponentScan	相当于 &lt;context:component-scan base-package&#x3D;””&#x2F;&gt;<br>@Import	相当于 <import resource="””"></import><br>2.4 Spring纯注解整合DbUtils<br>创建SpringConfig配置类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>@Configuration<br>@ComponentScan(“com.test”)<br>@PropertySource(“classpath:jdbc.properties”)<br>public class SpringConfig {</p>
<p>  @Value(“${jdbc.driver}”)<br>  private String driverClassName;</p>
<p>  @Value(“${jdbc.url}”)<br>  private String url;</p>
<p>  @Value(“${jdbc.username}”)<br>  private String username;</p>
<p>  @Value(“${jdbc.password}”)<br>  private String password;</p>
<p>  &#x2F;&#x2F; 自定义druid对象，交给ioc容器<br>  &#x2F;*<br><bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"><br>    <property name="driverClassName" value="${jdbc.driver}"></property><br>    <property name="url" value="${jdbc.url}"></property><br>    <property name="username" value="${jdbc.username}"></property><br>    <property name="password" value="${jdbc.password}"></property><br></bean><br>*&#x2F;</p>
<p>  @Bean(“dataSource”)<br>  public DataSource createDataSource() {<br>    DruidDataSource druidDataSource &#x3D; new DruidDataSource();<br>    druidDataSource.setDriverClassName(driverClassName);<br>    druidDataSource.setUrl(url);<br>    druidDataSource.setUsername(username);<br>    druidDataSource.setPassword(password);<br>    return druidDataSource;<br>  }</p>
<p>  &#x2F;&#x2F; 自定义queryRunner对象，交给ioc容器<br>  &#x2F;*<br><bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"><br>    <constructor-arg name="ds" ref="dataSource"></constructor-arg><br></bean><br>*&#x2F;<br>  @Bean(“queryRunner”)<br>  public QueryRunner createQueryRunner(@Autowired DataSource dataSource) {<br>    QueryRunner queryRunner &#x3D; new QueryRunner(dataSource);<br>    return queryRunner;<br>  }<br>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>@Test<br>public void testAnnoQueryRunner() throws Exception {</p>
<p>  AnnotationConfigApplicationContext app &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);</p>
<p>  AccountService accountService &#x3D; app.getBean(AccountService.class);</p>
<p>  Account byId &#x3D; accountService.findById(1);<br>  System.out.println(byId);<br>}<br>2.5 配置类模块化<br>编写DataSourceConfig</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>public class DataSourceConfig {<br>    @Value(“${jdbc.driver}”)<br>    private String driverClassName;</p>
<pre><code>@Value(&quot;$&#123;jdbc.url&#125;&quot;)
private String url;

@Value(&quot;$&#123;jdbc.username&#125;&quot;)
private String username;

@Value(&quot;$&#123;jdbc.password&#125;&quot;)
private String password;
</code></pre>
<p>&#x2F;&#x2F; 自定义druid对象，交给ioc容器<br>&#x2F;*<br><bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"><br>    <property name="driverClassName" value="${jdbc.driver}"></property><br>    <property name="url" value="${jdbc.url}"></property><br>    <property name="username" value="${jdbc.username}"></property><br>    <property name="password" value="${jdbc.password}"></property><br></bean><br>*&#x2F;</p>
<pre><code>@Bean(&quot;dataSource&quot;)
public DataSource createDataSource() &#123;
    DruidDataSource druidDataSource = new DruidDataSource();
    druidDataSource.setDriverClassName(driverClassName);
    druidDataSource.setUrl(url);
    druidDataSource.setUsername(username);
    druidDataSource.setPassword(password);
    return druidDataSource;
&#125;
</code></pre>
<p>}<br>修改主配置类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>@Configuration<br>@ComponentScan(“com.test”)<br>@PropertySource(“classpath:jdbc.properties”)<br>@Import({DataSourceConfig.class})<br>public class SpringConfig {<br>&#x2F;*<br>    @Value(“${jdbc.driver}”)<br>    private String driverClassName;<br>三.Spring整合Junit<br>3.1 介绍<br>Junit是一个单元测试工具，点击run的执行测试方法时，其实底层是通过runner(运行器)来工作的， 默认的Junit是不会自动加载spring环境。</p>
<p>1<br>2<br>public class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> {<br>  private final ConcurrentHashMap&lt;FrameworkMethod, Description&gt; methodDescriptions &#x3D; new ConcurrentHashMap&lt;FrameworkMethod, Description&gt;();<br>如果想在Junit中直接获取spring的容器，我们需要导入spring提供的测试整合包，切换为spring的运行 器，就可以直接获取IOC容器中的对象了。</FrameworkMethod></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<!--junit单元测试-->
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.12</version>
</dependency>
<!--spring整合junit-->
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-test</artifactId>
  <version>5.1.5.RELEASE</version>
</dependency>
3.2 使用
在进行单元测试时，指定junti的运行器为spring的

<p>1<br>2<br>@RunWith(SpringRunner.class) &#x2F;&#x2F; 将单元测试的运行器，切换为spring的</p>
<p>指定加载配置文件或者配置类</p>
<p>1<br>@ContextConfiguration(classes &#x3D; SpringConfig.class) &#x2F;&#x2F; 加载配置类的<br>总结</p>
<h1 id="spring02"><a href="#spring02" class="headerlink" title="spring02"></a>spring02</h1><h2 id="一-DbUtils"><a href="#一-DbUtils" class="headerlink" title="一 DbUtils"></a>一 DbUtils</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>DbUtils是Apache一款用于简化jdbc操作的工具类</p>
</li>
<li><p>核心对象</p>
</li>
</ul>
<p>​ - QueryRunner queryRunner &#x3D; new QueryRunner(DataSource dataSource);</p>
<ul>
<li>核心方法</li>
</ul>
<p>​ - int update();</p>
<p>​ - DML类型</p>
<p>​ - T query();</p>
<p>​ - DQL类型</p>
<h3 id="Spring的xml整合DbUtils"><a href="#Spring的xml整合DbUtils" class="headerlink" title="Spring的xml整合DbUtils"></a>Spring的xml整合DbUtils</h3><ul>
<li>spring整合第三方数据源</li>
</ul>
<p>​ - Druid</p>
<ul>
<li>spring整合DbUtils</li>
</ul>
<p>​ - QueryRunner</p>
<ul>
<li>加载第三方配置文件</li>
</ul>
<p>​ - &lt;context:property-placeholder location&#x3D;”classpath:jdbc.properties”&#x2F;&gt;</p>
<ul>
<li>使用SPEL</li>
</ul>
<p>​ - ${xxxxxx}</p>
<h2 id="二-Spring注解开发"><a href="#二-Spring注解开发" class="headerlink" title="二 Spring注解开发"></a>二 Spring注解开发</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li>IOC</li>
</ul>
<p>​ - @Component</p>
<p>​ - @Controller</p>
<p>​ - @Service</p>
<p>​ - @Repository</p>
<ul>
<li>DI</li>
</ul>
<p>​ - @Autowired</p>
<p>​ - 根据类型</p>
<p>​ - @Qualifier</p>
<p>​ - 在@Autowired基础上+id</p>
<p>​ - @Resource</p>
<p>​ - @Autowired + @Qualifier</p>
<p>​ - @Value</p>
<p>​ - 通过SPEL表达式，获取第三方配置文件的值</p>
<ul>
<li>生命周期</li>
</ul>
<p>​ - @Scope</p>
<p>​ - 作用范围</p>
<p>​ - singleton</p>
<p>​ - prototype</p>
<p>​ - @PostConstruct</p>
<p>​ - 初始化执行方法</p>
<p>​ - @PreDestroy</p>
<p>​ - 销毁执行方法</p>
<h3 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h3><ul>
<li>@Configuration</li>
</ul>
<p>​ - spring的配置文件</p>
<p>​ - applicationContext.xml</p>
<ul>
<li>@Bean</li>
</ul>
<p>​ - 将第三方类，交给ioc容器</p>
<ul>
<li>@PropertySource</li>
</ul>
<p>​ - 加载第三方配置文件</p>
<ul>
<li>@ComponentScan</li>
</ul>
<p>​ - 开启注解组件扫描</p>
<ul>
<li>@Import</li>
</ul>
<p>​ - 配置类模块化</p>
<h2 id="三-Spring整合Junit"><a href="#三-Spring整合Junit" class="headerlink" title="三 Spring整合Junit"></a>三 Spring整合Junit</h2><h3 id="Runwith注解替换原来的运行器"><a href="#Runwith注解替换原来的运行器" class="headerlink" title="@Runwith注解替换原来的运行器"></a>@Runwith注解替换原来的运行器</h3><ul>
<li>@RunWith(SpringRunner.class)</li>
</ul>
<h3 id="使用-ContextConfiguration指定配置文件或配置类"><a href="#使用-ContextConfiguration指定配置文件或配置类" class="headerlink" title="使用@ContextConfiguration指定配置文件或配置类"></a>使用@ContextConfiguration指定配置文件或配置类</h3><ul>
<li><p>@ContextConfiguration(value &#x3D; {“classpath:applicationContext.xml”})</p>
</li>
<li><p>@ContextConfiguration(classes &#x3D; {SpringConfig.class})</p>
</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="DBUtil快速入门"><a href="#DBUtil快速入门" class="headerlink" title="DBUtil快速入门"></a>DBUtil快速入门</h3><h3 id="spring的xml版本整合DBUtils"><a href="#spring的xml版本整合DBUtils" class="headerlink" title="spring的xml版本整合DBUtils"></a>spring的xml版本整合DBUtils</h3><h3 id="spring的常用注解版本整合DBUtils"><a href="#spring的常用注解版本整合DBUtils" class="headerlink" title="spring的常用注解版本整合DBUtils"></a>spring的常用注解版本整合DBUtils</h3><h3 id="spring的纯注解版本整合DBUtils"><a href="#spring的纯注解版本整合DBUtils" class="headerlink" title="spring的纯注解版本整合DBUtils"></a>spring的纯注解版本整合DBUtils</h3><h3 id="spring整合junit"><a href="#spring整合junit" class="headerlink" title="spring整合junit"></a>spring整合junit</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/28/Spring-%E5%88%9D%E8%AF%86-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/Spring-%E5%88%9D%E8%AF%86-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Spring 初识 & 相关配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-28 01:41:27" itemprop="dateCreated datePublished" datetime="2020-05-28T01:41:27+08:00">2020-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Spring概述<br>1.1 Spring是什么<br>Spring是分层的 Java SE&#x2F;EE应用 full-stack(全栈) 轻量级开源框架。<br>Spring的核心是 IOC(Inverse Of Control:控制反转)和 AOP(Aspect Oriented Programming:面向切面编程)</p>
<p>Spring一个全栈应用框架, 提供了表现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众 多应用技术</p>
<p>Spring还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框 架</p>
<p>Spring官网:<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a></p>
<p>1.2 Spring发展历程<br>EJB</p>
<p>1997 年，IBM提出了EJB 的思想</p>
<p>1998 年，SUN制定开发标准规范 EJB1.0</p>
<p>1999 年，EJB1.1 发布</p>
<p>2001 年，EJB2.0 发布</p>
<p>2003 年，EJB2.1 发布</p>
<p>2006 年，EJB3.0 发布</p>
<p>Spring<br>Rod Johnson 2002年编著《Expert one on one J2EE design and development》指出了JavaEE和EJB组件框架中的存在的一些主要缺陷;提出普通java类依赖注入更为简单的解决方案。</p>
<p>2004年编著《Expert one-on-one J2EE Development without EJB》 阐述了JavaEE开发时不使用EJB的解决方式(Spring 雏形) 同年4月spring1.0诞生</p>
<p>2006年10月，发布 Spring2.0</p>
<p>2009年12月，发布 Spring3.0</p>
<p>2013年12月，发布 Spring4.0</p>
<p>2017年9月， 发布最新 Spring5.0 通用版(GA)</p>
<p>1.3 Spring优势<br>方便解耦，简化开发<br>通过Spring提供的 IOC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。</p>
<p>AOP编程的支持</p>
<p>通过Spring的AOP功能，方便进行面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
<p>声明式事务的支持</p>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
<p>方便程序的测试</p>
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<p>方便集成各种优秀框架</p>
<p>Spring对各种优秀框架(Struts、Hibernate、Hessian、Quartz等)的支持。</p>
<p>降低JavaEE API的使用难度</p>
<p>Spring对JavaEEAPI(如JDBC、JavaMail、RPC等)进行了薄薄的封装层，使这些 API 的使用难度大为降低。</p>
<p>1.4 Spring体系结构<br>核心容器（Core Container）<br>数据访问&#x2F;集成（Data Access&#x2F;Integration）层<br>Web层<br>AOP（Aspect Oriented Programming）模块<br>植入（Instrumentation）模块<br>消息传输（Messaging）<br>测试（Test）模块</p>
<p>二.初识IOC<br>2.1 介绍<br>控制反转(Inverse Of Control) 是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。</p>
<p>控制:在java中指的是对象的控制权限(创建、销毁)</p>
<p>反转:指的是对象控制权由原来 由开发者在类中手动控制 反转到 由Spring容器控制</p>
<p>2.2 环境搭建<br>IDEA new empty project &#x3D;&#x3D;&gt;设置Project Name、JDK Version、Encodings&#x3D;&#x3D;&gt;添加maven module&#x3D;&#x3D;&gt;导入Jar包</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</p>
<!--依赖管理--> 
<dependencies>
  <!--dom4j-->
  <dependency> 
    <groupId>dom4j</groupId> 
    <artifactId>dom4j</artifactId> 
    <version>1.6.1</version>
  </dependency>
  <!--xpath-->
  <dependency> 
    <groupId>jaxen</groupId> 
    <artifactId>jaxen</artifactId> 
    <version>1.1.6</version>
  </dependency>
  <!--junit-->
  <dependency> 
    <groupId>junit</groupId> 
    <artifactId>junit</artifactId> 
    <version>4.12</version>
  </dependency>
</dependencies>
2.3 版本一:原始版本
编写UserDao接口和实现类

<p>1<br>2<br>3<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }<br>}<br>编写UserService接口和实现类</p>
<p>1<br>2<br>3<br>public interface UserService {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        userDao.save();<br>    }<br>}<br>编写UserTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class UserTest{<br>  &#x2F;&#x2F;调用Service实现保存<br>  @Test<br>  public void testUser01() throws Exception{<br>    UserServiceImpl userService &#x3D; new UserServiceImpl();<br>    userService.save();<br>  }<br>}<br>问题</p>
<p>Service层和dao层代码产生耦合——松耦原则：编译期解耦，运行期可以耦合<br>每次调用save方法时，都会创建一个新的dao对象<br>2.4 版本二:工厂解耦<br>编写beans.xml</p>
<p>1<br>2<br>3<br><beans><br>  <bean id="userDao" class="com.test.dao.impl.UserDaoImpl"></bean><br></beans><br>编写BeanFactory</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>public class BeanFactory {</p>
<pre><code>public static Object getBean(String id) &#123;
    Object object = null;

    try &#123;
        // 1.通过类加载器读取 beans.xml
        InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;);

        // 2.创建dom4j核心解析器对象
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(in);

        // 3.编写xpath表达式
        String xpath = &quot;//bean[@id=&#39;&quot; + id + &quot;&#39;]&quot;;

        // 4.获取指定id的标签对象
        Element element = (Element) document.selectSingleNode(xpath);

        // 5.获取全限定名
        String className = element.attributeValue(&quot;class&quot;);

        // 6.通过反射创建对象实例
        object = Class.forName(className).newInstance();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    // 7.返回对象实例
    return object;
&#125;
</code></pre>
<p>}<br>修改UserServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>&#x2F;&#x2F;        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        UserDao userDao &#x3D; (UserDao) BeanFactory.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}<br>问题</p>
<p>每次调用save方法，都会创建一个新的dao对象，工厂每次调用getBean方法都会创建一个新的对象实例，浪费内存</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public void save() {<br>&#x2F;&#x2F;        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        UserDao userDao &#x3D; (UserDao) BeanFactory.getBean(“userDao”);<br>        UserDao userDao1 &#x3D; (UserDao) BeanFactory.getBean(“userDao”);<br>        userDao.save();<br>        userDao1.save();<br>    }<br>}</p>
<p>&#x2F;*<br>com.test.dao.impl.UserDaoImpl@516be40f<br>com.test.dao.impl.UserDaoImpl@3c0a50da<br>UserDao Saved!<br>UserDao Saved!<br>*&#x2F;<br>2.5 版本三:工厂优化<br>修改BeanFactory</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>public class BeanFactory {</p>
<pre><code>// 声明存储对象的容器(map集合)
private static Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;();

// 静态代码块，初始化ioc容器
static &#123;
    String id = null;
    String className = null;
    Object object = null;

    try &#123;
        // 1.通过类加载器读取 beans.xml
        InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;);

        // 2.创建dom4j核心解析器对象
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(in);

        // 3.编写xpath表达式
        String xpath = &quot;//bean&quot;;

        // 4.获取所有bean标签对象
        List&lt;Element&gt; list = document.selectNodes(xpath);

        // 5.遍历集合，创建对象实例，设置到ioc容器中
        for (Element element : list) &#123;
            id = element.attributeValue(&quot;id&quot;);
            className = element.attributeValue(&quot;class&quot;);
            object = Class.forName(className).newInstance();

            // 设置到map集合
            ioc.put(id, object);
        &#125;
    &#125; catch (
            Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

// 7.从ioc容器获取指定id的对象实例
public static Object getBean(String id) &#123;
    return ioc.get(id);
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;*<br>com.test.dao.impl.UserDaoImpl@4ba2ca36<br>com.test.dao.impl.UserDaoImpl@4ba2ca36<br>UserDao Saved!<br>UserDao Saved!<br>*&#x2F;<br>2.6 小结<br>对象的创建由原来的 使用 new关键字 在类中主动创建 变成了 从工厂中获取, 而对象的创建过程由工厂 内部来实现, 而这个工厂就是 Spring的IOC容器。</p>
<p>也就是以后我们的对象不再自己创建,而是直接向 Spring要, 这种思想就是IOC</p>
<p>目的：松耦合</p>
<p>三.Spring快速入门<br>3.1 需求<br>UserServiceImpl		UserDaoImpl<br>UserDao userDao &#x3D; Spring客户端.getBean(id标识)		CURD方法<br>⬆⬇Spring框架		⬆⬇<br>读取xml配置文件<br>根据id标识获得Bean权限定名<br>通过反射创建Bean对象<br>返回对象	➡<br>⬅	xml配置文件<br>id标识&#x3D;com.test.dao.UserDaoImpl<br>3.2 代码实现<br>创建maven的java模块</p>
<p>IDEA new moudle&#x3D;&#x3D;&gt;MVN&#x3D;&#x3D;&gt;导入依赖管理Spring、Junit坐标，JDK1.8插件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br><?xml version="1.0" encoding="UTF-8"?><br><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelVersion>4.0.0</modelVersion></project></p>
<pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;
&lt;artifactId&gt;Spring_online_Day01_ioc_xml&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;!--依赖管理--&gt;
&lt;dependencies&gt;
    &lt;!--spring的核心坐标--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

编写UserDao接口和实现类(同上)

<p>1<br>2<br>3<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }<br>}<br>创建spring的核心配置文件，导入约束</p>
<p>官方推荐名称:applicationContext.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>

写bean标签(id、class)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;!--    将userDao的对象创建权交给ioc容器--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre>

测试(模拟service层)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class UserTest {<br>    &#x2F;&#x2F; spring的快速入门<br>    @Test<br>    public void testUser() throws Exception{<br>        &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>        ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        &#x2F;&#x2F; 2.获取指定id的对象实例<br>        UserDao userDao &#x3D; (UserDao) app.getBean(“userDao”);<br>        userDao.save();<br>    }<br>}<br>四.Spring相关API<br>4.1 二个接口(创建的对象均为单例)<br>BeanFactory</p>
<p>介绍</p>
<p>IOC容器的顶级接口，定义了IOC的最基础的功能, 但功能比较简单,一般面向Spring自身使用</p>
<p>特点(懒汉设计)</p>
<p>在第一次使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化[用的时候再创建]</p>
<p>ApplicationContext</p>
<p>介绍</p>
<p>这是在BeanFactory基础上衍生出的接口,它扩展了BeanFactory的功能,一般面向程序员使用</p>
<p>特点(恶汉设计)</p>
<p>在容器启动时，一次性创建并加载了所有的Bean [初始化的时候全创建好]</p>
<p>4.2 三个实现类<br>ClassPathXmlApplicationContext</p>
<p>功能：读取类路径(classpath)下的xml配置文件</p>
<p>FileSystemXmlApplicationContext</p>
<p>功能：读取本地磁盘下的xml配置文件</p>
<p>AnnotationConfigApplicationContext</p>
<p>功能：读取java配置类加载配置</p>
<p>4.3 一个方法<br>public Object getBean(String name) throws BeansException;</p>
<p>功能：通过指定id获取对象的实例，需要手动强转</p>
<p>public <T> T getBean(Class<T> requiredType);</T></T></p>
<p>功能：通过指定类型获取对象的实例，不需要强转</p>
<p>public <T> T getBean(String name, Class<T> requiredType);</T></T></p>
<p>功能：通过指定id和类型获取对象的实例</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>&#x2F;&#x2F; getBean方法介绍<br>&#x2F;&#x2F; 方式一: 通过指定id获取对象的实例，需要手动强转<br>@Test<br>public void testUserByID() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>  &#x2F;&#x2F; 2.获取指定id的对象实例<br>  UserDao userDao &#x3D; (UserDao) app.getBean(“userDao”);<br>  userDao.save();<br>}</p>
<p>&#x2F;&#x2F; getBean方法介绍<br>&#x2F;&#x2F; 方式二:通过指定(接口)类型获取对象的实例，不需要强转<br>&#x2F;&#x2F;缺点:如果同一个接口类型下有多个对象实例，会报错<br>@Test<br>public void testUserByInstance() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  UserDao userDao &#x3D; app.getBean(UserDao.class);<br>  userDao.save();<br>}</p>
<p>&#x2F;&#x2F; getBean方法介绍<br>&#x2F;&#x2F; 方式三:通过指定id和类型获取对象的实例<br>@Test<br>public void testUserBySpecifyIdOfType() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>  UserDao userDao &#x3D; app.getBean(“userDao”, UserDao.class);<br>  userDao.save();<br>}</p>
<p>4.4 知识小结<br>1<br>2<br>3<br>ApplicationContext app &#x3D; new ClasspathXmlApplicationContext(“xml文件”);<br>app.getBean(“id”);<br>app.getBean(Class);<br>五.Spring配置文件<br>5.1 Bean标签基本配置<br>基本配置</p>
<p>1<br><bean id="userDao" class="cn.itcast.dao.impl.UserDaoImpl"></bean><br>基本属性	<br>id	在ioc容器的唯一标识<br>class	创建对象实例的全限定名<br>作用范围</p>
<p>scope属性:声明此对象的作用范围	何时创建	对象运行	何时销毁<br>singleton(单例对象)	ioc容器初始化时，创建对象	ioc容器在,对象在	ioc容器关闭时，销毁对象<br>prototype(多例对象)	在调用getBean()方法时，创建	一直使用就一直活着	当对象不再使用后，根据JVM GC机制垃圾回收<br>生命周期</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;!--    将userDao的对象创建权交给ioc容器--&gt;
</code></pre>
<p>  <bean id="userDao" class="com.test.dao.impl.UserDaoImpl" scope="singleton" init-method="MethodInit" destroy-method="MethodDestory"></bean><br><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void save() {<br>        System.out.println(“UserDao Saved!”);<br>    }</p>
<p>  &#x2F;&#x2F;当创建时，init-method&#x3D;”MethodInit”<br>    private void MethodInit() {<br>        System.out.println(“Method Init Now”);<br>    }</p>
<p>  &#x2F;&#x2F;当销毁时，destroy-method&#x3D;”MethodDestory”<br>    private void MethodDestory() {<br>        System.out.println(“Method Die Now”);<br>    }<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>@Test<br>public void testUserDestory() throws Exception {<br>  &#x2F;&#x2F; 1.通过spring的api读取配置文件<br>  ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>  &#x2F;&#x2F; 2.获取指定id的对象实例<br>  UserDao userDao &#x3D; (UserDao) app.getBean(“userDao”);<br>  UserDao userDao1 &#x3D; (UserDao) app.getBean(“userDao”);</p>
<p>  System.out.println(userDao);<br>  System.out.println(userDao1);</p>
<p>  ((ClassPathXmlApplicationContext) app).close();<br>}</p>
<p>&#x2F;*<br>Method Init Now<br>com.test.dao.impl.UserDaoImpl@78e67e0a<br>com.test.dao.impl.UserDaoImpl@78e67e0a<br>Method Die Now<br>*&#x2F;<br>5.2 spring创建对象实例三种方式<br>无参构造方法实例化</p>
<p>在企业开发时，所有的类必须提供无参构造方法</p>
<p>1<br>2<br>public UserDaoImpl(String a)<br>  &#x2F;&#x2F;若未提供无参构造，则xml中class&#x3D;”com.test.dao.impl.UserDaoImpl” 会报错<br>工厂静态方法实例化</p>
<p>依赖的jar包中有个A类，A类中有个静态方法m1，m1方法的返回值是一个B对象。如果我们频繁 使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无 需调用A类中的m1方法，直接从IOC容器获得。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>&#x2F;&#x2F;工厂静态方法实例化对象<br>public class StaticFactoryBean {<br>    public static UserDao createUserDao(){<br>        return new UserDaoImpl();<br>    }</p>
<pre><code>// 传统方式，自己通过工厂获取对象
public static void main(String[] args) &#123;
    UserDao userDao = StaticFactoryBean.createUserDao();
&#125;
</code></pre>
<p>}<br>1<br>2</p>
<!--工厂静态方法实例化对象-->
<p><bean id="userDao" class="com.test.factory.StaticFactoryBean" factory-method="createUserDao"></bean><br>工厂普通方法实例化</p>
<p>依赖的jar包中有个A类，A类中有个普通方法m1，m1方法的返回值是一个B对象。如果我们频繁 使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无 需调用A类中的m1方法，直接从IOC容器获得。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>&#x2F;&#x2F;工厂普通方法实例化对象<br>public class DynamicFactoryBean {</p>
<p>  public UserDao createUserDao() {<br>    return new UserDaoImpl();<br>  }</p>
<p>  &#x2F;&#x2F; 传统方式，自己通过工厂获取对象<br>  public static void main(String[] args) {<br>    &#x2F;&#x2F; 1.创建工厂对象<br>    DynamicFactoryBean dynamicFactoryBean &#x3D; new DynamicFactoryBean();<br>    &#x2F;&#x2F; 2.创建UserDao对象<br>    UserDao userDao &#x3D; dynamicFactoryBean.createUserDao();<br>  }<br>}<br>1<br>2<br>3</p>
<!--工厂普通方法实例化对象-->
<p><bean id="dynamicFactoryBean" class="com.test.factory.DynamicFactoryBean"></bean><br><bean id="userDao" factory-bean="dynamicFactoryBean"></bean><br>5.3 Bean依赖注入<br>5.3.1 概述<br>依赖注入(Dependency Injection, DI) 它是 Spring 框架核心 IOC 的具体实现</p>
<p>其实就是给对象中的属性赋值的过程，通过spring完成依赖注入</p>
<p>UserServiceImpl	➡依赖	UserDaoImpl<br>private UserDao userDao<br>userDao.save()		<br>⬆service层需要调用dao层对象的实例，就要从Spring的ioc容器注入此实例，<br>⬆这个过程称为依赖注入		<br>Spring的配置文件		<br><bean id="”userDao”" class="”xxx”"><br><bean id="”userService”" class="”xxx”">		<br>5.3.2 环境搭建<br>IDEA new moudle&#x3D;&#x3D;&gt;MVN&#x3D;&#x3D;&gt;导入依赖管理Spring、Junit坐标，JDK1.8插件&#x3D;&#x3D;&gt;复制UserDao,UserService&#x3D;&#x3D;&gt;编写spring的核心配置文件</bean></bean></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br><build><br>    <plugins><br>        <plugin><br>            <groupId>org.apache.maven.plugins</groupId><br>            <artifactId>maven-compiler-plugin</artifactId><br>            <configuration><br>                <source>1.8<br>                <target>1.8</target><br>                <encoding>UTF-8</encoding><br>            </configuration><br>        </plugin><br>    </plugins><br></build></p>
<!--依赖管理-->
<dependencies>
    <!--spring的核心坐标-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.1.5.RELEASE</version>
    </dependency>
    <!--junit-->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <dependency>
        <groupId>dom4j</groupId>
        <artifactId>dom4j</artifactId>
        <version>1.6</version>
        <scope>compile</scope>
    </dependency>
</dependencies>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd">

<pre><code>&lt;!--    将userDao的对象创建权交给ioc容器--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;


&lt;!--    将userService交给ioc容器--&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
</beans>
5.4 Bean依赖注入方式
构造方法

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class UserServiceImpl implements UserService {</p>
<pre><code>private UserDao userDao;

public UserServiceImpl(UserDao userDao) &#123;
    this.userDao = userDao;
&#125;

@Override
public void save() &#123;
    userDao.save();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<!--
构造方法注入: <constructor-arg> 子标签
版本一:
    name:构造方法参数名称 
    value:简单数据类型(String、int、double...)
    ref:引用数据类型(从ioc容器中获取的对象) 
版本二:
    index:构造方法参数索引 
    type:该索引对应的java类型(全限定名) 
    value:简单数据类型(String、int、double...) 
    ref:引用数据类型(从ioc容器中获取的对象)
-->

<!--    将userService交给ioc容器-->
<bean id="userService" class="com.test.service.impl.UserServiceImpl">
  <constructor-arg name="userDao" ref="userDao"></constructor-arg>
</bean>
set方法(推荐使用 )

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class UserServiceImpl implements UserService {</p>
<pre><code>private UserDao userDao;
</code></pre>
<p>&#x2F;&#x2F;    public UserServiceImpl(UserDao userDao) {<br>&#x2F;&#x2F;        this.userDao &#x3D; userDao;<br>&#x2F;&#x2F;    }</p>
<pre><code>public void setUserDao(UserDao userDao) &#123;
    this.userDao = userDao;
&#125;

@Override
public void save() &#123;
    userDao.save();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<!--    将userDao的对象创建权交给ioc容器-->
<p><bean id="userDao" class="com.test.dao.impl.UserDaoImpl"></bean></p>
<!--

    set方法注入:<property> 子标签
        name:set方法的属性名 setUserDao() -> UserDao -> userDao
        value:简单数据类型(String、int、double...)
        ref:引用数据类型(从ioc容器中获取的对象)
        -->
<bean id="userService" class="com.test.service.impl.UserServiceImpl">
  <property name="userDao" ref="userDao"></property>
</bean>
P命名空间注入

<p>P命名空间注入底层(本质)使用的也是set方法注入，只是在上着的基础上进行简化</p>
<p>导入P命名空间约束</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"><br>使用P命名空间注完成注入(单一属性来简洁，但是若变量多，则不如第二种规范)</beans></p>
<p>1<br><bean id="userService" class="com.test.service.impl.UserServiceImpl" p:userdao-ref="userDao"></bean><br>5.5 Bean依赖注入的数据类型<br>简单数据类型</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>public class User {</p>
<pre><code>private Integer id;

private String username;

public void setId(Integer id) &#123;
    this.id = id;
&#125;

public void setUsername(String username) &#123;
    this.username = username;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5</p>
<!-- 注入简单数据类型 -->
<bean id="user" class="com.test.domain.User">
  <property name="id" value="1"></property>
  <property name="username" value="jack"></property>
</bean>
引用数据类型

<p>参考5.4 Bean依赖注入方式</p>
<p>集合数据类型</p>
<p>单列集合(list、set、array)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>public class UserDaoImpl implements UserDao {</p>
<pre><code>private List&lt;Object&gt; list;
private Set&lt;Object&gt; set;
private Object[] array;

public void setList(List&lt;Object&gt; list) &#123;
    this.list = list;
&#125;

public void setSet(Set&lt;Object&gt; set) &#123;
    this.set = set;
&#125;

public void setArray(Object[] array) &#123;
    this.array = array;
&#125;

@Override
public void save() &#123;
    System.out.println(&quot;UserDao Saved!&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40</p>
<!--
    di 注入单列集合类型
        需要在 <property>标签中
    list集合 使用子标签 <list>
            <value> 简单数据类型
            <ref> 引用数据类型(对象在ioc容器中)
    set集合 使用子标签 <set>
        <value> 简单数据类型
        <ref> 引用数据类型(对象在ioc容器中)
    array数组 使用子标签<array>
        <value> 简单数据类型
        <ref> 引用数据类型(对象在ioc容器中)
-->


<bean id="userDao" class="com.test.dao.impl.UserDaoImpl">
  <property name="list">
    <list>
      <value>A</value>
      <value>B</value>
      <ref bean="user"></ref>
    </list>
  </property>

  <property name="set">
    <set>
      <value>C</value>
      <value>D</value>
      <ref bean="user"></ref>
    </set>
  </property>

  <property name="array">
    <array>
      <value>E</value>
      <value>F</value>
      <ref bean="user"></ref>
    </array>
  </property>
</bean>
双列集合(map、properties)

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>package com.test.dao.impl;</p>
<p>import com.test.dao.UserDao;</p>
<p>import java.util.List;<br>import java.util.Map;<br>import java.util.Properties;<br>import java.util.Set;</p>
<p>public class UserDaoImpl implements UserDao {</p>
<p>&#x2F;&#x2F;    private List<Object> list;<br>&#x2F;&#x2F;    private Set<Object> set;<br>&#x2F;&#x2F;    private Object[] array;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setList(List<Object> list) {<br>&#x2F;&#x2F;        this.list &#x3D; list;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setSet(Set<Object> set) {<br>&#x2F;&#x2F;        this.set &#x3D; set;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    public void setArray(Object[] array) {<br>&#x2F;&#x2F;        this.array &#x3D; array;<br>&#x2F;&#x2F;    }</Object></Object></Object></Object></p>
<pre><code>private Map&lt;String ,Object&gt; map;
private Properties properties;

public void setMap(Map&lt;String, Object&gt; map) &#123;
    this.map = map;
&#125;

public void setProperties(Properties properties) &#123;
    this.properties = properties;
&#125;

@Override
public void save() &#123;
    System.out.println(&quot;UserDao Saved!&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27</p>
<!--
di 注入双列集合类型
    需要在 <property>标签中
map集合 使用子标签<map>
    <entry key="" value="简单数据类型" | value-ref="引用数据类型(对象ioc中)" ></entry>
properties集合 使用子标签 <props>
     <prop key="" >value</prop>
-->
<bean id="userDao" class="com.test.dao.impl.UserDaoImpl">
    <property name="map">
        <map>
            <entry key="k1" value="v1"></entry>
            <entry key="k2" value="v2"></entry>
            <entry key="u1" value-ref="user"></entry>
        </map>
    </property>
    <property name="properties">
        <props>
            <prop key="k1">v1</prop>
            <prop key="k3">v2</prop>
            <prop key="k3">v3</prop>
        </props>
    </property>
</bean>
5.6 配置文件模块化
实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，也就是所谓的配置文件模块化。

<p>并列加载</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>&#x2F;&#x2F;并列加载<br>@Test<br>public void testParallels() throws Exception{<br>    ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(“applicationContext_dao.xml”,”applicationContext_service.xml”);</p>
<p>}<br>主从配置</p>
<p>1<br>2<br>3<br>4<br>5<br>tree<br>.<br>├── applicationContext-dao.xml<br>├── applicationContext-service.xml<br>└── applicationContext.xml<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<!-- applicationContext.xml-->

<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"></beans></p>
<pre><code>&lt;import resource=&quot;classpath:applicationContext-dao.xml&quot;&gt;&lt;/import&gt;
&lt;import resource=&quot;classpath:applicationContext-service.xml&quot;&gt;&lt;/import&gt;
</code></pre>
<p>注意：不论是否同一个xml，都不得出现相同id，否则触发报错或覆盖问题</p>
<p>5.7 知识小结<br><bean>标签:创建对象并放到spring的IOC容器</bean></p>
<p>id属性:在容器中Bean实例的唯一标识，不允许重复</p>
<p>class属性:要实例化的Bean的全限定名</p>
<p>scope属性:Bean的作用范围，常用是Singleton(默认)和prototype</p>
<p><constructor-arg>标签:属性注入</constructor-arg></p>
<p>name属性:属性名称</p>
<p>value属性:注入的简单属性值</p>
<p>ref属性:注入的对象引用值</p>
<p><property>标签:属性注入</property></p>
<p>name属性:属性名称</p>
<p>value属性:注入的简单属性值</p>
<p>ref属性:注入的对象引用值</p>
<list>
<set>
<array>
<map>
<props>

<p><import>标签:导入其他的Spring的分文件</import></p>
<p>总结</p>
<h1 id="spring01"><a href="#spring01" class="headerlink" title="spring01"></a>spring01</h1><h2 id="一-Spring概述"><a href="#一-Spring概述" class="headerlink" title="一 Spring概述"></a>一 Spring概述</h2><h3 id="spring是一款-full-stack-轻量级开源框架"><a href="#spring是一款-full-stack-轻量级开源框架" class="headerlink" title="spring是一款 full-stack 轻量级开源框架"></a>spring是一款 full-stack 轻量级开源框架</h3><ul>
<li>IOC</li>
</ul>
<p>​ - 控制反转</p>
<ul>
<li>AOP</li>
</ul>
<p>​ - 面向切面编程</p>
<h2 id="二-初识IOC"><a href="#二-初识IOC" class="headerlink" title="二 初识IOC"></a>二 初识IOC</h2><h3 id="控制反转（Inverse-Of-Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。"><a href="#控制反转（Inverse-Of-Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。" class="headerlink" title="控制反转（Inverse Of Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。"></a>控制反转（Inverse Of Control）是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。</h3><h3 id="自定义IOC容器"><a href="#自定义IOC容器" class="headerlink" title="自定义IOC容器"></a>自定义IOC容器</h3><ul>
<li>BeanFactory</li>
</ul>
<h2 id="三-Spring快速入门"><a href="#三-Spring快速入门" class="headerlink" title="三 Spring快速入门"></a>三 Spring快速入门</h2><h3 id="1-创建java项目，导入spring开发基本坐标"><a href="#1-创建java项目，导入spring开发基本坐标" class="headerlink" title="1. 创建java项目，导入spring开发基本坐标"></a>1. 创建java项目，导入spring开发基本坐标</h3><h3 id="2-编写Dao接口和实现类"><a href="#2-编写Dao接口和实现类" class="headerlink" title="2. 编写Dao接口和实现类"></a>2. 编写Dao接口和实现类</h3><h3 id="3-创建spring核心配置文件"><a href="#3-创建spring核心配置文件" class="headerlink" title="3. 创建spring核心配置文件"></a>3. 创建spring核心配置文件</h3><h3 id="4-在spring配置文件中配置-UserDaoImpl"><a href="#4-在spring配置文件中配置-UserDaoImpl" class="headerlink" title="4. 在spring配置文件中配置 UserDaoImpl"></a>4. 在spring配置文件中配置 UserDaoImpl</h3><h3 id="5-使用spring相关API获得Bean实例"><a href="#5-使用spring相关API获得Bean实例" class="headerlink" title="5. 使用spring相关API获得Bean实例"></a>5. 使用spring相关API获得Bean实例</h3><h2 id="四-Spring相关API"><a href="#四-Spring相关API" class="headerlink" title="四 Spring相关API"></a>四 Spring相关API</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><ul>
<li>是 IOC 容器的核心接口，它定义了IOC的基本功能。</li>
</ul>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><ul>
<li><p>代表应用上下文对象，可以获得spring中IOC容器的Bean对象。</p>
</li>
<li><p>常用实现类</p>
</li>
</ul>
<p>​ - 1. ClassPathXmlApplicationContext</p>
<p>​ - 2. FileSystemXmlApplicationContext</p>
<p>​ - 3. AnnotationConfigApplicationContext</p>
<ul>
<li>常用方法</li>
</ul>
<p>​ - 1. Object getBean(String name);</p>
<p>​ - 2. <T> T getBean(Class<T> requiredType);</T></T></p>
<p>​ - 3. <T> T getBean(String name,Class<T> requiredType);</T></T></p>
<h2 id="五-Spring配置文件"><a href="#五-Spring配置文件" class="headerlink" title="五 Spring配置文件"></a>五 Spring配置文件</h2><h3 id="5-1-Bean标签基本配置"><a href="#5-1-Bean标签基本配置" class="headerlink" title="5.1 Bean标签基本配置"></a>5.1 Bean标签基本配置</h3><ul>
<li><p>id：Bean实例在Spring容器中的唯一标识</p>
</li>
<li><p>class：Bean的全限定名</p>
</li>
</ul>
<h3 id="5-2-Bean标签范围配置"><a href="#5-2-Bean标签范围配置" class="headerlink" title="5.2 Bean标签范围配置"></a>5.2 Bean标签范围配置</h3><ul>
<li>scope</li>
</ul>
<p>​ - singleton</p>
<p>​ - prototype</p>
<h3 id="5-3-Bean生命周期配置"><a href="#5-3-Bean生命周期配置" class="headerlink" title="5.3 Bean生命周期配置"></a>5.3 Bean生命周期配置</h3><ul>
<li><p>init-method</p>
</li>
<li><p>destroy-method</p>
</li>
</ul>
<h3 id="5-4-Bean实例化三种方式"><a href="#5-4-Bean实例化三种方式" class="headerlink" title="5.4 Bean实例化三种方式"></a>5.4 Bean实例化三种方式</h3><p>无参构造方法</p>
<p>工厂静态方法</p>
<p>工厂实例方法</p>
<h3 id="5-5-Bean依赖注入概述"><a href="#5-5-Bean依赖注入概述" class="headerlink" title="5.5 Bean依赖注入概述"></a>5.5 Bean依赖注入概述</h3><p>通过框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<h3 id="5-6-Bean依赖注入方式"><a href="#5-6-Bean依赖注入方式" class="headerlink" title="5.6 Bean依赖注入方式"></a>5.6 Bean依赖注入方式</h3><p>构造方法<br><constructor-arg name="”userDao”" ref="”userDao”/"><br>set方法<br><property name="”userDao”" ref="”userDao”/"><br>p命名空间<br><bean id="”userService”" class="”com.test.service.impl.UserServiceImpl”" p:userdao-ref="”userDao”/"></bean></property></constructor-arg></p>
<h3 id="5-7-Bean依赖注入的数据类型"><a href="#5-7-Bean依赖注入的数据类型" class="headerlink" title="5.7 Bean依赖注入的数据类型"></a>5.7 Bean依赖注入的数据类型</h3><ul>
<li><p>简单数据类型</p>
</li>
<li><p>引用数据类型</p>
</li>
<li><p>集合数据类型</p>
</li>
</ul>
<p>​ - list</p>
<p>​ - set</p>
<p>​ - array</p>
<p>​ - map</p>
<p>​ - properties</p>
<h3 id="5-8-配置文件模块化"><a href="#5-8-配置文件模块化" class="headerlink" title="5.8 配置文件模块化"></a>5.8 配置文件模块化</h3><ul>
<li>主从配置</li>
</ul>
<import resource="”applicationContext-xxx.xml”/"></import></props></map></array></set></list>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/25/Linux-Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/Linux-Nginx/" class="post-title-link" itemprop="url">Linux & Nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 01:40:56" itemprop="dateCreated datePublished" datetime="2020-05-25T01:40:56+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.linux基础<br>1.1 远程连接工具使用<br>在实际开发中，Linux服务器都在其他的地方，我们要通过windows客户端工具远程去连接Linux并操作 它，连接Linux的windows客户端工具有很多，企业中常用的有secureCRT、Putty、xshell、SSH Secure等。</p>
<p>1.2 Linux目录结构<br>root目录:超级管理员所在的目录，用~表示<br>home目录:普通用户所在的目录<br>usr目录:安装用户文件所在的目录<br>etc目录:Linux系统管理和配置文件所在的目录</p>
<p>1.3 文件夹(目录)操作命令<br>查看</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>ls</p>
<p>List directory contents.</p>
<ul>
<li><p>List files one per line:<br>  ls -1</p>
</li>
<li><p>List all files, including hidden files:<br>  ls -a</p>
</li>
<li><p>Long format list (permissions, ownership, size and modification date) of all files:<br>  ls -la</p>
</li>
<li><p>Long format list with size displayed using human readable units (KB, MB, GB):<br>  ls -lh</p>
</li>
<li><p>Long format list sorted by size (descending):<br>  ls -lS</p>
</li>
<li><p>Long format list of all files, sorted by modification date (oldest first):<br>  ls -ltr<br>跳转</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>cd</p>
<p>Change the current working directory.</p>
<ul>
<li><p>Go to the given directory:<br>  cd path&#x2F;to&#x2F;directory</p>
</li>
<li><p>Go to home directory of current user:<br>  cd</p>
</li>
<li><p>Go up to the parent of the current directory:<br>  cd ..</p>
</li>
<li><p>Go to the previously chosen directory:<br>  cd -<br>创建</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>mkdir</p>
<p>Creates a directory.</p>
<ul>
<li><p>Create a directory in current directory or given path:<br>  mkdir directory</p>
</li>
<li><p>Create directories recursively (useful for creating nested dirs):<br>  mkdir -p path&#x2F;to&#x2F;directory<br>搜索</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>find</p>
<p>Find files or directories under the given directory tree, recursively.</p>
<ul>
<li><p>Find files by extension:<br>  find root_path -name ‘*.ext’</p>
</li>
<li><p>Find files by matching multiple patterns:<br>  find root_path -name ‘<em>pattern_1</em>‘ -or -name ‘<em>pattern_2</em>‘</p>
</li>
<li><p>Find directories matching a given name, in case-insensitive mode:<br>  find root_path -type d -iname ‘<em>lib</em>‘</p>
</li>
<li><p>Find files matching a path pattern:<br>  find root_path -path ‘<strong>&#x2F;lib&#x2F;</strong>&#x2F;*.ext’</p>
</li>
<li><p>Find files matching a given pattern, excluding specific paths:<br>  find root_path -name ‘<em>.py’ -not -path ‘</em>&#x2F;site-packages&#x2F;*’</p>
</li>
<li><p>Find files matching a given size range:<br>  find root_path -size +500k -size -10M</p>
</li>
<li><p>Run a command for each file (use <code>&#123;&#125;</code> within the command to access the filename):<br>  find root_path -name ‘*.ext’ -exec wc -l {} ;</p>
</li>
<li><p>Find files modified in the last 7 days, and delete them:<br>  find root_path -mtime -7 -delete<br>修改</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<p>mv</p>
<p>Move or rename files and directories.</p>
<ul>
<li><p>Move files in arbitrary locations:<br>  mv source target</p>
</li>
<li><p>Do not prompt for confirmation before overwriting existing files:<br>  mv -f source target</p>
</li>
<li><p>Prompt for confirmation before overwriting existing files, regardless of file permissions:<br>  mv -i source target</p>
</li>
<li><p>Do not overwrite existing files at the target:<br>  mv -n source target</p>
</li>
<li><p>Move files in verbose mode, showing files after they are moved:<br>  mv -v source target<br>剪切</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<p>mv</p>
<p>Move or rename files and directories.</p>
<ul>
<li><p>Move files in arbitrary locations:<br>  mv source target</p>
</li>
<li><p>Do not prompt for confirmation before overwriting existing files:<br>  mv -f source target</p>
</li>
<li><p>Prompt for confirmation before overwriting existing files, regardless of file permissions:<br>  mv -i source target</p>
</li>
<li><p>Do not overwrite existing files at the target:<br>  mv -n source target</p>
</li>
<li><p>Move files in verbose mode, showing files after they are moved:<br>  mv -v source target<br>复制</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>cp</p>
<p>Copy files and directories.</p>
<ul>
<li><p>Copy a file to another location:<br>  cp path&#x2F;to&#x2F;file.ext path&#x2F;to&#x2F;copy.ext</p>
</li>
<li><p>Copy a file into another directory, keeping the filename:<br>  cp path&#x2F;to&#x2F;file.ext path&#x2F;to&#x2F;target_parent_directory</p>
</li>
<li><p>Recursively copy a directory’s contents to another location (if the destination exists, the directory is copied inside it):<br>  cp -r path&#x2F;to&#x2F;directory path&#x2F;to&#x2F;copy</p>
</li>
<li><p>Copy a directory recursively, in verbose mode (shows files as they are copied):<br>  cp -vr path&#x2F;to&#x2F;directory path&#x2F;to&#x2F;copy</p>
</li>
<li><p>Copy text files to another location, in interactive mode (prompts user before overwriting):<br>  cp -i *.txt path&#x2F;to&#x2F;target_directory</p>
</li>
<li><p>Dereference symbolic links before copying:<br>  cp -L link path&#x2F;to&#x2F;copy<br>删除</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>rmdir</p>
<p>Removes a directory.</p>
<ul>
<li><p>Remove directory, provided it is empty. Use <code>rm</code> to remove not empty directories:<br>  rmdir path&#x2F;to&#x2F;directory</p>
</li>
<li><p>Remove directories recursively (useful for nested dirs):<br>  rmdir -p path&#x2F;to&#x2F;directory<br>1.4 文件操作命令<br>创建</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>touch</p>
<p>Change a file access and modification times (atime, mtime).</p>
<ul>
<li><p>Create a new empty file(s) or change the times for existing file(s) to current time:<br>  touch filename</p>
</li>
<li><p>Set the times on a file to a specific date and time:<br>  touch -t YYYYMMDDHHMM.SS filename</p>
</li>
<li><p>Use the times from a file to set the times on a second file:<br>  touch -r filename filename2<br>查看</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>cat</p>
<p>Print and concatenate files.</p>
<ul>
<li><p>Print the contents of a file to the standard output:<br>  cat file</p>
</li>
<li><p>Concatenate several files into the target file:<br>  cat file1 file2 &gt; target_file</p>
</li>
<li><p>Append several files into the target file:<br>  cat file1 file2 &gt;&gt; target_file</p>
</li>
<li><p>Number all output lines:<br>  cat -n file</p>
</li>
<li><p>Display non-printable and whitespace characters (with <code>M-</code> prefix if non-ASCII):<br>  cat -v -t -e file</p>
</li>
</ul>
<p>tail</p>
<p>Display the last part of a file.</p>
<ul>
<li><p>Show last ‘num’ lines in file:<br>  tail -n num file</p>
</li>
<li><p>Show all file since line ‘num’:<br>  tail -n +num file</p>
</li>
<li><p>Show last ‘num’ bytes in file:<br>  tail -c num file</p>
</li>
<li><p>Keep reading file until <code>Ctrl + C</code>:<br>  tail -f file</p>
</li>
<li><p>Keep reading file until <code>Ctrl + C</code>, even if the file is rotated:<br>  tail -F file</p>
</li>
</ul>
<p>head</p>
<p>Output the first part of files.</p>
<ul>
<li><p>Output the first few lines of a file:<br>  head -n count_of_lines filename</p>
</li>
<li><p>Output the first few bytes of a file:<br>  head -c number_in_bytes filename<br>删除</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>rm</p>
<p>Remove files or directories.</p>
<ul>
<li><p>Remove files from arbitrary locations:<br>  rm path&#x2F;to&#x2F;file path&#x2F;to&#x2F;another&#x2F;file</p>
</li>
<li><p>Recursively remove a directory and all its subdirectories:<br>  rm -r path&#x2F;to&#x2F;directory</p>
</li>
<li><p>Forcibly remove a directory, without prompting for confirmation or showing error messages:<br>  rm -rf path&#x2F;to&#x2F;directory</p>
</li>
<li><p>Interactively remove multiple files, with a prompt before every removal:<br>  rm -i file(s)</p>
</li>
<li><p>Remove files in verbose mode, printing a message for each removed file:<br>  rm -v path&#x2F;to&#x2F;directory&#x2F;*<br>编辑</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>vim</p>
<p>Vim (Vi IMproved), a command-line text editor, provides several modes for different kinds of text manipulation.<br>Pressing <code>i</code> enters edit mode. <code>&lt;Esc&gt;</code> goes back to normal mode, which doesn’t allow regular text insertion.<br>More information: <a target="_blank" rel="noopener" href="https://www.vim.org/">https://www.vim.org</a>.</p>
<ul>
<li><p>Open a file:<br>  vim path&#x2F;to&#x2F;file</p>
</li>
<li><p>View Vim’s help manual:<br>  :help<Enter></Enter></p>
</li>
<li><p>Save a file:<br>  :write<Enter></Enter></p>
</li>
<li><p>Quit without saving:<br>  :quit!<Enter></Enter></p>
</li>
<li><p>Open a file at a specified line number:<br>  vim +line_number path&#x2F;to&#x2F;file</p>
</li>
<li><p>Undo the last operation:<br>  u</p>
</li>
<li><p>Search for a pattern in the file (press <code>n</code>&#x2F;<code>N</code> to go to next&#x2F;previous match):<br>  &#x2F;search_pattern<Enter></Enter></p>
</li>
<li><p>Perform a regex substitution in the whole file:<br>  :%s&#x2F;pattern&#x2F;replacement&#x2F;g<Enter><br>1.5 文件压缩命令<br>将文件打成压缩包</Enter></p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>tar</p>
<p>Archiving utility.<br>Often combined with a compression method, such as gzip or bzip.<br>More information: <a target="_blank" rel="noopener" href="https://www.gnu.org/software/tar">https://www.gnu.org/software/tar</a>.</p>
<ul>
<li><p>Create an archive from files:<br>  tar cf target.tar file1 file2 file3</p>
</li>
<li><p>Create a gzipped archive:<br>  tar czf target.tar.gz file1 file2 file3</p>
</li>
<li><p>Create a gzipped archive from a directory using relative paths:<br>  tar czf target.tar.gz -C path&#x2F;to&#x2F;directory .</p>
</li>
<li><p>Extract a (compressed) archive into the current directory:<br>  tar xf source.tar[.gz|.bz2|.xz]</p>
</li>
<li><p>Extract an archive into a target directory:<br>  tar xf source.tar -C directory</p>
</li>
<li><p>Create a compressed archive, using archive suffix to determine the compression program:<br>  tar caf target.tar.xz file1 file2 file3</p>
</li>
<li><p>List the contents of a tar file:<br>  tar tvf source.tar</p>
</li>
<li><p>Extract files matching a pattern:<br>  tar xf source.tar –wildcards “*.html”</p>
</li>
<li><p>Extract a specific file without preserving the folder structure:<br>  tar xf source.tar source.tar&#x2F;path&#x2F;to&#x2F;extract –strip-components&#x3D;depth_to_strip<br>解压缩包获得文件</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>tar</p>
<p>Archiving utility.<br>Often combined with a compression method, such as gzip or bzip.<br>More information: <a target="_blank" rel="noopener" href="https://www.gnu.org/software/tar">https://www.gnu.org/software/tar</a>.</p>
<ul>
<li><p>Create an archive from files:<br>  tar cf target.tar file1 file2 file3</p>
</li>
<li><p>Create a gzipped archive:<br>  tar czf target.tar.gz file1 file2 file3</p>
</li>
<li><p>Create a gzipped archive from a directory using relative paths:<br>  tar czf target.tar.gz -C path&#x2F;to&#x2F;directory .</p>
</li>
<li><p>Extract a (compressed) archive into the current directory:<br>  tar xf source.tar[.gz|.bz2|.xz]</p>
</li>
<li><p>Extract an archive into a target directory:<br>  tar xf source.tar -C directory</p>
</li>
<li><p>Create a compressed archive, using archive suffix to determine the compression program:<br>  tar caf target.tar.xz file1 file2 file3</p>
</li>
<li><p>List the contents of a tar file:<br>  tar tvf source.tar</p>
</li>
<li><p>Extract files matching a pattern:<br>  tar xf source.tar –wildcards “*.html”</p>
</li>
<li><p>Extract a specific file without preserving the folder structure:<br>  tar xf source.tar source.tar&#x2F;path&#x2F;to&#x2F;extract –strip-components&#x3D;depth_to_strip<br>1.6 文件权限命令<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>chmod</p>
</li>
</ul>
<p>Change the access permissions of a file or directory.</p>
<ul>
<li><p>Give the [u]ser who owns a file the right to e[x]ecute it:<br>  chmod u+x file</p>
</li>
<li><p>Give the [u]ser rights to [r]ead and [w]rite to a file&#x2F;directory:<br>  chmod u+rw file_or_directory</p>
</li>
<li><p>Remove e[x]ecutable rights from the [g]roup:<br>  chmod g-x file</p>
</li>
<li><p>Give [a]ll users rights to [r]ead and e[x]ecute:<br>  chmod a+rx file</p>
</li>
<li><p>Give [o]thers (not in the file owner’s group) the same rights as the [g]roup:<br>  chmod o&#x3D;g file</p>
</li>
<li><p>Remove all rights from [o]thers:<br>  chmod o&#x3D; file</p>
</li>
<li><p>Change permissions recursively giving [g]roup and [o]thers the abililty to [w]rite:<br>  chmod -R g+w,o+w directory<br>1.7 其他命令<br>显示工作目录</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>pwd</p>
<p>Print name of current&#x2F;working directory.</p>
<ul>
<li><p>Print the current directory:<br>  pwd</p>
</li>
<li><p>Print the current directory, and resolve all symlinks (i.e. show the “physical” path):<br>  pwd -P<br>查看进程</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>ps</p>
<p>Information about running processes.</p>
<ul>
<li><p>List all running processes:<br>  ps aux</p>
</li>
<li><p>List all running processes including the full command string:<br>  ps auxww</p>
</li>
<li><p>Search for a process that matches a string:<br>  ps aux | grep string</p>
</li>
<li><p>List all processes of the current user in extra full format:<br>  ps –user $(id -u) -F</p>
</li>
<li><p>List all processes of the current user as a tree:<br>  ps –user $(id -u) f</p>
</li>
<li><p>Get the parent pid of a process:<br>  ps -o ppid&#x3D; -p pid<br>杀死进程</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>kill</p>
<p>Sends a signal to a process, usually related to stopping the process.<br>All signals except for SIGKILL and SIGSTOP can be intercepted by the process to perform a clean exit.</p>
<ul>
<li><p>Terminate a program using the default SIGTERM (terminate) signal:<br>  kill process_id</p>
</li>
<li><p>List available signal names (to be used without the <code>SIG</code> prefix):<br>  kill -l</p>
</li>
<li><p>Terminate a background job:<br>  kill %job_id</p>
</li>
<li><p>Terminate a program using the SIGHUP (hang up) signal. Many daemons will reload instead of terminating:<br>  kill -1|HUP process_id</p>
</li>
<li><p>Terminate a program using the SIGINT (interrupt) signal. This is typically initiated by the user pressing <code>Ctrl + C</code>:<br>  kill -2|INT process_id</p>
</li>
<li><p>Signal the operating system to immediately terminate a program (which gets no chance to capture the signal):<br>  kill -9|KILL process_id</p>
</li>
<li><p>Signal the operating system to pause a program until a SIGCONT (“continue”) signal is received:<br>  kill -17|STOP process_id</p>
</li>
<li><p>Send a <code>SIGUSR1</code> signal to all processes with the given GID (group id):<br>  kill -SIGUSR1 -group_id<br>搜索</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>grep</p>
<p>Matches patterns in input text.<br>Supports simple patterns and regular expressions.</p>
<ul>
<li><p>Search for an exact string:<br>  grep search_string path&#x2F;to&#x2F;file</p>
</li>
<li><p>Search in case-insensitive mode:<br>  grep -i search_string path&#x2F;to&#x2F;file</p>
</li>
<li><p>Search recursively (ignoring non-text files) in current directory for an exact string:<br>  grep -RI search_string .</p>
</li>
<li><p>Use extended regular expressions (supporting <code>?</code>, <code>+</code>, <code>&#123;&#125;</code>, <code>()</code> and <code>|</code>):<br>  grep -E ^regex$ path&#x2F;to&#x2F;file</p>
</li>
<li><p>Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:<br>  grep -C|B|A 3 search_string path&#x2F;to&#x2F;file</p>
</li>
<li><p>Print file name with the corresponding line number for each match:<br>  grep -Hn search_string path&#x2F;to&#x2F;file</p>
</li>
<li><p>Use the standard input instead of a file:<br>  cat path&#x2F;to&#x2F;file | grep search_string</p>
</li>
<li><p>Invert match for excluding specific strings:<br>  grep -v search_string<br>管道</p>
</li>
</ul>
<p>1<br>2<br>3<br>4<br>|      ##管道符<br>管道只允许正确输出通过<br> tee         ####复制一份输出<br>2&gt;&amp;1 |       ####转换错误输出为正确再通过管道<br>关机</p>
<p>1<br>poweroff<br>重启</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>reboot</p>
<p>Reboot the system.</p>
<ul>
<li><p>Reboot immediately:<br>  sudo reboot</p>
</li>
<li><p>Reboot immediately without gracefully shutting down:<br>  sudo reboot -q<br>二.Linux网络<br>2.1 网络服务<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>ifconfig</p>
</li>
</ul>
<p>Network Interface Configurator.</p>
<ul>
<li><p>View network settings of an ethernet adapter:<br>  ifconfig eth0</p>
</li>
<li><p>Display details of all interfaces, including disabled interfaces:<br>  ifconfig -a</p>
</li>
<li><p>Disable eth0 interface:<br>  ifconfig eth0 down</p>
</li>
<li><p>Enable eth0 interface:<br>  ifconfig eth0 up</p>
</li>
<li><p>Assign IP address to eth0 interface:<br>  ifconfig eth0 ip_address</p>
</li>
</ul>
<p>ip addr :CentOS7版本<br>修改网卡ip<br>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33<br>概要信息	<br>DEVICE&#x3D;ens33	网卡名称<br>TYPE&#x3D;Ethernet	网卡类型 以太网<br>ONBOOT&#x3D;yes	是否开机就使用此网卡<br>BOOTPROTO&#x3D;dhcp	启动网卡时指定获取IP地址的方式<br>IPADDR&#x3D;	ip地址<br>GATEWAY&#x3D;	网关<br>NETMASK&#x3D;255.255.255.0	子网掩码<br>DNS1&#x3D;	DNS服务器<br>重启网卡服务	<br>systemctl status network	查看指定服务的状态<br>systemctl stop network	停止指定服务<br>systemctl start network	启动指定服务<br>systemctl restart network	重启指定服务<br>2.2 防火墙服务<br>2.2.1 防火墙设置<br>防火墙设置	<br>开启防火墙	systemctl start firewalld<br>重启防火墙	systemctl restart firewalld<br>关闭防火墙	systemctl stop firewalld<br>设置开机启动	systemctl enable firewalld<br>停止并关闭开机启动	systemctl disable firewalld<br>查看防火墙状态	systemctl status firewalld 或者 firewall-cmd –state<br>查看防火墙开机时是否启动	systemctl list-unit-files | grep firewalld<br>2.2.2 端口设置<br>端口设置	<br>添加	firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent<br>更新防火墙规则	firewall-cmd –reload<br>查看	firewall-cmd –zone&#x3D;public –query-port&#x3D;80&#x2F;tcp<br>firewall-cmd –zone&#x3D;public –list-ports<br>删除	firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent<br>常用端口	8080 tomcat<br>80 http协议<br>443 https协议<br>22 ssh远程连接<br>3306 mysql<br>6379 redis<br>三.Nginx<br>3.1 介绍<br>Nginx是一款轻量级的 Web 服务器,由俄罗斯的程序设计师伊戈尔·西索夫所开发。 Nginx性能非常优秀, 官方测试能够支撑5万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。</p>
<p>Nginx的功能有很多，我们主要使用它来做静态资源服务器、负载均衡服务器和反向代理服务器。</p>
<p>3.2 应用场景<br>3.2.1 静态资源服务器<br>部署网站的静态资源(html、css、js),可与Tomcat等实现动静分离</p>
<p>3.2.2 反向代理服务器<br>代理</p>
<p>给某个对象提供一个代理对象，并由代理对象控制原对象的引用</p>
<p>正向代理</p>
<p>对客户端进行代理(例如VPN)</p>
<p>反向代理</p>
<p>对服务端进行代理</p>
<p>反向代理，就是对服务端进行代理，作为客户端,只需要将请求发送到反向代理服务器，由反向代理服务 器去选择目标服务器获取数据后，再响应给客户端，此时反向代理服务器和目标服务器对外就是一个服 务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<p>3.2.3 负载均衡服务器<br>负载均衡 Load Balance 意思就是将一份负载分摊到多个操作单元上进行执行</p>
<p>3.3 配置文件介绍(nginx-1.13.9&#x2F;conf&#x2F;nginx.conf)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>server {<br>    listen       80; #port<br>    server_name  localhost; #Server</p>
<pre><code>#charset koi8-r;

#access_log  logs/host.access.log  main;

location / &#123;
    root   html; #Static resource directory
    index  index.html index.htm; #Default visit page
&#125;
</code></pre>
<p>3.5 nginx与tomcat区别<br>存放的文件(资源)形式<br>Nginx是http服务器,只能解析静态文件</p>
<p>Tomcat是web中间件(本质上是一个servlet),能解析jsp和静态文件</p>
<p>用途</p>
<p>nginx可以作为反向代理服务器,负责均衡服务器,静态资源存放服务器</p>
<p>tomcat能作为jsp容器使用,静态资源存放服务器</p>
<p>性能</p>
<p>nginx支持5W+并发,tomcat的并发只能在200-400之间</p>
<p>总结</p>
<h1 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h1><h2 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>root</li>
</ul>
<p>​ - 超级管理员所在的目录</p>
<ul>
<li>home</li>
</ul>
<p>​ - 普通用户所在的目录</p>
<ul>
<li>usr</li>
</ul>
<p>​ - 安装用户文件所在的目录</p>
<ul>
<li>etc</li>
</ul>
<p>​ - Linux系统管理和配置文件所在的目录</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ul>
<li>查看</li>
</ul>
<p>​ - ll</p>
<p>​ - ls</p>
<ul>
<li>切换</li>
</ul>
<p>​ - cd</p>
<p>​ - 绝对路径</p>
<p>​ - 相对路径</p>
<ul>
<li>创建</li>
</ul>
<p>​ - mkdir -p</p>
<ul>
<li>修改&#x2F;剪切</li>
</ul>
<p>​ - mv</p>
<ul>
<li>复制</li>
</ul>
<p>​ - cp -r</p>
<ul>
<li>删除</li>
</ul>
<p>​ - rmdir -p</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>创建</li>
</ul>
<p>​ - touch</p>
<ul>
<li>查看</li>
</ul>
<p>​ - cat&#x2F;more&#x2F;less&#x2F;head&#x2F;tail</p>
<ul>
<li>删除</li>
</ul>
<p>​ - rm -rf</p>
<ul>
<li>编辑</li>
</ul>
<p>​ - vim</p>
<p>​ - 插入模式</p>
<p>​ - i</p>
<p>​ - 命令行模式</p>
<p>​ - esc</p>
<p>​ - 底行模式</p>
<p>​ - :</p>
<p>​ - wq!</p>
<p>​ - q!</p>
<h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><ul>
<li>打包</li>
</ul>
<p>​ - tar -zcvf</p>
<p>​ - xxxx.tar.gz</p>
<ul>
<li>解压缩</li>
</ul>
<p>​ - tar -zxvf</p>
<p>​ - xxxx.tar.gz</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul>
<li>chmod -R 777</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li>查看进程</li>
</ul>
<p>​ - ps -ef</p>
<ul>
<li>杀死进程</li>
</ul>
<p>​ - kill -9 PID</p>
<ul>
<li>文本搜索</li>
</ul>
<p>​ - grep -in</p>
<ul>
<li>管道</li>
</ul>
<p>​ - 一个命令的输出作为另一个命令的输入</p>
<h2 id="Linux网络"><a href="#Linux网络" class="headerlink" title="Linux网络"></a>Linux网络</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>查看ip</li>
</ul>
<p>​ - ifconfig</p>
<p>​ - ip addr</p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul>
<li>防火墙设置</li>
</ul>
<p>​ - 关闭</p>
<p>​ - systemctl stop firewalld</p>
<p>​ - 关闭开机自启动</p>
<p>​ - systemctl disable firewalld</p>
<ul>
<li>端口设置</li>
</ul>
<p>​ - 放行端口</p>
<p>​ - firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent</p>
<p>​ - 更新规则</p>
<p>​ - firewall-cmd –reload</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="由战斗民族开发的一款高性能的-http-服务器-x2F-反向代理服务器"><a href="#由战斗民族开发的一款高性能的-http-服务器-x2F-反向代理服务器" class="headerlink" title="由战斗民族开发的一款高性能的 http 服务器&#x2F;反向代理服务器"></a>由战斗民族开发的一款高性能的 http 服务器&#x2F;反向代理服务器</h3><ul>
<li><p>http服务器</p>
</li>
<li><p>反向代理（负载均衡）</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/20/Redis-%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Redis-%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Redis & 优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 01:39:59" itemprop="dateCreated datePublished" datetime="2020-05-20T01:39:59+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.NoSQL<br>1.1 NoSQL介绍<br>NoSQL(Not-Only SQL)，泛指非关系型的数据库，它可以作为关系型数据库的良好补充。</p>
<p>关系型数据库	非关系型数据库<br>特点	数据直接存在关联关系	数据之间没有关联关系<br>所有数据都在磁盘中	所有数据都在内存中<br>总结	存储复杂关系模型，硬盘io速度较慢	只能存储简单数据模型，内存io查询速度快<br>为什么学习NoSQL</p>
<p>高并发、高可用、高性能、海量数据</p>
<p>传统的关系型数据库出现了性能和扩展的瓶颈，所以非关系型数据库应时而生，解决了互联网产品的三 高和海量数据的问题</p>
<p>NoSQL和关系型的数据库是互补关系，在各自的应用场景中都有自己的特点，一般情况下我们使用关系 型数据库持久化数据(处理复杂的业务场景)，对一些热点数据通过NoSQL来作为缓存提高效率</p>
<p>使用后</p>
<p>先查找缓存<br>没有数据再查找数据库<br>1.2 NoSQL的主流产品<br>分类	特点	代表产品<br>键值存储	数据一般存在内存中，读写速度快(10w&#x2F;s)，适合作为缓存服务	redis<br>文档型数据库	数据结构要求不严格，适合存储结构不确定或者价值较低的数据	mongodb<br>列存储数据库	查找速度快，更容易进行分布式扩展，适合作为文件存储服务	Hbase<br>图形数据库	使用“图结构”进行存储，适合做社交网络计算等等	Neo4j<br>图形数据库介绍</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/79085901">https://blog.csdn.net/xlgen157387/article/details/79085901</a></p>
<p>二.Redis<br>2.1 Redis介绍<br>Redis(Remote Dictionary Server)是用C语言开发的一个开源的高性能键值对数据库。它的所有数据 都是保存在内存中的,这也就决定了其读写速度之快,是其它硬盘保存数据的系统所无法匹敌的。</p>
<p>官方曾经给出过一组测试数据，50个并发执行100000个请求: 读的速度是110000次&#x2F;s,写的速度是 81000次&#x2F;s</p>
<p>2.2 Redis安装和使用<br>下载</p>
<p>Reids官网地址:<a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io</a></p>
<p>中文网地址:<a target="_blank" rel="noopener" href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p>
<p>docker</p>
<p>docker pull redis</p>
<p>Linux</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>$ wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-6.0.3.tar.gz">http://download.redis.io/releases/redis-6.0.3.tar.gz</a><br>$ tar xzf redis-6.0.3.tar.gz<br>$ cd redis-6.0.3<br>$ make</p>
<p>$ src&#x2F;redis-server</p>
<p>$ src&#x2F;redis-cli<br>redis&gt; set foo bar<br>OK<br>redis&gt; get foo<br>“bar”<br>目录</p>
<p>redis.conf:配置文件</p>
<p>2.3 Redis客户端图形化工具<br>Redis Client 、Redis Desktop Manager 、Redis Studio.</p>
<p>2.4 Redis数据结构<br>Redis采用的键值对存储数据，键(key)的类型只能为字符串，值(value)支持五种数据类型:</p>
<p>K-V类型	key(字符串)	value(支持5种类型)<br>字符串：String	mystr	stringcode<br>哈希：HashMap	myhash	map集合(key:0),(value:100)<br>双向链表：LinkedList	mylist	左压栈—A-A–B–右压栈(有序且可重复)<br>无序集合：HashSet	myset	A|C|B|E|D (无序但不可重复)<br>有序集合：LinkedHashSet	myzset	A|B|C|D|E (有序但不可重复)<br>2.5 Redis命令操作<br>Redis命令是用来操作Redis数据库的, 就相当于操作MySql数据库时的SQL语句。</p>
<p>Redis的命令根据要操作的值(value)的数据结构的不同而不同, 每种数据类型都有自己的操作命令</p>
<p>2.5.1 String字符串<br>字符串类型是Redis中最为基础的数据存储类型。</p>
<p>在Redis中字符串类型的Value最多可以容纳的数据长度是512MB。</p>
<p>用法<br>新增	set key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL]<br>查询	get key<br>删除	del key [key …]<br>新增并指定存活时间	setex key seconds value<br>ttl key 查看存活时间<br>主键自增器	incr key (value默认加1)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>127.0.0.1:6379&gt; set mystr stringcode<br>OK<br>127.0.0.1:6379&gt; get mystr<br>“stringcode”<br>127.0.0.1:6379&gt; set mystr new_stringcode<br>OK<br>127.0.0.1:6379&gt; get mystr<br>“new_stringcode”<br>127.0.0.1:6379&gt; setex testcount 10 test10seconds<br>OK<br>127.0.0.1:6379&gt; ttl testcount<br>(integer) 5<br>127.0.0.1:6379&gt; get testcount<br>“test10seconds”<br>127.0.0.1:6379&gt; ttl testcount<br>(integer) -2<br>127.0.0.1:6379&gt; get testcount<br>(nil)<br>127.0.0.1:6379&gt;<br>2.5.2 Hash哈希<br>Hash类型极其类似于java中的Map,值里面可以存放一组组的键值对</p>
<p>该类型非常适合于存储java中对象的信息</p>
<p>用法<br>新增	hset key field value [field value …]<br>查询	hget key field<br>hgetall key<br>删除	hdel key field [field …]<br>del key [key …]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>127.0.0.1:6379&gt; hset user_1 name Jack<br>(integer) 1<br>127.0.0.1:6379&gt; hset user_1 age 18<br>(integer) 1<br>127.0.0.1:6379&gt; hget user_1 name<br>“Jack”<br>127.0.0.1:6379&gt; hgetall user_1</p>
<ol>
<li>“name”</li>
<li>“Jack”</li>
<li>“age”</li>
<li>“18”<br>127.0.0.1:6379&gt; hdel user_1 age<br>(integer) 1<br>127.0.0.1:6379&gt; hgetall user_1</li>
<li>“name”</li>
<li>“Jack”<br>127.0.0.1:6379&gt; del user_1<br>(integer) 1<br>127.0.0.1:6379&gt; keys *</li>
<li>“mystr”<br>127.0.0.1:6379&gt;<br>2.5.3 List列表<br>List类型底层是一个双向字符串链表。里面的元素是有序的，可重复的</li>
</ol>
<p>我们可以从链表的任何一端进行元素的增删</p>
<h1 id="redis的list是一个双向列表"><a href="#redis的list是一个双向列表" class="headerlink" title="redis的list是一个双向列表"></a>redis的list是一个双向列表</h1><p>b	<br>a<br>c<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>用法	<br>新增	lpush key element [element …]	将元素压入左侧顶端<br>rpush key element [element …]	将元素压入右侧顶端<br>查询	lrange key start stop	从左向右查询<br>0 -1 查看所有<br>删除	lpop key	将左侧顶端元素弹出<br>rpop key	将右侧顶端元素弹出<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>127.0.0.1:6379&gt; lpush mylist a<br>(integer) 1<br>127.0.0.1:6379&gt; lpush mylist b<br>(integer) 2<br>127.0.0.1:6379&gt; lpush mylist c<br>(integer) 3<br>127.0.0.1:6379&gt; lrange mylist 0 -1</p>
<ol>
<li>“c”</li>
<li>“b”</li>
<li>“a”<br>127.0.0.1:6379&gt; rpush mylist a<br>(integer) 4<br>127.0.0.1:6379&gt; lrange mylist 0 -1</li>
<li>“c”</li>
<li>“b”</li>
<li>“a”</li>
<li>“a”<br>127.0.0.1:6379&gt; lpop mylist<br>“c”<br>127.0.0.1:6379&gt; rpop mylist<br>“a”<br>127.0.0.1:6379&gt; lrange mylist 0 -1</li>
<li>“b”</li>
<li>“a”<br>127.0.0.1:6379&gt;<br>2.5.4 Set集合（无序）<br>Set类型底层是一张hash表。里面的元素是无序的，不可重复的</li>
</ol>
<p>用法	<br>新增	sadd key member [member …]	新增指定key元素<br>查询	smembers key	查询指定key元素<br>删除	srem key member [member …]	删除指定元素<br>del key [key …]	删除整个set集合<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>127.0.0.1:6379&gt; sadd myset a<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset b<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset c<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset f<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset e<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset d<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset a<br>(integer) 0<br>127.0.0.1:6379&gt; smembers myset</p>
<ol>
<li>“c”</li>
<li>“f”</li>
<li>“b”</li>
<li>“e”</li>
<li>“a”</li>
<li>“d”<br>127.0.0.1:6379&gt; srem myset a<br>(integer) 1<br>127.0.0.1:6379&gt; smembers myset</li>
<li>“c”</li>
<li>“f”</li>
<li>“b”</li>
<li>“e”</li>
<li>“d”<br>127.0.0.1:6379&gt; del myset<br>(integer) 1<br>127.0.0.1:6379&gt; smembers myset<br>(empty array)<br>127.0.0.1:6379&gt;<br>2.5.5 ZSet集合（有序）<br>Zset,也称sortedSet, 在Set的基础上，加入了有序功能，在添加元素的时候，允许指定一个分数，它会 按照这个分数排序</li>
</ol>
<p>用法	<br>新增	zadd key [NX | XX] [CH] [INCR] score member [score member …]	新增指定key元素<br>查询	zrange key start stop [WITHSCORES]	升序<br>zrevrange key start stop [WITHSCORES]	降序<br>删除	zrem key member [member …]	删除指定元素<br>del key [key …]	删除整个zset集合<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>127.0.0.1:6379&gt; zadd myzset 10 aaaaa<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myzset 30 bbbbb<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myzset 20 ccccc<br>(integer) 1<br>127.0.0.1:6379&gt; zrange myzset 0 100</p>
<ol>
<li>“aaaaa”</li>
<li>“ccccc”</li>
<li>“bbbbb”<br>127.0.0.1:6379&gt; zrange myzset 0 100 withscores</li>
<li>“aaaaa”</li>
<li>“10”</li>
<li>“ccccc”</li>
<li>“20”</li>
<li>“bbbbb”</li>
<li>“30”<br>127.0.0.1:6379&gt; zrevrange myzset 0 100</li>
<li>“bbbbb”</li>
<li>“ccccc”</li>
<li>“aaaaa”<br>127.0.0.1:6379&gt; zrevrange myzset 0 100 withscores</li>
<li>“bbbbb”</li>
<li>“30”</li>
<li>“ccccc”</li>
<li>“20”</li>
<li>“aaaaa”</li>
<li>“10”<br>127.0.0.1:6379&gt; zrem myzset aaaaa<br>(integer) 1<br>127.0.0.1:6379&gt; zrevrange myzset 0 100</li>
<li>“bbbbb”</li>
<li>“ccccc”<br>127.0.0.1:6379&gt; del myzset<br>(integer) 1<br>127.0.0.1:6379&gt; zrevrange myzset 0 100<br>(empty array)<br>127.0.0.1:6379&gt;<br>2.5.6 通用命令<br>命令<br>模糊查询键	keys *<br>删除多个键	del key [key …]<br>根据键判断记录是否存在	exists key[key …]<br>根据键判断值类型	type key<br>选择数据库	select index (0~15)<br>清空当前数据库	flushdb [ASYNC]<br>清空所有数据库	flushall [ASYNC]<br>2.6 Redis持久化<br>Redis的数据都是存在在内存之中的，那么这样一旦出现宕机，势必会导致数据的丢失，这就需要持久化操作，也就是要将redis在内存中的数据写到硬盘上保存。</li>
</ol>
<p>注意，redis虽然有持久化操作，但是其全部数据依旧都在内存中存在,也就是说硬盘上的只是为了安全和备份。</p>
<p>Redis提供了两种数据持久化的方式，分别是 RDB 和 AOF</p>
<p>RDB:默认开启</p>
<p>在redis运行期间，根据指定时间节点对内存的数据进行快照拍摄，持久化到磁盘文件(dump.rdb文件) 指定时间规则拍摄快照</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>cat redis.conf | tail -n +265 | head -n 25    </p>
<p>################################ SNAPSHOTTING  ################################<br>#</p>
<h1 id="Save-the-DB-on-disk"><a href="#Save-the-DB-on-disk" class="headerlink" title="Save the DB on disk:"></a>Save the DB on disk:</h1><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="save"><a href="#save" class="headerlink" title="save  "></a>save <seconds> <changes></changes></seconds></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h1 id="Will-save-the-DB-if-both-the-given-number-of-seconds-and-the-given"><a href="#Will-save-the-DB-if-both-the-given-number-of-seconds-and-the-given" class="headerlink" title="Will save the DB if both the given number of seconds and the given"></a>Will save the DB if both the given number of seconds and the given</h1><h1 id="number-of-write-operations-against-the-DB-occurred"><a href="#number-of-write-operations-against-the-DB-occurred" class="headerlink" title="number of write operations against the DB occurred."></a>number of write operations against the DB occurred.</h1><h1 id="-2"><a href="#-2" class="headerlink" title></a></h1><h1 id="In-the-example-below-the-behaviour-will-be-to-save"><a href="#In-the-example-below-the-behaviour-will-be-to-save" class="headerlink" title="In the example below the behaviour will be to save:"></a>In the example below the behaviour will be to save:</h1><h1 id="after-900-sec-15-min-if-at-least-1-key-changed"><a href="#after-900-sec-15-min-if-at-least-1-key-changed" class="headerlink" title="after 900 sec (15 min) if at least 1 key changed"></a>after 900 sec (15 min) if at least 1 key changed</h1><h1 id="after-300-sec-5-min-if-at-least-10-keys-changed"><a href="#after-300-sec-5-min-if-at-least-10-keys-changed" class="headerlink" title="after 300 sec (5 min) if at least 10 keys changed"></a>after 300 sec (5 min) if at least 10 keys changed</h1><h1 id="after-60-sec-if-at-least-10000-keys-changed"><a href="#after-60-sec-if-at-least-10000-keys-changed" class="headerlink" title="after 60 sec if at least 10000 keys changed"></a>after 60 sec if at least 10000 keys changed</h1><h1 id="-3"><a href="#-3" class="headerlink" title></a></h1><h1 id="Note-you-can-disable-saving-completely-by-commenting-out-all-“save”-lines"><a href="#Note-you-can-disable-saving-completely-by-commenting-out-all-“save”-lines" class="headerlink" title="Note: you can disable saving completely by commenting out all “save” lines."></a>Note: you can disable saving completely by commenting out all “save” lines.</h1><h1 id="-4"><a href="#-4" class="headerlink" title></a></h1><h1 id="It-is-also-possible-to-remove-all-the-previously-configured-save"><a href="#It-is-also-possible-to-remove-all-the-previously-configured-save" class="headerlink" title="It is also possible to remove all the previously configured save"></a>It is also possible to remove all the previously configured save</h1><h1 id="points-by-adding-a-save-directive-with-a-single-empty-string-argument"><a href="#points-by-adding-a-save-directive-with-a-single-empty-string-argument" class="headerlink" title="points by adding a save directive with a single empty string argument"></a>points by adding a save directive with a single empty string argument</h1><h1 id="like-in-the-following-example"><a href="#like-in-the-following-example" class="headerlink" title="like in the following example:"></a>like in the following example:</h1><h1 id="-5"><a href="#-5" class="headerlink" title></a></h1><h1 id="save-“”"><a href="#save-“”" class="headerlink" title="save “”"></a>save “”</h1><p>#1个key修改，15min后拍摄一次快照<br>save 900 1<br>#10个key修改，5min后拍摄一次快照<br>save 300 10<br>#10000个key修改，1min后拍摄一次快照<br>save 60 10000<br>AOF:默认关闭，需要手动开启</p>
<p>在redis运行期间，以日志记录的方式监听set操作，持久化到磁盘文件(appendonly.aof)</p>
<p>开启AOF:修改 redis.conf配置</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>cat redis.conf | tail -n +1018 | head -n 53          </p>
<p>############################## APPEND ONLY MODE ###############################</p>
<p>……</p>
<h1 id="Please-check-http-redis-io-topics-persistence-for-more-information"><a href="#Please-check-http-redis-io-topics-persistence-for-more-information" class="headerlink" title="Please check http://redis.io/topics/persistence for more information."></a>Please check <a target="_blank" rel="noopener" href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a> for more information.</h1><p>#若开启设置为yes<br>appendonly no</p>
<h1 id="The-name-of-the-append-only-file-default-“appendonly-aof”"><a href="#The-name-of-the-append-only-file-default-“appendonly-aof”" class="headerlink" title="The name of the append only file (default: “appendonly.aof”)"></a>The name of the append only file (default: “appendonly.aof”)</h1><p>appendfilename “appendonly.aof”</p>
<h1 id="The-fsync-call-tells-the-Operating-System-to-actually-write-data-on-disk"><a href="#The-fsync-call-tells-the-Operating-System-to-actually-write-data-on-disk" class="headerlink" title="The fsync() call tells the Operating System to actually write data on disk"></a>The fsync() call tells the Operating System to actually write data on disk</h1><h1 id="instead-of-waiting-for-more-data-in-the-output-buffer-Some-OS-will-really-flush"><a href="#instead-of-waiting-for-more-data-in-the-output-buffer-Some-OS-will-really-flush" class="headerlink" title="instead of waiting for more data in the output buffer. Some OS will really flush"></a>instead of waiting for more data in the output buffer. Some OS will really flush</h1><h1 id="data-on-disk-some-other-OS-will-just-try-to-do-it-ASAP"><a href="#data-on-disk-some-other-OS-will-just-try-to-do-it-ASAP" class="headerlink" title="data on disk, some other OS will just try to do it ASAP."></a>data on disk, some other OS will just try to do it ASAP.</h1><h1 id="-6"><a href="#-6" class="headerlink" title></a></h1><p>……</p>
<p>#日志持久化机制</p>
<p>#每次执行set操作时都会持久化一次</p>
<h1 id="appendfsync-always"><a href="#appendfsync-always" class="headerlink" title="appendfsync always"></a>appendfsync always</h1><p>#每秒持久化一次<br>appendfsync everysec</p>
<p>#根据服务器，cpu处于idle情况，持久化一次</p>
<h1 id="appendfsync-no"><a href="#appendfsync-no" class="headerlink" title="appendfsync no"></a>appendfsync no</h1><p>2.6.1 知识小结<br>这二种持久化机制可以共存</p>
<p>RDB:把redis作为缓存来用	AOF:把redis作为独立数据库<br>优点	性能高	几乎不会丢失数据<br>缺点	可能会丢失部分数据	性能较差<br>2.7 应用场景<br>2.7.1 缓存<br>将一些经常访问但又不会经常修改的数据，进行缓存，提高查询效率</p>
<p>2.7.2 秒杀<br>浏览器	➡秒杀	redis服务器	➡同步	MySQL<br>商品		扣库存		同步数据<br>生成订单		<br>支付发货		<br>2.7.3 微博热搜<br>微博app	➡	redis<br>微博热搜		ZSet评分有序集合<br>2.7.4 分布式session<br>User	➡	Tomcat服务器	➡	redis<br>第一次访问	Server_1	设置	<br>User				User<br>第二次访问	Server_2	查询	<br>2.7.5 验证码存储<br>网站	➡	redis<br>发送短信		手机号:6位随机验证码<br>精准控制session只有5min<br>三.Jedis<br>3.1 Jedis使用<br>Redis作为一款优秀的缓存服务器存在，大多数语言都提供了连接Redis的驱动包，在java中，比较出名</p>
<p>的是Jedis和Redisson，我们今天以Jedis为例学习，看看如何是用程序操作redis。</p>
<p>常用API</p>
<p>方法	解释<br>new Jedis(host, port)	创建jedis对象，参数host是redis服务器地址，参数port是redis服务端口<br>set(key,value)	设置字符串类型的数据<br>get(key)	获得字符串类型的数据<br>hset(key,field,value)	设置哈希类型的数据<br>hget(key,field)	获得哈希类型的数据<br>lpush(key,values)	设置列表类型的数据<br>lpop(key)	列表左面弹栈<br>rpop(key)	列表右面弹栈<br>del(key)	删除指定的key<br>快速入门</p>
<p>导入相关坐标</p>
<p>1<br>2<br>3<br>4<br>5<br>6</p>
<!--jedis-->
<dependency>
  <groupId>redis.clients</groupId>
  <artifactId>jedis</artifactId>
  <version>2.9.0</version>
</dependency>
编写代码

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>public class JedisTest {</p>
<p>  &#x2F;&#x2F; 快速入门之，向redis设置string类型的数据<br>  @Test<br>  public void testSet() throws Exception{<br>    &#x2F;&#x2F; 1.创建连接对象<br>    &#x2F;&#x2F; 默认连接 127.0.0.1 主机 和 6379 端口<br>    Jedis jedis &#x3D; new Jedis();<br>    &#x2F;&#x2F; 2.调用set方法设置数据<br>    jedis.set(“Java”, “Hello,World”);<br>    &#x2F;&#x2F; 3.释放资源<br>    jedis.close();<br>  }</p>
<p>  &#x2F;&#x2F; 快速入门之，查询string类型数据<br>  @Test<br>  public void testQuery() throws Exception{<br>    &#x2F;&#x2F; 1.创建连接对象<br>    Jedis jedis &#x3D; new Jedis();<br>    &#x2F;&#x2F; 2.调用get方法获取<br>    String java &#x3D; jedis.get(“Java”);<br>    System.out.println(java);<br>    &#x2F;&#x2F; 3.释放资源<br>    jedis.close();<br>  }<br>}<br>3.2 Jedis连接池<br>jedis连接资源的创建与销毁是非常消耗性能的，所以我们不希望频繁的创建和销毁它.基于这样的需求,就有了JedisPool技术。</p>
<p>快速入门</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>public class JedisPoolTest {<br>  &#x2F;&#x2F; 测试jedis内置的连接池<br>  @Test<br>  public void testJedisPool() throws Exception {</p>
<pre><code>// 0.连接池配置对象
JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
// 最大连接数
jedisPoolConfig.setMaxTotal(100);
// 最大等待时间，单位是毫秒
jedisPoolConfig.setMaxWaitMillis(3000);
// 最大空闲连接数
jedisPoolConfig.setMaxIdle(10);

// 1.创建连接池对象
JedisPool jedisPool = new JedisPool();

// 2.从池中获取连接
Jedis jedis = jedisPool.getResource();

// 3.操作api
jedis.hset(&quot;myhash&quot;, &quot;id&quot;, &quot;1&quot;);

// 4.归还到连接池
jedis.close();
</code></pre>
<p>  }<br>}<br>抽取为连接池工具类</p>
<p>1<br>2<br>3<br>4<br>jedis.host&#x3D;localhost<br>jedis.port&#x3D;6379<br>jedis.maxTotal&#x3D;20<br>jedis.maxIdle&#x3D;10<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>public class JedisUtils {</p>
<p>  private static JedisPool jedisPool;</p>
<p>  private static String host;<br>  private static Integer port;<br>  private static Integer maxTotal;<br>  private static Integer maxIdle;</p>
<p>  &#x2F;&#x2F; 初始化连接池<br>  static {<br>    try {</p>
<pre><code>  ResourceBundle jedis = ResourceBundle.getBundle(&quot;jedis&quot;);

  // 读取配置文件给变量赋值
  // 获取类加载读取 jedis.properties 获取io流
  InputStream is = JedisUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);
  // 创建properties对象 加载io流
  Properties properties = new Properties();
  properties.load(is);
  // 给变量赋值
  host = properties.getProperty(&quot;jedis.host&quot;);
  port = Integer.parseInt(properties.getProperty(&quot;jedis.port&quot;));
  maxTotal = Integer.parseInt(properties.getProperty(&quot;jedis.maxTotal&quot;));
  maxIdle = Integer.parseInt(properties.getProperty(&quot;jedis.maxIdle&quot;));

  // 创建连接池配置对象
  JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
  jedisPoolConfig.setMaxTotal(maxTotal);
  jedisPoolConfig.setMaxIdle(maxIdle);
  // 创建连接池对象
  jedisPool = new JedisPool(jedisPoolConfig, host, port);
&#125; catch (IOException e) &#123;
  e.printStackTrace();
&#125;
</code></pre>
<p>  }</p>
<p>  &#x2F;&#x2F; 提供获取jedis连接的方法<br>  public static Jedis getJedis() {<br>    return jedisPool.getResource();<br>  }<br>}<br>四.<br>4.1 缓存：导航条分类<br>4.1.1 需求分析<br>前端页面	➡	JavaServer	➡	SQL<br>首页 门票 周边游		CategroyService	➡	NoSQL<br>先查询缓存(redis)，有就直接返回		redis<br>没有，再查MySQL，先同步到redis再返回	➡	MySQL<br>List<Categroy> list;<br>将list转为json数组字符串返回		<br>4.1.2 代码实现<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>public class CategoryServiceImpl implements CategoryService {<br>  @Override<br>  public List<Category> findAll() {</Category></Categroy></p>
<pre><code>//        SqlSession sqlSession = MyBatisUtils.openSession();
//        CategoryDao categoryDao = sqlSession.getMapper(CategoryDao.class);
//
//        List&lt;Category&gt; categoryList = categoryDao.findAll();
//
//        MyBatisUtils.close(sqlSession);

List&lt;Category&gt; categoryList = null;
ObjectMapper objectMapper = new ObjectMapper();

Jedis jedis = JedisUtils.getJedis();

if (jedis.exists(&quot;travel_category&quot;)) &#123;
  String json = jedis.get(&quot;travel_category&quot;);

  try &#123;
    categoryList = objectMapper.readValue(json, List.class);
    System.out.println(&quot;Find In Redis&quot;);
  &#125; catch (IOException e) &#123;
    e.printStackTrace();
  &#125;
&#125; else &#123;
  SqlSession sqlSession = MyBatisUtils.openSession();
  CategoryDao categoryDao = sqlSession.getMapper(CategoryDao.class);

  categoryList = categoryDao.findAll();

  MyBatisUtils.close(sqlSession);

  try &#123;
    String json = objectMapper.writeValueAsString(categoryList);
    jedis.set(&quot;travel_category&quot;, json);
  &#125; catch (IOException e) &#123;
    e.printStackTrace();
  &#125;

&#125;
jedis.close();


return categoryList;
</code></pre>
<p>  }<br>}<br>4.2 短信验证码存活时间5分钟<br>4.2.1 需求分析</p>
<p>4.2.2 代码实现<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>protected void sendSms(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {<br>  &#x2F;&#x2F; 1.获取请求参数<br>  String telephone &#x3D; req.getParameter(“telephone”);<br>  &#x2F;&#x2F; 2.生成6位随机数(apache提供的)<br>  String smsCode &#x3D; RandomStringUtils.randomNumeric(6);<br>  &#x2F;&#x2F; 3.调用service完成短信发送，返回resultInfo<br>  ResultInfo resultInfo &#x3D; userService.sendSms(telephone, smsCode);</p>
<p>  &#x2F;&#x2F; 4.如果发送成功，将验证码写入到session中<br>  &#x2F;&#x2F;        if (resultInfo.getSuccess()) {<br>  &#x2F;&#x2F;            req.getSession().setAttribute(“smsCode_” + telephone, smsCode);<br>  &#x2F;&#x2F;            System.out.println(“smsCode: “ + smsCode);<br>  &#x2F;&#x2F;        }</p>
<p>  &#x2F;&#x2F; 4.如果发送成功，将验证码写入到session中<br>  if (resultInfo.getSuccess()) {</p>
<pre><code>// a.获取jedis连接
Jedis jedis = JedisUtils.getJedis();

// b.将验证码设置到jedis中，存活1分钟
jedis.setex(&quot;smsCode_&quot; + telephone, 60, smsCode);

// c.释放资源
jedis.close();
System.out.println(&quot;smsCode: &quot; + smsCode);
</code></pre>
<p>  }<br>  javaToJsonWriteClient(resultInfo, resp);</p>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>protected void register(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {</p>
<p>  &#x2F;&#x2F; a.获取请求参数<br>  String telephone &#x3D; req.getParameter(“telephone”);<br>  String smsCode &#x3D; req.getParameter(“smsCode”);</p>
<p>  &#x2F;&#x2F; b.获取session中验证码<br>  &#x2F;&#x2F;        String sessionCode &#x3D; (String) req.getSession().getAttribute(“smsCode_” + telephone);</p>
<p>  Jedis jedis &#x3D; JedisUtils.getJedis();<br>  String sessionCode &#x3D; jedis.get(“smsCode_” + telephone);</p>
<p>  &#x2F;&#x2F; c.进行校验<br>  if (sessionCode &#x3D;&#x3D; null || (!sessionCode.equals(smsCode))) {</p>
<pre><code>// 验证码不正确
req.setAttribute(&quot;resultInfo&quot;, new ResultInfo(false, &quot;SMS Code not correct&quot;));
req.getRequestDispatcher(&quot;/register.jsp&quot;).forward(req, resp);
return;
</code></pre>
<p>  }</p>
<p>  &#x2F;&#x2F;获取请求参数<br>  Map&lt;String, String[]&gt; parameterMap &#x3D; req.getParameterMap();</p>
<p>  &#x2F;&#x2F;封装User中<br>  User param &#x3D; new User();</p>
<p>  try {<br>    BeanUtils.populate(param, parameterMap);<br>  } catch (Exception e) {<br>    throw new RuntimeException(“Entity class encapsulation failed”);<br>  }</p>
<p>  &#x2F;&#x2F;调用service，实现注册<br>  ResultInfo resultInfo &#x3D; userService.register(param);</p>
<p>  if (resultInfo.getSuccess()) {<br>    resp.sendRedirect(req.getContextPath() + “&#x2F;register_ok.jsp”);<br>    &#x2F;&#x2F;            req.getSession().removeAttribute(“smsCode_” + telephone);<br>    &#x2F;&#x2F; d.升级为，清除redis<br>    jedis.del(“smsCode” + telephone);<br>  } else {<br>    req.setAttribute(“resultInfo”, resultInfo);<br>    req.getRequestDispatcher(“&#x2F;register.jsp”).forward(req, resp);<br>  }<br>  jedis.close();<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>protected void telLogin(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>  &#x2F;&#x2F; 1.接收请求参数telephone<br>  String telephone &#x3D; req.getParameter(“telephone”);</p>
<p>  &#x2F;&#x2F; 2.调用service查询<br>  User currentUser &#x3D; userService.findByTelephone(telephone);</p>
<p>  &#x2F;&#x2F; 3.校验手机号<br>  ResultInfo resultInfo &#x3D; null;</p>
<p>  &#x2F;&#x2F; 4.3 校验<br>  if (currentUser &#x3D;&#x3D; null) {<br>    resultInfo &#x3D; new ResultInfo(false, “Phone Number not Registered”);<br>  } else {<br>    &#x2F;&#x2F;成功<br>    String smsCode &#x3D; req.getParameter(“smsCode”);</p>
<pre><code>//            String sessionCode = (String) req.getSession().getAttribute(&quot;smsCode_&quot; + telephone);

// 升级为从redis中获取
Jedis jedis = JedisUtils.getJedis();
String sessionCode = jedis.get(&quot;smsCode_&quot; + telephone);

if (sessionCode == null || (!sessionCode.equals(smsCode))) &#123;
  resultInfo = new ResultInfo(false, &quot;Wrong SMS Code&quot;);
&#125; else &#123;
  req.getSession().setAttribute(&quot;currentUser&quot;, currentUser);
  // 清除session中验证码
  resultInfo = new ResultInfo(true, &quot;Login Success&quot;);

  //req.getSession().removeAttribute(&quot;smsCode_&quot; + telephone);
  // 清除redis中验证码
  jedis.del(&quot;smsCode_&quot; + telephone);
&#125;
// 释放资源
jedis.close();
</code></pre>
<p>  }<br>  &#x2F;&#x2F;将resultInfo转为Json响应到客户端<br>  javaToJsonWriteClient(resultInfo, resp);<br>}<br>总结</p>
<h2 id="一-NoSQL"><a href="#一-NoSQL" class="headerlink" title="一 NoSQL"></a>一 NoSQL</h2><h3 id="非关系型数据库，not-only-sql，弥补关系型数据库一些不足"><a href="#非关系型数据库，not-only-sql，弥补关系型数据库一些不足" class="headerlink" title="非关系型数据库，not only sql，弥补关系型数据库一些不足"></a>非关系型数据库，not only sql，弥补关系型数据库一些不足</h3><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>关系性</li>
</ul>
<p>​ - 1）数据之间存在关联关系</p>
<p>​ - 2）数据存储在硬盘</p>
<ul>
<li>非关系型</li>
</ul>
<p>​ - 1）数据之间不存在关联关系</p>
<p>​ - 2）数据存储在内存</p>
<h3 id="解决：互联和行业特点"><a href="#解决：互联和行业特点" class="headerlink" title="解决：互联和行业特点"></a>解决：互联和行业特点</h3><ul>
<li><p>高并发</p>
</li>
<li><p>高性能</p>
</li>
<li><p>高可用</p>
</li>
<li><p>海量数据</p>
</li>
</ul>
<h3 id="nosql分类"><a href="#nosql分类" class="headerlink" title="nosql分类"></a>nosql分类</h3><ul>
<li>键值对</li>
</ul>
<p>​ - redis</p>
<ul>
<li>文档类型（json）</li>
</ul>
<p>​ - mongoDB</p>
<ul>
<li>列存储</li>
</ul>
<p>​ - hbase</p>
<ul>
<li>图形（关系结构）</li>
</ul>
<h2 id="二-Redis"><a href="#二-Redis" class="headerlink" title="二 Redis"></a>二 Redis</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>C语言编写高性能键值对数据库</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>string</p>
</li>
<li><p>hash</p>
</li>
<li><p>linkedList</p>
</li>
<li><p>hashset</p>
</li>
<li><p>linkedHashSet</p>
</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>字符串</li>
</ul>
<p>​ - set key value</p>
<p>​ - get key</p>
<p>​ - del key</p>
<p>​ - setex key 存活时间 value</p>
<p>​ - incr key</p>
<p>​ - value+1</p>
<ul>
<li>哈希</li>
</ul>
<p>​ - hset key hkey hvalue</p>
<p>​ - hget key hkey</p>
<p>​ - hgetall key</p>
<p>​ - hrem key hkey</p>
<p>​ - del key</p>
<ul>
<li>列表</li>
</ul>
<p>​ - lpush key value</p>
<p>​ - rpush key value</p>
<p>​ - lrange key 0 -1</p>
<p>​ - lpop key</p>
<p>​ - rpop key</p>
<p>​ - del key</p>
<ul>
<li>集合</li>
</ul>
<p>​ - sadd key value</p>
<p>​ - smembers key</p>
<p>​ - srem key value</p>
<ul>
<li>有序集合</li>
</ul>
<p>​ - zadd key score value</p>
<p>​ - zrange key 0 -1 withscores</p>
<p>​ - zrevrange key 0 -1 withscores</p>
<p>​ - zrem key value</p>
<ul>
<li>通用命令</li>
</ul>
<p>​ - keys *</p>
<p>​ - del key1 key2 key3</p>
<p>​ - exists key</p>
<p>​ - type key</p>
<p>​ - select 0~15</p>
<p>​ - flushdb</p>
<p>​ - flushal</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li>RDB</li>
</ul>
<p>​ - 默认开启，在指定间隔时间将内存的数据拍摄快照，持久化到磁盘</p>
<p>​ - 1）优点：性能高</p>
<p>​ - 2）缺点：丢失数据</p>
<ul>
<li>AOF</li>
</ul>
<p>​ - 手动开启，根据日志记录方式监听redis的写（set）操作，持久化到磁盘</p>
<p>​ - 1）优点：保证数据的安全</p>
<p>​ - 2）缺点：性能稍差</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>1）缓存</p>
</li>
<li><p>2）秒杀</p>
</li>
<li><p>3）微博热搜</p>
</li>
<li><p>4）验证码存储</p>
</li>
<li><p>5）分布式session</p>
</li>
</ul>
<h2 id="三-Jedis"><a href="#三-Jedis" class="headerlink" title="三 Jedis"></a>三 Jedis</h2><h3 id="通过java语言操作redis，api与redis命令相似"><a href="#通过java语言操作redis，api与redis命令相似" class="headerlink" title="通过java语言操作redis，api与redis命令相似"></a>通过java语言操作redis，api与redis命令相似</h3><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul>
<li><p>1）导入jar坐标</p>
</li>
<li><p>2）编写代码</p>
</li>
</ul>
<p>​ - &#x2F;&#x2F;1.创建连接对象</p>
<p>​ - &#x2F;&#x2F;2.操作api</p>
<p>​ - &#x2F;&#x2F;3.关闭连接</p>
<h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/14/Maven%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/Maven%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Maven基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 01:39:29" itemprop="dateCreated datePublished" datetime="2020-05-14T01:39:29+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Maven简介<br>1.1 Maven是什么<br>Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM:Project Object Model)，一组标准集合，一个项 目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周 期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p>
<p>1.2 Maven能解决什么问题<br>一种工具，可以构建工程，管理 jar包，编译代码，还 能帮你自动运行单元测试，打包，生成报表，部署项目，生成 Web 站点。</p>
<p>1.3 Maven的两个核心功能<br>1.3.1 依赖管理<br>Maven的一个核心特性就是依赖管理。MVN依赖管理，就是一个管理jar包的过程</p>
<p>CRM项目<br>使用mvn工程实现	➡项目中给定坐标，去仓库拉取jar包➡<br>索引的存在，使拉取jar包过程，可以认为是自己项目中有的	MVN仓库<br>jar的仓库<br>坐标:将来要找某个jar包，就是要确定这个jar包的坐标	<br>jar包如何给出坐标:公司&#x2F;组织名+项目名+版本号一起确定	<br>maven工程中不直接将jar包导入到工程中，而是通过在pom.xml文件中添加所需jar包的坐标，避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库)中根据坐标从而找到这些jar包，再把这些jar包拿去运行。</p>
<p>通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢</p>
<p>通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。</p>
<p>1.3.2 项目构建<br>什么是项目构建</p>
<p>项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建。</p>
<p>一键构建 指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。</p>
<p>Maven规范化构建流程</p>
<p>清理	➡	编译	➡	测试	➡	报告	➡	打包	➡	部署<br>二 Maven安装和使用<br>2.1 Maven下载和安装<br>2.1.1 Maven下载<br>Maven官网下载地址:<a target="_blank" rel="noopener" href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></p>
<p>目前使用@3.5版本</p>
<p>2.1.2 Maven安装<br>将apache-maven-3.5.2-bin.zip解压并添加至path</p>
<p>maven目录结构</p>
<p>目录	介绍<br>bin	存放了 maven 的命令<br>boot	存放了一些 maven 本身的引导程序，如类加载器等<br>conf	存放了 maven 的一些配置文件，如 setting.xml 文件<br>lib	存放了 maven 本身运行所需的一些 jar 包<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>apache-maven-3.5.2<br>├── LICENSE<br>├── NOTICE<br>├── README.txt<br>├── bin<br>│   ├── m2.conf<br>│   ├── mvn<br>│   ├── mvn.cmd<br>│   ├── mvnDebug<br>│   ├── mvnDebug.cmd<br>│   └── mvnyjp<br>├── boot<br>│   └── plexus-classworlds-2.5.2.jar<br>├── conf<br>│   ├── logging<br>│   ├── settings.xml<br>│   └── toolchains.xml<br>└── lib<br>    ├── aopalliance-1.0.jar<br>        ├── …省略<br>    └── wagon-provider-api.license</p>
<p>7 directories, 91 files<br>2.1.3 Maven及JDK配置<br>Maven 3.3+ require JDK 1.7 or above to execute - they still allow you to build against 1.3 and other JDK versions by Using Toolchains</p>
<p>配置PATH</p>
<p>1<br>2<br>3<br>4<br>5<br>vi .zshrc</p>
<p>#MAVEN_HOME<br>export MAVEN_HOME&#x3D;&#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;apache-maven-3.5.2<br>export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin<br>2.1.4 Maven软件版本测试<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br> ~ #mvn -v<br>Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)<br>Maven home: &#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;apache-maven-3.5.2<br>Java version: 1.8.0_221, vendor: Oracle Corporation<br>Java home: &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_221.jdk&#x2F;Contents&#x2F;Home&#x2F;jre<br>Default locale: en_CN, platform encoding: UTF-8<br>OS name: “mac os x”, version: “10.15.4”, arch: “x86_64”, family: “mac”<br>2.3 Maven仓库<br>2.3.1 Maven仓库的分类<br>Maven仓库分为本地仓库和远程仓库二大类。而远程仓库又可分成中央仓库，私服，第三方仓库。</p>
<p>Maven仓库	<br>本地仓库		远程仓库<br>⬇<br>中央仓库<br>私服<br>第三方公共库<br>依赖寻找流程</p>
<p>在本地仓库中，根据Maven坐标系寻找指定依赖，如果存在，直接返回。</p>
<p>如果Maven仓库中不存在，或者需要检查依赖的版本时，maven则会去远程仓库中寻找，下载到本地仓库中再使 用。</p>
<p>本地仓库</p>
<p>用来存储从远程仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找。</p>
<p>中央仓库</p>
<p>在maven软件中内置一个远程仓库地址<a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。</p>
<p>第三方公共库</p>
<p>Maven 仓库默认中央仓库在国外且只有一个， 国内使用难免很慢，我们可以更换为第三方公共库，例如:阿里云镜 像。</p>
<p>私服</p>
<p>私服是一种特殊的远程仓库，其内容是来自于其他的远程仓库，一般架设在局域网内，提供给一个组织的人员使用。 当Maven需要下载依赖时，从私服请求，如果私服上不存在该依赖，则从其他远程仓库下载，同时缓存在私服上，提 供给其他人使用。如果项目中的一些内部模块，无法发布到外部远程仓库中，也可发布在私服上，提供给项目中的其 他人员使用。</p>
<p>2.3.2 Maven本地仓库的配置<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>cd  $MAVEN_HOME&#x2F;conf<br>vi settings.xml</p>
<h1 id="找到"><a href="#找到" class="headerlink" title="找到"></a>找到</h1><p><settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"><br>  <!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: ${user.home}/.m2/repository
  <localRepository>/path/to/local/repo</localRepository>
  --><br>  将<localRepository>&#x2F;path&#x2F;to&#x2F;local&#x2F;repo</localRepository>改为本地仓库路径添加到注释后<br>2.3.4 Maven仓库国内镜像配置<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br><mirrors><br>  <!-- mirror
   | Specifies a repository mirror site to use instead of a given repository. The repository that
   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
   |
  <mirror>
    <id>mirrorId</id>
    <mirrorOf>repositoryId</mirrorOf>
    <name>Human Readable Name for this Mirror.</name>
    <url>http://my.repository.com/repo/path</url>
  </mirror>
   --><br>  <!-- 添加阿里云镜像 --><br><mirror><br>    <id>alimaven</id><br>    <name>aliyun maven</name><br>    <url><a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></url><br>    <mirrorOf>central</mirrorOf><br>  </mirror><br></mirrors><br>2.3.4 全局setting与用户setting<br>maven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。</settings></p>
<p>在maven安装目录下 的有 conf&#x2F;setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。 如需要 个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在:${user.dir} &#x2F;.m2&#x2F;settings.xml目录 中,${user.dir} 指windows 中的用户目录。</p>
<p>maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全 局配置文件。</p>
<p>2.3 Maven坐标和依赖<br>Maven的一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。为了能自动化的解析任何一个Java构 件，Maven必须将这些Jar包或者其他资源进行唯一标识，这是管理项目的依赖的基础，也就是我们要说的坐标。包 括我们自己开发的项目，也是要通过坐标进行唯一标识的，这样才能才其它项目中进行依赖引用。</p>
<p>坐标的定义元素如下</p>
<p>元素	作用<br>groupId	定义当前Maven项目名称<br>artifactId	定义项目模块<br>version	定义当前项目的当前版本<br>例如</p>
<p>创建一个Maven的web项目，在pom.xml文件中生成坐标</p>
<p>1<br>2<br>3<br>4<br>5</p>
<!--当前项目坐标--> 
<p><groupId>com.test</groupId><br><artifactId>maven_helloword</artifactId><br><version>1.0-SNAPSHOT</version><br><packaging>war</packaging><br>要引入junit的测试jar，只需要在pom.xml配置文件中配置引入junit的坐标依赖即可</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<!-- 依赖关系 --> 
<dependencies>
<!-- 此项目运行使用junit，所以此项目依赖junit --> 
  <dependency>
<!-- junit的项目名称 --> 
    <groupId>junit</groupId>
<!-- junit的模块名称 --> 
    <artifactId>junit</artifactId> <!-- junit版本 --> 
    <version>4.12</version>
<!-- 依赖范围:单元测试时使用junit -->
        <scope>test</scope>
    </dependency>
</dependencies>
2.4 Maven工程的认识
2.4.1 Maven工程的目录结构
作为一个maven工程，它的src目录和pom.xml是必备的。

<p>1<br>2<br>3<br>4<br>├── maven_java.iml<br>├── pom.xml<br>├── src<br>└── target<br>进入src目录后，我们发现它里面的目录结构如下</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>src<br>├── main<br>│   ├── java					#项目代码<br>│   ├── resources			#配置文件<br>│   └── webapp				#页面资源<br>└── test<br>        ├── java					#测试代码<br>    └──resources 					</p>
<p>6 directories, 0 files<br>文件	说明<br>src&#x2F;main&#x2F;java	存放项目的.java文件<br>src&#x2F;main&#x2F;resources	存放项目资源文件，如spring, mybatis配置文件<br>src&#x2F;test&#x2F;java	存放所有单元测试.java文件，如junit测试类<br>src&#x2F;test&#x2F;resources	测试资源文件<br>target	项目输出位置，编译后的class文件会输出到此目录<br>pom.xml	maven项目核心配置文<br>注意:如果是普通的java项目，那么就没有webapp目录。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>完整java项目<br>    java工程名（项目名）<br>        |– src目录<br>            |– main目录（主干代码）<br>                |– java目录（java代码）<br>                |– resources目录（配置文件）<br>            |– test目录（测试代码）<br>                |– java目录（java代码）<br>                |– resources目录（配置文件）<br>        |– pom.xml（maven工程核心配置文件）<br>        |– target目录（存放编译后的class文件…..）</p>
<ul>
<li>web项目【重点】<br>  web工程名（项目名）<br>  |– src目录<br>      |– main目录（主干代码）<br>          |– java目录（java代码）<br>          |– resources目录（配置文件）<br>          |– webapp目录（页面资源）<br>              |– WEB-INF<br>                  |– web.xml(web工程核心配置文件)<br>              |– index.jsp<br>              |– css、js、img..<br>      |– test目录（测试代码）<br>          |– java目录（java代码）<br>          |– resources目录（配置文件）<br>  |– pom.xml（maven工程核心配置文件）<br>  |– target目录（存放编译后的class文件…..）<br>2.4.2 Maven工程的运行<br>进入maven工程目录(当前目录有pom.xml文件)，运行tomcat7:run命令</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>~ mvn tomcat7:run</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] &gt;&gt;&gt; tomcat7-maven-plugin:2.2:run (default-cli) &gt; process-classes @ maven_web &gt;&gt;&gt;<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 1 source file to &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;classes<br>[INFO]<br>[INFO] &lt;&lt;&lt; tomcat7-maven-plugin:2.2:run (default-cli) &lt; process-classes @ maven_web &lt;&lt;&lt;<br>[INFO]<br>[INFO]<br>[INFO] — tomcat7-maven-plugin:2.2:run (default-cli) @ maven_web —<br>[INFO] Running war on <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a><br>[INFO] Creating Tomcat server configuration at &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;tomcat<br>[INFO] create webapp with contextPath:<br>May 15, 2020 10:29:37 PM org.apache.coyote.AbstractProtocol init<br>INFO: Initializing ProtocolHandler [“http-bio-8080”]<br>May 15, 2020 10:29:37 PM org.apache.catalina.core.StandardService startInternal<br>INFO: Starting service Tomcat<br>May 15, 2020 10:29:37 PM org.apache.catalina.core.StandardEngine startInternal<br>INFO: Starting Servlet Engine: Apache Tomcat&#x2F;7.0.47<br>May 15, 2020 10:29:38 PM org.apache.coyote.AbstractProtocol start<br>INFO: Starting ProtocolHandler [“http-bio-8080”]<br>根据上边的提示信息,访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 即可</p>
<p>三.Maven生命周期和插件<br>3.1 Maven常用命令和插件<br>3.1.1 clean<br>clean是maven工程的清理命令，执行 clean会删除target目录及内容。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>~ mvn clean</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-clean-plugin:2.5:clean (default-clean) @ maven_web —<br>[INFO] Deleting &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 0.228 s<br>[INFO] Finished at: 2020-05-15T23:52:52+08:00<br>[INFO] Final Memory: 9M&#x2F;309M<br>[INFO] ————————————————————————<br>3.1.2 compile<br>compile是maven工程的编译命令，作用是将src&#x2F;main&#x2F;java下的文件编译为class文件输出到target目录下。</p>
<p>将src中main目录下java代码进行编译，将src中main目录下配置抽取，输出到target目录: classes目录</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>~ mvn compile</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 1 source file to &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;classes<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 0.952 s<br>[INFO] Finished at: 2020-05-15T23:56:28+08:00<br>[INFO] Final Memory: 13M&#x2F;209M<br>[INFO] ————————————————————————</p>
<p>～ ll  .&#x2F;target&#x2F;classes&#x2F;cn&#x2F;itcast&#x2F;web&#x2F;servlet&#x2F;</p>
<p>total 8<br>-rw-r–r–  1 swzxsyh  staff   1.1K May 15 23:56 HelloServlet.class<br>3.1.3 test<br>test是maven工程的测试命令 mvn test，会执行src&#x2F;test&#x2F;java下的单元测试类，并编译为class文件。</p>
<p>mvn test&#x3D;&gt;target编译main代码&#x3D;&gt;编译test代码&#x3D;&gt;执行所有测试代码，类名xxxTest结尾，必须有@Test注解的方法</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>~ mvn test</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO] </p>
<p>#清理target目录<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>#编译src&#x2F;main主干<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>#编译src&#x2F;test测试目录<br>[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven_web —<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 1 source file to &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;test-classes<br>[INFO] </p>
<h1 id="针对test目录下的测试代码，逐一测试"><a href="#针对test目录下的测试代码，逐一测试" class="headerlink" title="针对test目录下的测试代码，逐一测试"></a>针对test目录下的测试代码，逐一测试</h1><p>[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ maven_web —<br>[INFO] Surefire report directory: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;surefire-reports</p>
<hr>
<h2 id="T-E-S-T-S"><a href="#T-E-S-T-S" class="headerlink" title=" T E S T S"></a> T E S T S</h2><p>Running cn.itcast.test.HelloTest<br>仅在测试期有效<br>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.065 sec</p>
<p>Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>
<p>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 1.509 s<br>[INFO] Finished at: 2020-05-16T00:00:02+08:00<br>[INFO] Final Memory: 15M&#x2F;212M<br>[INFO] ————————————————————————<br>3.1.4 package<br>package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。</p>
<p>mvn package&#x3D;&gt;编译main代码&#x3D;&gt;编译test代码&#x3D;&gt;执行测试&#x3D;&gt;将项目打成war包</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>~ mvn package</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ maven_web —<br>[INFO] Surefire report directory: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;surefire-reports</p>
<hr>
<h2 id="T-E-S-T-S-1"><a href="#T-E-S-T-S-1" class="headerlink" title=" T E S T S"></a> T E S T S</h2><p>Running cn.itcast.test.HelloTest<br>仅在测试期有效<br>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.048 sec</p>
<p>Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>
<p>[INFO]<br>[INFO] — maven-war-plugin:2.2:war (default-war) @ maven_web —<br>[INFO] Packaging webapp<br>[INFO] Assembling webapp [maven_web] in [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT]<br>[INFO] Processing war project<br>[INFO] Copying webapp resources [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;src&#x2F;main&#x2F;webapp]<br>[INFO] Webapp assembled in [49 msecs]<br>[INFO] Building war: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war<br>[INFO] WEB-INF&#x2F;web.xml already added, skipping<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 1.528 s<br>[INFO] Finished at: 2020-05-16T00:05:14+08:00<br>[INFO] Final Memory: 12M&#x2F;294M<br>[INFO] ————————————————————————</p>
<p>~ find . -name ‘*war’<br>.&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war<br>#此包可以直接放在tomcat的webapp下执行<br>注意：为什么maven_hello是war包而不是jar包呢？</p>
<p>1<br>2<br>3<br>cat pom.xml| grep -ri ‘packaging’<br>(standard input):    <packaging>war</packaging><br>#导包方式：jar默认，手动指定war<br>3.1.5 install<br>install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。</p>
<p>mvn install&#x3D;&gt;编译main代码&#x3D;&gt;编译test代码&#x3D;&gt;执行测试&#x3D;&gt;将项目打成war包&#x3D;&gt;安装到本地库</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>~ mvn install</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ maven_web —<br>[INFO] Surefire report directory: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;surefire-reports</p>
<hr>
<h2 id="T-E-S-T-S-2"><a href="#T-E-S-T-S-2" class="headerlink" title=" T E S T S"></a> T E S T S</h2><p>Running cn.itcast.test.HelloTest<br>仅在测试期有效<br>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.053 sec</p>
<p>Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>
<p>[INFO]<br>[INFO] — maven-war-plugin:2.2:war (default-war) @ maven_web —<br>[INFO] Packaging webapp<br>[INFO] Assembling webapp [maven_web] in [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT]<br>[INFO] Processing war project<br>[INFO] Copying webapp resources [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;src&#x2F;main&#x2F;webapp]<br>[INFO] Webapp assembled in [32 msecs]<br>[INFO] Building war: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war<br>[INFO] WEB-INF&#x2F;web.xml already added, skipping<br>[INFO] </p>
<h1 id="将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署"><a href="#将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署" class="headerlink" title="将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署"></a>将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署</h1><p>[INFO] — maven-install-plugin:2.4:install (default-install) @ maven_web —<br>[INFO] Installing &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war to &#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;repository&#x2F;cn&#x2F;itcast&#x2F;maven_web&#x2F;1.0-SNAPSHOT&#x2F;maven_web-1.0-SNAPSHOT.war<br>[INFO] Installing &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;pom.xml to &#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;repository&#x2F;cn&#x2F;itcast&#x2F;maven_web&#x2F;1.0-SNAPSHOT&#x2F;maven_web-1.0-SNAPSHOT.pom<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 1.522 s<br>[INFO] Finished at: 2020-05-16T00:08:09+08:00<br>[INFO] Final Memory: 12M&#x2F;297M<br>[INFO] ————————————————————————<br>从运行结果中，可以看出: 当后面的命令执行时，前面的操作过程也都会自动执行</p>
<p>3.1.6 deploy<br>maven工程部署命令，将jar或war包部署（上传）到私服中。</p>
<p>3.2 Maven生命周期<br>maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”。</p>
<p>在同一个生命周期中的命令,执行后面的命令,前面的命令自动执行</p>
<p>三套名称	描述	命令<br>Clean Lifecycle	在进行真正的构建之前进行一些清理工作。	clean<br>Default Lifecycle	构建的核心部分，编译，测试，打包，部署等等。	compile,test,package,install,deploy<br>Site Lifecycle	生成项目报告，站点，发布站点。	site<br>3.2.1 clean生命周期 clean生命周期的目的是清理项目<br>阶段	描述<br>pre-clean	执行一些需要在clean之前完成的工作<br>clean	移除所有上一次构建生成的文件<br>post-clean	执行一些需要在clean之后立刻完成的工作<br>3.2.2 default生命周期<br>default生命周期定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分</p>
<p>生命周期阶段	描述<br>validate(校验)	校验项目是否正确并且所有必要的信息可以完成项目的构建过程。<br>initialize(初始化)	初始化构建状态，比如设置属性值。<br>generate-sources(生成源代码)	生成包含在编译阶段中的任何源代码。<br>process-sources(处理源代码)	处理源代码，比如说，过滤任意值。<br>generate-resources(生成资源文件)	生成将会包含在项目包中的资源文件。<br>process-resources (处理资源文件)	复制和处理资源到目标目录，为打包阶段最好准备。<br>compile(编译)	编译项目的源代码。<br>process-classes(处理类文件)	处理编译生成的文件，比如说对Java class文件做字节码改善优化。<br>generate-test-sources(生成测试源代 码)	生成包含在编译阶段中的任何测试源代码。<br>process-test-sources(处理测试源代 码)	处理测试源代码，比如说，过滤任意值。<br>generate-test-resources(生成测试资源 文件)	为测试创建资源文件。<br>process-test-resources(处理测试资源 文件)	复制和处理测试资源到目标目录。<br>test-compile(编译测试源码)	编译测试源代码到测试目标目录.<br>process-test-classes(处理测试类文件)	处理测试源码编译生成的文件。<br>test(测试)	使用合适的单元测试框架运行测试(Juint是其中之一)。<br>prepare-package(准备打包)	在实际打包之前，执行任何的必要的操作为打包做准备。<br>package(打包)	将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者 EAR文件。<br>pre-integration-test(集成测试前)	在执行集成测试前进行必要的动作。比如说，搭建需要的环境。<br>integration-test(集成测试)	处理和部署项目到可以运行集成测试环境中。<br>post-integration-test(集成测试后)	在执行集成测试完成后进行必要的动作。比如说，清理集成测试 环境。<br>verify (验证)	运行任意的检查来验证项目包有效且达到质量标准。<br>install(安装)	安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。<br>deploy(部署)	将最终的项目包复制到远程仓库中与其他开发者和项目共享。<br>3.2.3 site生命周期<br>site生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团 队交流和发布项目信息。</p>
<p>阶段	描述<br>pre-site	执行一些需要在生成站点文档之前完成的工作<br>site	生成项目的站点文档<br>post-site	执行一些需要在生成站点文档之后完成的工作，并且为部署做准备<br>site-deploy	将生成的站点文档部署到特定的服务器上<br>3.3 Maven概念模型<br>Maven 包含了一个项目对象模型 (POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插 件(plugin)目标(goal)的逻辑。</p>
<p>项目对象模型 (Project Object Model)</p>
<p>一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。</p>
<p>依赖管理系统(Dependency Management System)</p>
<p>通过maven的依赖管理对项目所依赖的jar 包进行统一管理。比如:项目依赖junit4.12，通过在pom.xml中定义 junit4.12的依赖即使用junit4.12，如下所示是junit4.12的依赖定义:</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<!-- 依赖关系 --> <dependencies>
<!-- 此项目运行使用junit，所以此项目依赖junit --> <dependency>
<!-- junit的项目名称 --> <groupId>junit</groupId>
<!-- junit的模块名称 --> <artifactId>junit</artifactId> <!-- junit版本 --> <version>4.12</version>
<!-- 依赖范围:单元测试时使用junit -->
<pre><code>    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</dependency></dependencies>
一个项目生命周期(Project Lifecycle)

<p>使用maven完成项目的构建，项目构建包括:清理、编译、测试、部署等过程，maven将这些过程规范为一个生命</p>
<p>周期</p>
<p>清理	➡	编译	➡	测试	➡	报告	➡	打包	➡	部署<br>一组标准集合</p>
<p>maven将整个项目管理过程定义一组标准。</p>
<p>比如:通过maven构建工程有标准的目录结构，有标准的生命周期阶 段、依赖管理有标准的坐标定义等。</p>
<p>插件(plugin)目标(goal)</p>
<p>maven 管理项目生命周期过程都是基于插件完成的。</p>
<p>四.IDEA创建Maven工程<br>4.1 IDEA配置本地Maven<br>进入configure–&gt;settings–&gt;build–&gt;build tools–&gt;Maven中，设置maven工具和本地仓库</p>
<p>进入configure–&gt;settings–&gt;build–&gt;build tools–&gt;Maven–&gt;Runner中，设置VM Options:-DarchetypeCatalog&#x3D;internal -Dfile.encoding&#x3D;GB2312</p>
<p>4.2 IDEA创建工程<br>Java工程</p>
<p>选择Maven，下一步，设置GroupID域名倒写，ArtifactID项目名，Version版本号</p>
<p>手动创建test测试配置文件目录</p>
<p>test目录右击创建resources目录，然后Mark Directory AS选Resources Root</p>
<p>指定maven环境的jdk版本和字符集</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<!-- pom.xml -->

<build>
    <plugins>
        <!-- 设置编译版本为1.8 -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.1</version>
            <configuration>
                <source>1.8
                <target>1.8</target>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
    </plugins>
</build>
maven工程命令操作

<p>打开右侧maven栏，双击命令即可</p>
<p>如何导入依赖</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<!-- pom.xml -->  

<!--依赖管理-->
  <dependencies>
    <!--mysql驱动-->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.47</version>
      <scope>runtime</scope>
    </dependency>
</dependencies>
安装一个插件JBLJavaToWeb

<p>点击项目，选择插件功能JBLJavaToWeb即可将Java项目转换为Web项目</p>
<p>4.3 发布web工程<br>idea使用外置tomcat运行</p>
<p>Add Configurations–&gt;ADD&#x3D;&gt;Tomcat(Local)，设置名称Tomcat，其他跟之前项目一样</p>
<p>idea使用maven内置tomcat插件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br><build><br>        <plugins><br>            <!-- 设置编译版本为1.8 --><br>            <plugin><br>                <groupId>org.apache.maven.plugins</groupId><br>                <artifactId>maven-compiler-plugin</artifactId><br>                <version>3.1</version><br>                <configuration><br>                    <source>1.8<br>                    <target>1.8</target><br>                    <encoding>UTF-8</encoding><br>                </configuration><br>            </plugin><br>            <plugin><br>                <groupId>org.apache.tomcat.maven</groupId><br>                <artifactId>tomcat7-maven-plugin</artifactId><br>                <version>2.2</version><br>                <configuration><br>                    <port>8080</port><br>                    <path></path>&#x2F;<br>                    <uriEncoding>utf-8</uriEncoding><br>                </configuration><br>            </plugin><br>        </plugins><br>    </build><br>4.4 依赖管理<br>我们不考虑依赖范围引起的问题</p>
<p>依赖范围	对于编译classpath有效	对于测试classpath有效	对于运行时classpath有效	例子<br>compile（默认）	Y	Y	Y	mybatis<br>test	-	Y	-	junit<br>provided	Y	Y	-	servlet-api<br>runtime	-	Y	Y	JDBC驱动<br>system	Y	Y	-	本地，maven仓库之外的库<br>依赖范围	描述<br>compile	默认依赖范围，作用域在编译、测试、运行时都有效。<br>test	作用域在测试时有效。编译和运行时不需要，比如：Junit。<br>provided	作用域在编译、测试时有效。运行时不需要，比如： servlet api 被 tomcat 容器提供。<br>runtime	作用域在测试、运行时有效。编译时不需要，比如：jdbc的驱动包。<br>system	system范围依赖与provided类似，jar包在本地磁盘而不是maven仓库<br>在maven_web工程中测试scope:</p>
<p>默认引入 的jar包</p>
<p>compile 【默认范围 可以不写】(编译、测试、运行 都有效 )</p>
<p>servlet-api 、jsp-api</p>
<p>provided (编译、测试 有效， 运行时无效 防止和tomcat下jar冲突)</p>
<p>jdbc驱动jar包</p>
<p>runtime (测试、运行 有效 )</p>
<p>junit</p>
<p>test (测试有效)</p>
<p>依赖范围由强到弱的顺序是:compile&gt;provided&gt;runtime&gt;test</p>
<p>总结</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h3><ul>
<li>依赖管理</li>
</ul>
<p>​ - 通过maven管理jar包的整个过程</p>
<ul>
<li>一键构建</li>
</ul>
<p>​ - 通过一个maven的一个命令就可以完成工程整个构建的过程</p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h3><ul>
<li><p>下载 3.5.2 版本</p>
</li>
<li><p>安装解压到非中文路径</p>
</li>
<li><p>配置MAVEN_HOME环境变量</p>
</li>
</ul>
<p>​ - 依赖java环境</p>
<h2 id="仓库分类"><a href="#仓库分类" class="headerlink" title="仓库分类"></a>仓库分类</h2><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li><p>1.中央仓库</p>
</li>
<li><p>2.第三方远程仓库</p>
</li>
</ul>
<p>​ - 阿里云镜像</p>
<ul>
<li>3.私服</li>
</ul>
<h3 id="配置指定本地仓库"><a href="#配置指定本地仓库" class="headerlink" title="配置指定本地仓库"></a>配置指定本地仓库</h3><ul>
<li>帅哥提供5G</li>
</ul>
<p>​ - 不建议覆盖</p>
<h3 id="配置阿里云镜像"><a href="#配置阿里云镜像" class="headerlink" title="配置阿里云镜像"></a>配置阿里云镜像</h3><ul>
<li>提高下载速度</li>
</ul>
<h2 id="命令和插件"><a href="#命令和插件" class="headerlink" title="命令和插件"></a>命令和插件</h2><h3 id="1）clean"><a href="#1）clean" class="headerlink" title="1）clean"></a>1）clean</h3><ul>
<li>清理target目录</li>
</ul>
<h3 id="2）compile"><a href="#2）compile" class="headerlink" title="2）compile"></a>2）compile</h3><ul>
<li>编译 src&#x2F;main&#x2F;java</li>
</ul>
<h3 id="3）test"><a href="#3）test" class="headerlink" title="3）test"></a>3）test</h3><ul>
<li>测试 src&#x2F;test&#x2F;java</li>
</ul>
<h3 id="4）package"><a href="#4）package" class="headerlink" title="4）package"></a>4）package</h3><ul>
<li>将工程进行打包</li>
</ul>
<p>​ - jar</p>
<p>​ - war</p>
<h3 id="5）install"><a href="#5）install" class="headerlink" title="5）install"></a>5）install</h3><ul>
<li>将打包后的工程安装到本地仓库</li>
</ul>
<h3 id="6）deploy"><a href="#6）deploy" class="headerlink" title="6）deploy"></a>6）deploy</h3><ul>
<li>将本地仓库的jar包或war包上传到私服</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="清理生命周期"><a href="#清理生命周期" class="headerlink" title="清理生命周期"></a>清理生命周期</h3><ul>
<li>clean</li>
</ul>
<h3 id="默认生命周期"><a href="#默认生命周期" class="headerlink" title="默认生命周期"></a>默认生命周期</h3><ul>
<li>compile</li>
</ul>
<p>​ - test</p>
<p>​ - package</p>
<p>​ - install</p>
<p>​ - deploy</p>
<h3 id="站点生命周期"><a href="#站点生命周期" class="headerlink" title="站点生命周期"></a>站点生命周期</h3><ul>
<li>site</li>
</ul>
<h2 id="IDEA配置maven工具"><a href="#IDEA配置maven工具" class="headerlink" title="IDEA配置maven工具"></a>IDEA配置maven工具</h2><h3 id="全局settings配置"><a href="#全局settings配置" class="headerlink" title="全局settings配置"></a>全局settings配置</h3><ul>
<li><p>指定maven工具路径</p>
</li>
<li><p>指定maven工具配置文件路径</p>
</li>
<li><p>指定maven工具本地仓库的路径</p>
</li>
</ul>
<h3 id="指定本地创建maven时，使用本地骨架"><a href="#指定本地创建maven时，使用本地骨架" class="headerlink" title="指定本地创建maven时，使用本地骨架"></a>指定本地创建maven时，使用本地骨架</h3><ul>
<li>-DarchetypeCatalog&#x3D;internal -Dfile.encoding&#x3D;GB2312</li>
</ul>
<h2 id="IDEA创建maven工程"><a href="#IDEA创建maven工程" class="headerlink" title="IDEA创建maven工程"></a>IDEA创建maven工程</h2><h3 id="1-创建java工程"><a href="#1-创建java工程" class="headerlink" title="1)创建java工程"></a>1)创建java工程</h3><h3 id="2）创建web工程"><a href="#2）创建web工程" class="headerlink" title="2）创建web工程"></a>2）创建web工程</h3><ul>
<li>下载JBLJavaToWeb插件</li>
</ul>
<h2 id="IDEA发布web工程"><a href="#IDEA发布web工程" class="headerlink" title="IDEA发布web工程"></a>IDEA发布web工程</h2><h3 id="1）使用本地tomcat"><a href="#1）使用本地tomcat" class="headerlink" title="1）使用本地tomcat"></a>1）使用本地tomcat</h3><h3 id="2）使用tomcat插件"><a href="#2）使用tomcat插件" class="headerlink" title="2）使用tomcat插件"></a>2）使用tomcat插件</h3><ul>
<li>pom.xml</li>
</ul>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><h3 id="1）我们编写的web工程需要手动导入servlet-api-坐标"><a href="#1）我们编写的web工程需要手动导入servlet-api-坐标" class="headerlink" title="1）我们编写的web工程需要手动导入servlet-api 坐标"></a>1）我们编写的web工程需要手动导入servlet-api 坐标</h3><h3 id="2）在打成-war包的时候将servlet-api-设置到-x2F-WEB-INF-x2F-lib目录下"><a href="#2）在打成-war包的时候将servlet-api-设置到-x2F-WEB-INF-x2F-lib目录下" class="headerlink" title="2）在打成 war包的时候将servlet-api 设置到 &#x2F;WEB-INF&#x2F;lib目录下"></a>2）在打成 war包的时候将servlet-api 设置到 &#x2F;WEB-INF&#x2F;lib目录下</h3><h3 id="3）如果与tomcat软件内置的版本不一致，可能会启动报错"><a href="#3）如果与tomcat软件内置的版本不一致，可能会启动报错" class="headerlink" title="3）如果与tomcat软件内置的版本不一致，可能会启动报错"></a>3）如果与tomcat软件内置的版本不一致，可能会启动报错</h3><h3 id="4）需要指定jar包的作用范围（provided）"><a href="#4）需要指定jar包的作用范围（provided）" class="headerlink" title="4）需要指定jar包的作用范围（provided）"></a>4）需要指定jar包的作用范围（provided）</h3><h3 id="有哪些依赖范围呢？"><a href="#有哪些依赖范围呢？" class="headerlink" title="有哪些依赖范围呢？"></a>有哪些依赖范围呢？</h3><ul>
<li>compile</li>
</ul>
<p>​ - 默认，在编译、测试、运行期有效</p>
<ul>
<li>test</li>
</ul>
<p>​ - 仅在测试期有效</p>
<ul>
<li>provided</li>
</ul>
<p>​ - 在编译、测试期有效</p>
<ul>
<li>runtime</li>
</ul>
<p>​ - 在测试、运行期有效</p>
<ul>
<li>system</li>
</ul>
<p>​ - 从本地中导入jar包</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/13/MyBatis%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/MyBatis%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">MyBatis注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-13 01:38:24" itemprop="dateCreated datePublished" datetime="2020-05-13T01:38:24+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.MyBatis注解<br>1.1 MyBatis常用注解<br>注解	作用<br>@Insert	实现新增，代替了<insert></insert><br>@Update	实现更新，代替了<update></update><br>@Delete	实现删除，代替了<delete></delete><br>@Select	实现查询，代替了<select></select><br>@Result	实现结果集封装，代替了<result></result><br>@Results	可以与@Result 一起使用，封装多个结果集，代替了<resultMap></resultMap><br>@One	实现一对一结果集封装，代替了<association></association><br>@Many	实现一对多结果集封装，代替了<collection></collection><br>1.2 MyBatis 单表操作<br>需求</p>
<p>基于user模块通过注解实现，增删改查</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>public interface UserMapper {</p>
<pre><code>//查询所有
@Select(&quot;SELECT id AS uid,username AS uname,birthday AS bir,sex AS gender,address AS addr FROM user&quot;)
@Results(value = &#123;
        //resultMap标签手动映射封装
        @Result(column = &quot;uid&quot;, property = &quot;id&quot;, id = true),
        @Result(column = &quot;uname&quot;, property = &quot;username&quot;),
        @Result(column = &quot;bir&quot;, property = &quot;birthday&quot;),
        @Result(column = &quot;gender&quot;, property = &quot;sex&quot;),
        @Result(column = &quot;addr&quot;, property = &quot;address&quot;)
&#125;)
public List&lt;User&gt; findAll();


//id查询
@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)
public User findById(Integer id);


//新增
@Insert(&quot;INSERT INTO user (username,birthday,sex,address) VALUES(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&quot;)
public void save(User user);


//修改(动态sql推荐使用xml)
@Update(&quot;UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id = #&#123;id&#125;&quot;)
public void update(User user);

//删除
@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)
public void delete(Integer id);
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>public class UserMapperTest extends BaseMapperTest {<br>    &#x2F;&#x2F;单表测试<br>    @Test<br>    public void testFindAll() throws Exception {<br>        UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>        List<User> list &#x3D; userMapper.findAll();<br>        System.out.println(list);<br>    }</User></p>
<pre><code>//单表测试,查询一个
@Test
public void testFindById() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findById(41);
    System.out.println(user);
&#125;

//新增
@Test
public void testInsert() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setUsername(&quot;A&quot;);
    user.setBirthday(new Date());
    user.setAddress(&quot;GZ&quot;);
    user.setSex(&quot;Male&quot;);
    userMapper.save(user);
&#125;

//修改
@Test
public void testUpdate() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setId(58);
    user.setUsername(&quot;B&quot;);
    userMapper.save(user);
&#125;

//删除
@Test
public void testDelete() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    userMapper.delete(58);
&#125;
</code></pre>
<p>}<br>1.3 MyBatis多表操作<br>注解多表操作是基于嵌套查询来实现</p>
<p>注解	说明<br>@Results	结果映射的列表，包含了一个特别结果列如何被映射到属性或字段的详情。属性有：value, id。value 属性是 Result 注解的数组。这个 id 的属性是结果映射的名称。<br>@Result	在列和属性或字段之间的单独结果映射。属性有：id, column, javaType, jdbcType, typeHandler, one, many。id 属性是一个布尔值，来标识应该被用于比较（和在 XML 映射中的相似）的属性。one 属性是单独的联系，和 相似，而 many 属性是对集合而言的，和相似。它们这样命名是为了避免名称冲突。<br>@One	复杂类型的单独属性值映射。属性有：select，已映射语句（也就是映射器方法）的全限定名，它可以加载合适类型的实例。fetchType会覆盖全局的配置参数 lazyLoadingEnabled。注意 联合映射在注解 API中是不支持的。这是因为 Java 注解的限制,不允许循环引用。<br>@Many	映射到复杂类型的集合属性。属性有：select，已映射语句（也就是映射器方法）的全限定名，它可以加载合适类型的实例的集合，fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。注意 联合映射在注解 API中是不支持的。这是因为 Java 注解的限制，不允许循环引用<br>1.3.1 一对一查询<br>需求</p>
<p>查询一个订单，与此同时查询出该订单所属的用户</p>
<p>一对一查询语句</p>
<p>1<br>2<br>SELECT * FROM orders where id &#x3D; #{id};<br>SELECT * FROM <code>user</code> WHERE id &#x3D; #{订单的uid};<br>OrderMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>public interface OrderMapper {</p>
<pre><code>//一对一嵌套注解
@Select(&quot;SELECT * FROM orders WHERE id = #&#123;id&#125;&quot;)
@Results(value = &#123;
        //resultMap标签手动映射封装
        @Result(column = &quot;uid&quot;, property = &quot;id&quot;, id = true),
        @Result(column = &quot;uname&quot;, property = &quot;username&quot;),
        @Result(column = &quot;bir&quot;, property = &quot;birthday&quot;),
        @Result(column = &quot;gender&quot;, property = &quot;sex&quot;),
        @Result(column = &quot;addr&quot;, property = &quot;address&quot;),
        @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.test.dao.UserMapper.findById&quot;,fetchType = FetchType.EAGER))

&#125;)
public Order findByIdWithUsers(Integer id);
</code></pre>
<p>}<br>UserMapper接口</p>
<p>1<br>2<br>3<br>&#x2F;&#x2F;id查询<br>@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>public User findById(Integer id);<br>注解嵌套</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>public interface OrderMapper {</p>
<pre><code>//一对一嵌套注解
@Select(&quot;SELECT * FROM orders WHERE id = #&#123;id&#125;&quot;)
@Results(value = &#123;
        //resultMap标签手动映射封装
        @Result(column = &quot;uid&quot;, property = &quot;id&quot;, id = true),
        @Result(column = &quot;uname&quot;, property = &quot;username&quot;),
        @Result(column = &quot;bir&quot;, property = &quot;birthday&quot;),
        @Result(column = &quot;gender&quot;, property = &quot;sex&quot;),
        @Result(column = &quot;addr&quot;, property = &quot;address&quot;),
  
  //注解嵌套
  @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.test.dao.UserMapper.findById&quot;,fetchType = FetchType.EAGER))
  

&#125;)
public Order findByIdWithUsers(Integer id);
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public class OrderMapperTest extends BaseMapperTest {</p>
<pre><code>//一对一嵌套注解测试
@Test
public void testFindByIdWithUsers() throws Exception &#123;
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);
    Order order = orderMapper.findByIdWithUsers(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}<br>1.3.2 一对多查询<br>需求</p>
<p>查询一个用户，与此同时查询出该用户具有的订单</p>
<p>一对多查询语句</p>
<p>1<br>2<br>SELECT * FROM <code>user</code> where id &#x3D; #{id};<br>SELECT * FROM orders where uid &#x3D; #{用户id};<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>&#x2F;&#x2F;一对多注解嵌套查询<br>@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>@Results({ &#x2F;&#x2F; resultMap标签手动映射<br>        @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>        @Result(column &#x3D; “username”,property &#x3D; “username”),<br>        @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>        @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>        @Result(column &#x3D; “address”,property &#x3D; “address”),<br>        @Result(property &#x3D; “orderList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>})<br>public User findByIdWithOrders(Integer id);</p>
<p>OrderMapper接口</p>
<p>1<br>2<br>@Select(“SELECT * FROM orders WHERE uid &#x3D; #{id}”)<br>public List<Order> findByUid(Integer id);<br>注解嵌套</Order></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>    &#x2F;&#x2F;一对多注解嵌套查询<br>    @Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>    @Results({ &#x2F;&#x2F; resultMap标签手动映射<br>            @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>            @Result(column &#x3D; “username”,property &#x3D; “username”),<br>            @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>            @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>            @Result(column &#x3D; “address”,property &#x3D; “address”),</p>
<p>@Result(property &#x3D; “orderList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>    })<br>    public User findByIdWithOrders(Integer id);</p>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>&#x2F;&#x2F;一对多注解测试<br>@Test<br>public void testFindByIdWithOrders() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    User user &#x3D; userMapper.findByIdWithOrders(41);<br>    System.out.println(user);<br>    System.out.println(user.getOrderList());<br>}<br>1.3.3 多对多查询<br>需求</p>
<p>查询用户同时查询出该用户的所有角色</p>
<p>多对多查询语句</p>
<p>1<br>2<br>3<br>SELECT * FROM <code>user</code> where id &#x3D; #{id};<br>SELECT * FROM role r INNER JOIN user_role ur ON r.<code>id</code> &#x3D; ur.<code>rid</code><br>    WHERE ur.<code>uid</code> &#x3D; #{用户id};<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>&#x2F;&#x2F;多对多注解嵌套查询<br>@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>@Results({ &#x2F;&#x2F; resultMap标签手动映射<br>        @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>        @Result(column &#x3D; “username”,property &#x3D; “username”),<br>        @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>        @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>        @Result(column &#x3D; “address”,property &#x3D; “address”),<br>        @Result(property &#x3D; “roleList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>})<br>public User findByIdWithRoles(Integer id);</p>
<p>RoleMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public interface RoleMapper {<br>    @Select(“SELECT * FROM role r INNER JOIN user_role ur ON ur.<code>rid = r.</code>id<code> WHERE ur.</code>uid&#96;&#x3D;#{uid}”)<br>    @Results(value &#x3D; {<br>            @Result(column &#x3D; “id”,property &#x3D; “id”,id &#x3D; true),<br>            @Result(column &#x3D; “role_name”,property &#x3D; “roleName”),<br>            @Result(column &#x3D; “role_desc”,property &#x3D; “roleDesc”)<br>    })<br>    public List<Role> findByUid(Integer id);</Role></p>
<p>}<br>注解嵌套</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>    &#x2F;&#x2F;多对多注解嵌套查询<br>    @Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>    @Results({ &#x2F;&#x2F; resultMap标签手动映射<br>            @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>            @Result(column &#x3D; “username”,property &#x3D; “username”),<br>            @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>            @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>            @Result(column &#x3D; “address”,property &#x3D; “address”),</p>
<p>@Result(property &#x3D; “roleList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>    })<br>    public User findByIdWithRoles(Integer id);</p>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>&#x2F;&#x2F; 多对多注解测试<br>@Test<br>public void testFindByIdWithRoles() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>User user = userMapper.findByIdWithRoles(41);
System.out.println(user);
System.out.println(user.getOrderList());
</code></pre>
<p>}<br>1.4 延迟加载<br>不管是一对多还是多对多 ，在注解配置中都有fetchType的属性</p>
<p>fetchType &#x3D; FetchType.LAZY 表示懒加载</p>
<p>fetchType &#x3D; FetchType.EAGER 表示立即加载</p>
<p>fetchType &#x3D; FetchType.DEFAULT 表示使用全局配置</p>
<p>1.5 二级缓存<br>配置SqlMapConfig.xml文件开启二级缓存的支持</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><settings><br>    <!--
        因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。
        为true代表开启二级缓存；为false代表不开启二级缓存。
    --><br>    <setting name="cacheEnabled" value="true"><br></setting></settings><br>在Mapper接口中使用注解配置二级缓存</p>
<p>1<br>2<br>@CacheNamespace<br>public interface UserMapper {…}<br>1.6 知识小结<br>注解开发和xml配置相比，从开发效率来说，注解编写更简单，效率更高。</p>
<p>从可维护性来说，注解如果要修改，必须修改源码，会导致维护成本增加。xml维护性更强。</p>
<p>经验：单表简单CRUD可以使用注解、多表及动态sql就用xml</p>
<p>二.MyBatis案例练习<br>2.1 编程风格<br>浏览器：Chrome、Firefox</p>
<p>包目录：cn(com).公司名.项目名（都是小写）</p>
<p>类：大驼峰式命名</p>
<p>方法名：小驼峰式命名</p>
<p>2.2 环境搭建<br>编写中文过滤器</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>@WebFilter(“&#x2F;*”)<br>public class EncodeFilter implements Filter {<br>    @Override<br>    public void init(FilterConfig filterConfig) throws ServletException {</p>
<pre><code>&#125;

@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
    servletRequest.setCharacterEncoding(&quot;UTF-8&quot;);
    filterChain.doFilter(servletRequest, servletResponse);
&#125;

@Override
public void destroy() &#123;

&#125;
</code></pre>
<p>}<br>2.3 查询所有<br>2.3.1 需求和效果实现<br>通过三层架构+接口+mybatis，查询员工信息，在页面展示</p>
<p>2.3.2需求分析<br>index.jsp–&gt;EmpServlet–&gt;EmpService接口EmpServiceImp实现类–&gt;EmpDao接口+EmpDao映射，最终返给list.jsp</p>
<p>2.3.3 代码实现<br>index.jsp</p>
<p>1<br><a href="${pageContext.request.contextPath}/emp?action=findAll">员工列表</a><br>Emp实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class Emp {<br>    private Integer id;<br>    private String name;<br>    private String sex;<br>    private String joindate;<br>    private Double salary;<br>    private String address;<br>&#x2F;&#x2F;此处省略getter&#x2F;setter，toString<br>EmpServlet</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>@WebServlet(“&#x2F;EmpServlet”)<br>public class EmpServlet extends HttpServlet {</p>
<pre><code>// 重写service方法
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    // 获取action请求参数
    String action = request.getParameter(&quot;action&quot;);
    // 判断
    if (action.equals(&quot;findAll&quot;)) &#123;
        this.findAll(request, response);
    &#125;
&#125;

// 查询所有
protected void findAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    // 1.调用service查询
    EmpService empService = new EmpServiceImpl();
    List&lt;Emp&gt; list = empService.findAll();
    // 2.将list写入request域
    request.setAttribute(&quot;list&quot;, list);
    // 3.转发
    request.getRequestDispatcher(&quot;/list.jsp&quot;).forward(request, response);
&#125;
</code></pre>
<p>}<br>EmpServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>public class EmpServiceImpl implements EmpService {</p>
<pre><code>@Override
public List&lt;Emp&gt; findAll() &#123;
    // 通过mybatis工具类获取sqlSession
    SqlSession sqlSession = MyBatisUtils.openSession();
    // 创建EmpDao代理对象
    EmpDao empDao = sqlSession.getMapper(EmpDao.class);
    // 查询
    List&lt;Emp&gt; list= empDao.findAll();
    // 关闭sqlSession
    MyBatisUtils.close(sqlSession);
    return list;
&#125;
</code></pre>
<p>}<br>EmpDao（接口+映射）</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.EmpDao"><br>    <select id="findAll" resulttype="Emp"><br>        SELECT * FROM emp<br>    </select><br></mapper><br>list.jsp</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>&lt;c:forEach items&#x3D;”${list}” var&#x3D;”emp”&gt;<br>    <tr><br>        <td>${emp.id}</td><br>        <td>${emp.ename}</td><br>        <td>${emp.joindate}</td><br>        <td>${emp.salary}</td><br>        <td>${emp.address}</td><br>    </tr><br><br>2.4 分页查询<br>2.4.1 导入数据<br>2.4.2 分页介绍<br>在实际开发中，如果数据库数据太多，一般我们需要进行分页查询，提高效率</p>
<p>分页技术实现</p>
<p>物理分页：数据库实现（MySQL、Oracle）</p>
<p>内存分页：查询全部，在通过java代码进行分页</p>
<p>使用MySQL操作物理分页</p>
<p>语法： select * from 表名 limit 开始索引,每页个数;</p>
<p>模拟百度分页，一个显示5条，数据库共有16条记录</p>
<p>第一页</p>
<p>select * from 表名 limit 0,5;</p>
<p>第二页</p>
<p>select * from 表名 limit 5,5;</p>
<p>第三页</p>
<p>select * from 表名 limit 10,5;</p>
<p>第四页</p>
<p>select * from 表名 limit 15,5;</p>
<p>索引公式</p>
<p>开始索引&#x3D;(当前页-1) × 每页个数</p>
<p>如何获得当前页和每页个数</p>
<p>前端页提供</p>
<p>2.4.3 需求和效果实现<br>通过mysql物理分页，一个显示5条，数据库共有16条记录</p>
<p>2.4.3 需求分析</p>
<p>后端代码流程图</p>
<p>2.4.4 代码实现<br>index.jsp</p>
<p>1<br>2<br>3<br>4</p>
<body>
<%--<a href="${pageContext.request.contextPath}/EmpServlet?action=findAll">员工列表--%>
<a href="${pageContext.request.contextPath}/EmpServlet?action=findByPage&currentPage=1&pageSize=5">员工列表</a>
</%--<a></body>
PageBean

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class PageBean<E> {</E></p>
<pre><code>private Integer totalCount; // 总记录数

private Integer totalPage;// 总页数

private List&lt;E&gt; list; // 结果集

private Integer currentPage; // 当前页

private Integer pageSize; // 每页个数
</code></pre>
<p>  &#x2F;&#x2F;此处省略getter&#x2F;setter，toString<br>EmpServlet</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>@WebServlet(“&#x2F;EmpServlet”)<br>public class EmpServlet extends HttpServlet {</p>
<pre><code>// 重写service方法
@Override
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    // 获取action请求参数
    String action = req.getParameter(&quot;action&quot;);
    // 判断
    if (action.equals(&quot;findAll&quot;)) &#123;
        this.findAll(req, resp);
    &#125; else if (action.equals(&quot;findByPage&quot;)) &#123;
        this.findByPage(req, resp);
    &#125;
&#125;

EmpService empService = new EmpServiceImpl();

// 分页查询
protected void findByPage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    // 1.接收请求参数
    String currentPageStr = req.getParameter(&quot;currentPage&quot;);
    String pageSizeStr = req.getParameter(&quot;pageSize&quot;);
    // 2.转为整型
    int currentPage = Integer.parseInt(currentPageStr);
    int pageSize = Integer.parseInt(pageSizeStr);
    // 3.调用service查询
    PageBean&lt;Emp&gt; pb = empService.findByPage(currentPage, pageSize);
    // 4.设置到request域
    req.setAttribute(&quot;pb&quot;, pb);
    // 5.转发
    req.getRequestDispatcher(&quot;/list.jsp&quot;).forward(req, resp);
&#125;
</code></pre>
<p>EmpServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>public class EmpServiceImpl implements EmpService {<br>    @Override<br>    public List<Emp> findAll() {<br>        &#x2F;&#x2F; 通过mybatis工具类获取sqlSession<br>        SqlSession sqlSession &#x3D; MyBatisUtils.openSession();<br>        &#x2F;&#x2F; 创建EmpDao代理对象<br>        EmpDao empDao &#x3D; sqlSession.getMapper(EmpDao.class);<br>        &#x2F;&#x2F; 查询<br>        List<Emp> list &#x3D; empDao.findAll();<br>        &#x2F;&#x2F; 关闭sqlSession<br>        MyBatisUtils.close(sqlSession);<br>        return list;<br>    }<br>    @Override<br>    public PageBean<Emp> findByPage(int currentPage,int pageSize){<br>        &#x2F;&#x2F; 通过mybatis工具类获取sqlSession<br>        SqlSession sqlSession &#x3D; MyBatisUtils.openSession();</Emp></Emp></Emp></p>
<pre><code>    // 创建EmpDao代理对象
    EmpDao empDao = sqlSession.getMapper(EmpDao.class);

    // 1.创建 PageBean
    PageBean&lt;Emp&gt; pageBean = new PageBean();

    // 2.封装当前页和每页个数
    pageBean.setCurrentPage(currentPage);
    pageBean.setPageSize(pageSize);

    // 3.调用dao查询总记录数并封装
    Integer totalCount = empDao.findCount();
    pageBean.setTotalCount(totalCount);

    // 4.计算并封装总页数
    int totalPage = (int)Math.ceil(totalCount*1.0/pageSize);
    pageBean.setTotalPage(totalPage);

    // 5.计算开始索引
    int index = (currentPage - 1) * pageSize;

    // 6.调用dao查询结果集并封装
    List&lt;Emp&gt; list = empDao.findList(index,pageSize);
    pageBean.setList(list);

    // 关闭sqlSession
    MyBatisUtils.close(sqlSession);
    // 7.返回pageBean对象
    return pageBean;
&#125;
</code></pre>
<p>}<br>EmpDao（接口+映射）</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>public interface EmpDao {<br>    List<Emp> findAll();</Emp></p>
<pre><code>//查看总记录
Integer findCount();

//分页查询结果
List&lt;Emp&gt; findList(@Param(&quot;index&quot;) int index,@Param(&quot;pageSize&quot;) int pageSize);
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.EmpDao"><br>    <select id="findAll" resulttype="Emp"><br>        SELECT * FROM emp<br>    </select></mapper></p>
<pre><code>&lt;!--  查看总记录数 --&gt;
&lt;select id=&quot;findCount&quot; resultType=&quot;java.lang.Integer&quot;&gt;
    SELECT count(*) FROM emp
&lt;/select&gt;

&lt;!--    查看结果集--&gt;
&lt;select id=&quot;findList&quot; resultType=&quot;com.test.domain.Emp&quot;&gt;
    SELECT * FROM emp limit #&#123;index&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>

list.jsp

<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        table &#123;</span><br><span class="line">            margin: 30px auto;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #page td &#123;</span><br><span class="line">            width: 20px;</span><br><span class="line">            border: 1px solid gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> cellpadding=<span class="string">&quot;0&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;600px&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;入职日期&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;薪资&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;住址&lt;/td&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;emps&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;emp&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.name&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.sex&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.joindate&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.salary&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.address&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td style=<span class="string">&quot;text-align: left&quot;</span>&gt;总共检索到$&#123;pb.totalCount&#125;条记录,共分$&#123;pb.totalPage&#125;页&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;table id=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;pb.currentPage&gt;1&#125;&quot;</span>&gt;</span><br><span class="line">            &lt;td style=<span class="string">&quot;width:50px&quot;</span>&gt;</span><br><span class="line">                &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                   href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;pb.currentPage-1&#125;&amp;pageSize=5&quot;</span>&gt;上一页&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;c:forEach begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;$&#123;pb.totalPage&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">            &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;page == pb.currentPage&#125;&quot;</span>&gt;</span><br><span class="line">                &lt;td bgcolor=<span class="string">&quot;#ffd700&quot;</span>&gt;</span><br><span class="line">                    &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                       href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;page&#125;&amp;pageSize=5&quot;</span>&gt;$&#123;page&#125;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;page != pb.currentPage&#125;&quot;</span>&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                       href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;page&#125;&amp;pageSize=5&quot;</span>&gt;$&#123;page&#125;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;pb.currentPage &lt; pb.totalPage&#125;&quot;</span>&gt;</span><br><span class="line">            &lt;td style=<span class="string">&quot;width:50px&quot;</span>&gt;</span><br><span class="line">                &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                   href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;pb.currentPage+1&#125;&amp;pageSize=5&quot;</span>&gt;下一页&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">txt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">    <span class="comment">// var txt = document.querySelector（&quot;#uname&quot;）;</span></span><br><span class="line">    txt.innerText = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/12/Mybatis%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2-%E5%8A%A0%E8%BD%BD-%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/12/Mybatis%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2-%E5%8A%A0%E8%BD%BD-%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Mybatis嵌套查询 & 加载 & 缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-12 01:37:47" itemprop="dateCreated datePublished" datetime="2020-05-12T01:37:47+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Mybatis嵌套查询<br>1.1 什么事嵌套查询<br>嵌套查询就是将原来多表查询中的联合查询语句拆成多个单表的查询，再使用mybatis的语法嵌套在一起。</p>
<p>例</p>
<p>需求:查询一个订单，与此同时查询出该订单所属的用户</p>
<p>关联查询:</p>
<p>1<br>select * from orders o inner join user u on o.uid &#x3D; u.id where o.id &#x3D; 1;<br>缺点:<br>sql语句编写难度大</p>
<p>数据量过大，笛卡尔积数量倍增，可能造成内存溢出</p>
<p>嵌套查询</p>
<p>1<br>2<br>3<br>4<br>5<br>–根据订单id查询订单表<br>  select * from orders where id &#x3D; 1;<br>–再根据订单表中uid(外键)查询用户表<br>    select * from user where id &#x3D; 订单表uid;<br>–最后由mybatis框架进行嵌套组合<br>优点</p>
<p>sql语句编写简单</p>
<p>没有多表关联，不会产生笛卡尔积</p>
<p>1.2 一对一嵌套查询<br>需求</p>
<p>查询一个订单，与此同时查询出该订单所属的用户</p>
<p>sql语句</p>
<p>1<br>2<br>3<br>4<br>– 1.根据订单id查询订单表<br>    select * from orders where id &#x3D; 1;<br>– 2.再根据订单表中uid(外键)查询用户表<br>    select * from user where id &#x3D; 41;<br>OrderMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface OrderMapper {</p>
<pre><code>//一对一嵌套查询
public Order findByIdWithUser(Integer id);
</code></pre>
<p>OrderMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.OrderMapper"></mapper></p>
<pre><code>&lt;resultMap id=&quot;orderMap&quot; type=&quot;Order&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;

    &lt;!--通过mybatis嵌套查询user表--&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;uid&quot; select=&quot;com.test.dao.OrderMapper.findById&quot;&gt;

    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<!--    一对一嵌套查询-->
<pre><code>&lt;!--    resultType:单表映射封装 --&gt;
&lt;!--    resultMap:多表查询必须手动映射封装--&gt;

&lt;select id=&quot;findByIdWithUser&quot; parameterType=&quot;int&quot; resultMap=&quot;orderMap&quot;&gt;
    SELECT * FROM orders WHERE id=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>public interface UserMapper {<br>    &#x2F;&#x2F; 根据用户id查询user对象<br>    public User findById(Integer id);<br>UserMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;!--    根据用户id查询user对象--&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
SELECT * FROM user WHERE id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<p>通过mybatis进行嵌套组合</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br><resultMap id="orderMap" type="Order"><br>    <id column="id" property="id"></id><br>    <result column="ordertime" property="ordertime"></result><br>    <result column="money" property="money"></result></resultMap></p>
<pre><code>&lt;!--通过mybatis嵌套查询user表
一对一association
column=&quot;uid&quot; 订单查询的用户外键字段，需要作为条件
select=&quot;com.test.dao.OrderMapper.findById&quot;查询用户表(用户接口+执行方法名)
--&gt;
&lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;uid&quot; select=&quot;com.test.dao.UserMapper.findById&quot;/&gt;


&lt;/association&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>public class OrderMapperTest extends BaseMapperTest {</p>
<pre><code>// 一对一嵌套测试
@Test
public void testFindByIdWithUser() throws Exception &#123;
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);

    // 根据id查询
    Order order = orderMapper.findByIdWithUser(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>[2020-05-12 21:21:03,060] DEBUG o.OrderMapper.findByIdWithUser  - &#x3D;&#x3D;&gt;  Preparing: </p>
<p>&#x2F;&#x2F;先查询订单<br>SELECT * FROM orders WHERE id&#x3D;? </p>
<p>[2020-05-12 21:21:03,111] DEBUG o.OrderMapper.findByIdWithUser  - &#x3D;&#x3D;&gt; Parameters: 1(Integer)<br>[2020-05-12 21:21:03,159] DEBUG     com.test.dao.UserMapper  - Cache Hit Ratio [com.test.dao.UserMapper]: 0.0<br>[2020-05-12 21:21:03,159] DEBUG theima.dao.UserMapper.findById  - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: </p>
<p>&#x2F;&#x2F;再查询用户<br>SELECT * FROM user WHERE id&#x3D;? </p>
<p>[2020-05-12 21:21:03,159] DEBUG theima.dao.UserMapper.findById  - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 41(Integer)<br>[2020-05-12 21:21:03,162] DEBUG theima.dao.UserMapper.findById  - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1<br>[2020-05-12 21:21:03,165] DEBUG o.OrderMapper.findByIdWithUser  - &lt;&#x3D;&#x3D;      Total: 1</p>
<p>&#x2F;&#x2F;用mybatis嵌套组合在一起<br>Order{id&#x3D;1, ordertime&#x3D;Mon May 20 15:58:02 CST 2019, money&#x3D;999.5, user&#x3D;User{id&#x3D;41, username&#x3D;’老王’, birthday&#x3D;Tue May 28 06:47:08 CST 2019, sex&#x3D;’男’, address&#x3D;’北京’, orderList&#x3D;null, roleList&#x3D;null}}<br>嵌套关系</p>
<p>步骤	<br>&#x2F;&#x2F;一对一嵌套查询<br>public Order findByIdWithUser(Integer id);<br>&#x2F;&#x2F; 根据用户id查询user对象<br>public User findById(Integer id);<br>用mybatis嵌套组合在一起<br><association property="”user”" javatype="”User”" column="”uid”" select="”com.test.dao.UserMapper.findById”" fetchtype="”eager”/"><br>1.3 一对多嵌套查询<br>需求</association></p>
<p>查询一个用户，与此同时查询出该用户具有的订单</p>
<p>sql语句</p>
<p>1<br>2<br>3<br>4<br>– 1. 先根据用户id，查询用户表(一个)<br>    SELECT * FROM USER WHERE id &#x3D; 41;<br>– 2. 再根据用户id，查询订单表(多个)<br>    SELECT * FROM orders WHERE uid &#x3D; 41;<br>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; 一对多嵌套查询<br>public User findByIdWithOrders(Integer id);<br>UserMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br><resultMap id="userWithOrdersMap" type="User"><br>    <id column="id" property="id"><br>    <result column="username" property="username"><br>    <result column="sex" property="sex"><br>    <result column="birthday" property="birthday"><br>    <result column="address" property="address"><br>    <!--一对多嵌套组合--><br>    <collection property="orderList" oftype="Order" column="id" select="com.test.dao.OrderMapper.findByUid"><br></collection></result></result></result></result></id></resultMap></p>
<!--一对多嵌套查询-->
<select id="findByIdWithOrders" parametertype="int" resultmap="userWithOrdersMap">
    SELECT * FROM user WHERE id=#{id}
</select>
OrderMapper接口

<p>1<br>2<br>&#x2F;&#x2F; 根据用户id，查询订单列表<br>public List<Order> findByUid(Integer id);<br>OrderMapper映射</Order></p>
<p>1<br>2<br>3<br><select id="findByUid" parametertype="int" resulttype="Order"><br>    SELECT * FROM orders WHERE uid&#x3D;#{uid}<br></select><br>通过mybatis进行嵌套组合</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br><resultMap id="userWithOrdersMap" type="User"><br>    <id column="id" property="id"><br>    <result column="username" property="username"><br>    <result column="sex" property="sex"><br>    <result column="birthday" property="birthday"><br>    <result column="address" property="address"><br>    <!--一对多嵌套组合
    collection
    column="id" 根据用户查询的结果，id作为条件
    select="com.test.dao.OrderMapper.findByUid" 去查询订单表(映射接口+执行方法)
    --><br>    <collection property="orderList" oftype="Order" column="id" select="com.test.dao.OrderMapper.findByUid"><br></collection></result></result></result></result></id></resultMap><br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class UserMapperTest extends BaseMapperTest {</p>
<pre><code>@Test
public void testFindByIdWithOrders() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findByIdWithOrders(41);
    System.out.println(user);
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;先查询用户<br>    SELECT * FROM USER WHERE id &#x3D; 41;<br>&#x2F;&#x2F;再查询订单<br>    SELECT * FROM orders WHERE uid &#x3D; 41;<br>&#x2F;&#x2F;用mybatis嵌套组合在一起<br>嵌套关系</p>
<p>步骤	<br>&#x2F;&#x2F;先查询用户<br>public User findByIdWithOrders(Integer id);<br>&#x2F;&#x2F; 再查询订单<br>public List<Order> findByUid(Integer id);<br>用mybatis嵌套组合在一起<br><collection property="”orderList”" oftype="”Order”" column="”id”" select="”com.test.dao.OrderMapper.findByUid”/"><br>1.4 多对多嵌套查询<br>需求</collection></Order></p>
<p>查询用户同时查询出该用户的所有角色</p>
<p>mybatis的实现方案就是(一对多)，区别在于sql语句不同</p>
<p>sql语句</p>
<p>1<br>2<br>3<br>4<br>– 1. 先根据用户id，查询用户表(一个)<br>SELECT * FROM USER WHERE id &#x3D; 41;<br>– 2. 再根据用户id，查询角色表(多个)<br>SELECT * FROM role r INNER JOIN user_role ur ON ur.<code>rid</code> &#x3D; r.<code>id</code> WHERE ur.<code>uid</code> &#x3D; 41;<br>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; 多对多嵌套查询<br>public User findByIdWithRoles(Integer id);<br>UserMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br><resultMap id="userWithRolesMap" type="User"><br>    <id column="id" property="id"><br>    <result column="username" property="username"><br>    <result column="sex" property="sex"><br>    <result column="birthday" property="birthday"><br>    <result column="address" property="address"><br>    <!-- 多对多嵌套--><br>    <collection property="roleList" oftype="Role" column="id" select="com.test.dao.RoleMapper.findByUid"></collection><br></result></result></result></result></id></resultMap></p>
<select id="findByIdWithRoles" parametertype="int" resultmap="userWithRolesMap">
    SELECT * FROM user WHERE id=#{id}
</select>
RoleMapper接口

<p>1<br>2<br>3<br>4<br>5<br>public interface RoleMapper {</p>
<pre><code>// 根据用户id，查询角色列表
public List&lt;Role&gt; findByUid(Integer id);
</code></pre>
<p>}<br>RoleMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.RoleMapper"></mapper></p>
<pre><code>&lt;resultMap id=&quot;roleResultMap&quot; type=&quot;Role&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;/&gt;
    &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;/&gt;
&lt;/resultMap&gt;

&lt;!--    根据用户id，查询角色列表--&gt;
&lt;select id=&quot;findByUid&quot; parameterType=&quot;int&quot; resultMap=&quot;roleResultMap&quot;&gt;
    SELECT * FROM role r INNER JOIN user_role ur ON ur.`rid`=r.`id` WHERE ur.`uid`=#&#123;uid&#125;
&lt;/select&gt;
</code></pre>
</mapper>
通过mybatis进行嵌套组合

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;cache&gt;&lt;/cache&gt;

&lt;resultMap id=&quot;userWithOrdersMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!--一对多嵌套组合
    collection
    column=&quot;id&quot; 根据用户查询的结果，id作为条件
    select=&quot;com.test.dao.OrderMapper.findByUid&quot; 去查询订单表(映射接口+执行方法)
    --&gt;
    &lt;collection property=&quot;orderList&quot; ofType=&quot;Order&quot; column=&quot;id&quot; select=&quot;com.test.dao.OrderMapper.findByUid&quot;/&gt;
&lt;/resultMap&gt;


&lt;resultMap id=&quot;userWithRolesMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!-- 多对多嵌套
    column=&quot;id&quot; 用户id作为条件
    select=&quot;com.test.dao.RoleMapper.findByUid&quot;查询角色表(角色映射接口+执行方法)
    --&gt;
    &lt;collection property=&quot;roleList&quot; ofType=&quot;Role&quot; column=&quot;id&quot;
                select=&quot;com.test.dao.RoleMapper.findByUid&quot;&gt;&lt;/collection&gt;
&lt;/resultMap&gt;


&lt;!--    根据用户id查询user对象--&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
SELECT * FROM user WHERE id=#&#123;id&#125;
</code></pre>


<pre><code>&lt;!--一对多嵌套查询--&gt;
&lt;select id=&quot;findByIdWithOrders&quot; parameterType=&quot;int&quot; resultMap=&quot;userWithOrdersMap&quot;&gt;
    SELECT * FROM user WHERE id=#&#123;id&#125;
&lt;/select&gt;

&lt;select id=&quot;findByIdWithRoles&quot; parameterType=&quot;int&quot; resultMap=&quot;userWithRolesMap&quot;&gt;
    SELECT * FROM user WHERE id=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
</mapper>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>&#x2F;&#x2F; 多对多测试(根据用户查询角色)<br>@Test<br>public void testFindByIdWithRoles() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>User user = userMapper.findByIdWithRoles(41);
System.out.println(user);
</code></pre>
<p>}<br>嵌套关系</p>
<p>步骤	<br>&#x2F;&#x2F;先查询用户<br>public User findByIdWithRoles(Integer id);<br>&#x2F;&#x2F; 再查询角色列表<br>public List<Order> findByUid(Integer id);<br>用mybatis嵌套组合在一起<br><collection property="”roleList”" oftype="”Role”" column="”id”" select="”com.test.dao.RoleMapper.findByUid”/"><br>1.5 知识小结<br>步骤:一对多举例</collection></Order></p>
<p>先查询(一方)单表&#x3D;&gt;再查询(多方)单表&#x3D;&gt;最后由mybatis嵌套组合</p>
<p>配置	<br>一对一配置	使用<resultMap>+<association>做配置，通过column条件，执行select查询<br>一对多配置	使用<resultMap>+<collection>做配置，通过column条件，执行select查询<br>多对多配置	使用<resultMap>+<collection>做配置，通过column条件，执行select查询<br>优点:	缺点<br>简化sql语句编写<br>不会产生笛卡尔积	麻烦<br>开发中到底使用哪一种</collection></resultMap></collection></resultMap></association></resultMap></p>
<p>传统开发，数据量小</p>
<p>使用关联查询</p>
<p>互联网开发，数据量大</p>
<p>使用嵌套查询</p>
<p>二.Mybatis加载策略<br>2.1 什么是加载策略<br>当多个模型(表)之间存在关联关系时, 加载一个模型(表)的同时, 是否要立即加载其关联的模型, 我们把这种决策 称为加载策略</p>
<p>如果加载一个模型(表)的时候, 需要立即加载出其关联的所有模型(表), 这种策略称为立即加载</p>
<p>如果加载一个模型的时候, 不需要立即加载出其关联的所有模型, 等到真正需要的时候再加载, 这种策略称为延迟加载(懒加载)<br>Mybatis中的加载策略有两种:立即加载和延迟加载, 默认是立即加载</p>
<p>注意:延迟加载是在嵌套查询基础上实现的</p>
<p>什么样的场景使用立即加载</p>
<p>一对一</p>
<p>什么样的场景使用延迟加载(什么时候用，什么时候查询，提高数据库性能)</p>
<p>一对多、多对多</p>
<p>2.2 配置延迟加载<br>2.2.1 全局<br>SqlMapConfig.xml,设置开启全局延迟加载</p>
<p>1<br>2<br>3<br>4<br>5<br><settings><br>    <!--开启延迟(懒)加载 true 开始 false(默认值) 关闭--><br>    <setting name="lazyLoadingEnabled" value="true"></setting></settings></p>

2.2.2 局部
mapper映射文件，指定某一个select标签配置

<p>1<br>2<br>3<br>4<br>5<br><association></association> 标签<br><collection></collection> 标签<br>fetchType&#x3D;””属性<br>    eager 立即加载<br>    lazy 延迟加载<br>注意:局部优先级高于全局，就近原则</p>
<p>2.3 触发加载<br>有这样一个全局配置 lazyLoadTriggerMethods ,它定义的方法会触发立即加载</p>
<p>也就说当你调用它定义的方法时, 会执行数据加载, 它的默认值是 equals,clone,hashCode,toString</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><settings><br>    <!--开启延迟(懒)加载 true 开始 false(默认值) 关闭--><br>    <setting name="lazyLoadingEnabled" value="true"><br>    <!--触发立即加载的配置
      默认值:equals,clone,hashCode,toString
      value="" 覆盖了默认值，表示在执行上述四个方法时，不会触发立即加载
      只有在执行get方法获取时，触发数据加载
    --><br>    <setting name="lazyLoadTriggerMethods" value><br></setting></setting></settings><br>三.Mybatis缓存<br>什么是缓存</p>
<p>服务器内存(硬盘)中的一块区域</p>
<p>为什么使用缓存</p>
<p>提高查询效率</p>
<p>什么样的数据适合做缓存</p>
<p>经常访问但又不经常修改的数据</p>
<p>缓存是用来提高查询效率的，所有的持久层框架基本上都有缓存机制 Mybatis也提供了缓存策略，分为一级缓存，二 级缓存</p>
<p>3.1 一级缓存<br>3.1.1 介绍<br>MyBatis一级缓存是:SqlSession级别的缓存，默认开启，不需要手动配置</p>
<p>3.1.2 验证<br>需求</p>
<p>根据id查询用户</p>
<p>一级缓存测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>&#x2F;&#x2F; 一级缓存测试<br>@Test<br>public void testFindByIdWithBufferLevel1() throws Exception {<br>    &#x2F;&#x2F;需要用工具类开启&#x2F;关闭session，否则会出现session错误<br>    SqlSession sqlSession &#x3D; MyBatisUtils.openSession();<br>    UserMapper userMapper1 &#x3D; sqlSession.getMapper(UserMapper.class);<br>    &#x2F;&#x2F; 走数据库<br>    User user1 &#x3D; userMapper1.findById(41);<br>    System.out.println(user1);</p>
<pre><code>// 清除缓存(自己测试增、删、改)
sqlSession.clearCache();

// 获取第二个代理对象
UserMapper userMapper2 = sqlSession.getMapper(UserMapper.class);
// 走缓存(如果上面清除缓存，还是走数据库)
User user2 = userMapper2.findById(41);
System.out.println(user2);

// sqlSession关闭(清除缓存)
MyBatisUtils.close(sqlSession);
</code></pre>
<p>}<br>3.1.3 分析<br>一级缓存是SqlSession范围的缓存，不同的SqlSession之间的缓存区域是互相不影响的，执行SqlSession的C(增</p>
<p>加)U(更新)D(删除)操作，或者调用clearCache()、commit()、close()方法，都会清空缓存</p>
<p>SqlSession对象		LocalCache(Map集合)<br>第一次查询	写入<br>➡	LocalCache<br>如果中间发生了DML(增删改)事务操作，清除缓存	清除<br>➡	LocalCache<br>第N次查询	读取<br>⬅	LocalCache<br>一级缓存源码</p>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;org.apache.ibatis.cache.impl.PerpetualCache</p>
<p>public class PerpetualCache implements Cache {<br>    private final String id;<br>    private Map&lt;Object, Object&gt; cache &#x3D; new HashMap();<br>3.2 二级缓存<br>3.2.1 介绍<br>MyBatis的二级缓存虽然是默认开启的，但需要在映射文件中配置 <cache> 标签才能使用，而且要求实体类的必须 实现序列化接口</cache></p>
<p>3.2.2 验证<br>mybatis全局配置，默认值就是开启了二级缓存</p>
<p>指定需要开启二级缓存的映射配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;!--    当前映射文件，使用二级缓存--&gt;
&lt;cache&gt;&lt;/cache&gt;
</code></pre>
<p>指定User实现序列化接口</p>
<p>1<br>public class User implements Serializable<br>二级缓存测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>&#x2F;&#x2F; 二级缓存测试<br>@Test<br>public void testFindByIdWithBufferLevel2() throws Exception {<br>&#x2F;&#x2F;需要用工具类开启&#x2F;关闭session，否则会出现session错误<br>    &#x2F;&#x2F; 模拟第一个用户<br>    SqlSession sqlSession1 &#x3D; MyBatisUtils.openSession();<br>    UserMapper userMapper1 &#x3D; sqlSession1.getMapper(UserMapper.class);<br>    User user1 &#x3D; userMapper1.findById(41);<br>    System.out.println(user1);</p>
<pre><code>sqlSession1.close();

// 模拟第二个用户
SqlSession sqlSession2 = MyBatisUtils.openSession();
UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);
User user2 = userMapper2.findById(41);
System.out.println(user2);
sqlSession2.close();
</code></pre>
<p>}<br>3.2.3 分析<br>二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共</p>
<p>用二级缓存，二级缓存是跨SqlSession的。</p>
<p>二级缓存相比一级缓存的范围更大(按namespace来划分)</p>
<p>3.3 知识小结</p>
<p>mybatis的缓存，不需要手动存储和获取数据。mybatis自动维护的。</p>
<p>使用mybatis，如果是中小型项目，使用自带缓存的机制是可以满足需求的。如果是大型(分布式)项目，mybatis的 缓存灵活性不足，需要使用第三方的缓存技术解决问题。</p>
<p>四.核心配置文件回顾<br>4.1 properties标签<br>加载外部的properties文件</p>
<p>1<br><properties resource="jdbc.properties"></properties><br>4.2 settings标签<br>全局参数配置</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br><settings></settings></p>
<!--开启懒加载-->
<setting name="lazyLoadingEnabled" value="true">
<!-- 指定触发延迟加载的方法，只有get方法执行时才会触发立即加载 --> <setting name="lazyLoadTriggerMethods" value> <!--开启二级缓存 true开启(默认) false关闭-->
<setting name="cacheEnabled" value="true">

4.3 typeAliases标签
1
2
3
4
5
6
7
8
<!-- 单个定义别名 -->
<typeAliases>
<typeAlias type="cn.itcast.domain.User" alias="user"></typeAlias>
    </typeAliases>
<!-- 使用包的形式批量定义别名 -->
<typeAliases>
<package name="cn.itcast.domain"></package>
    </typeAliases>
4.4 mappers标签
加载映射配置

<p>1<br>2<br>3<br>4</p>
<ol>
<li>加载指定的src目录下的映射文件，例如:<mapper resource="com/test/mapper/UserMapper.xml"></mapper></li>
<li>加载并扫描指定包下所有的映射文件(接口)，例如: <package name="com.test.mapper">
4.5 environments标签
数据源环境配置</package></li>
</ol>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<!--数据库环境配置-->
<environments default="mysql">
    <!--使用MySQL环境-->
    <environment id="mysql">
        <!--事务管理器,底层JDBC-->
        <transactionManager type="JDBC">
        <!--连接池,内置POOLED-->
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.driver}">
            <property name="url" value="${jdbc.url}">
            <property name="username" value="${jdbc.user}">
            <property name="password" value="${jdbc.password}">
        </property></property></property></property></dataSource>
    </transactionManager></environment>
</environments>
总结
## 一 MyBatis嵌套查询

<h3 id="将原来多表查询中的联合查询语句，拆成多个单表的查询"><a href="#将原来多表查询中的联合查询语句，拆成多个单表的查询" class="headerlink" title="将原来多表查询中的联合查询语句，拆成多个单表的查询"></a>将原来多表查询中的联合查询语句，拆成多个单表的查询</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>一对一配置：使用<resultMap>+<association>做配置，通过column条件，执行select查询</association></resultMap></p>
</li>
<li><p>一对多配置：使用<resultMap>+<collection>做配置，通过column条件，执行select查询</collection></resultMap></p>
</li>
<li><p>多对多配置：使用<resultMap>+<collection>做配置，通过column条件，执行select查询</collection></resultMap></p>
</li>
</ul>
<h2 id="二-MyBatis加载策略"><a href="#二-MyBatis加载策略" class="headerlink" title="二 MyBatis加载策略"></a>二 MyBatis加载策略</h2><h3 id="全局延迟加载"><a href="#全局延迟加载" class="headerlink" title="全局延迟加载"></a>全局延迟加载</h3><ul>
<li><settings></settings></li>
</ul>
<p>​ &lt;!–开启全局延迟加载功能–&gt;</p>
<p>​ <setting name="”lazyLoadingEnabled”" value="”true”/"></setting></p>


<h3 id="局部延迟加载"><a href="#局部延迟加载" class="headerlink" title="局部延迟加载"></a>局部延迟加载</h3><ul>
<li><association> 和 <collection> 标签</collection></association></li>
</ul>
<p>​ - fetchType&#x3D;”lazy | eager”</p>
<ul>
<li>局部的加载策略优先级高于全局的加载策略。</li>
</ul>
<h2 id="三-MyBatis缓存"><a href="#三-MyBatis缓存" class="headerlink" title="三 MyBatis缓存"></a>三 MyBatis缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><ul>
<li>是SqlSession级别的缓存</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ul>
<li>是mapper映射级别的缓存，需要手动配置且实体类实现serializable接口</li>
</ul>
<h2 id="四-核心配置文件回顾"><a href="#四-核心配置文件回顾" class="headerlink" title="四 核心配置文件回顾"></a>四 核心配置文件回顾</h2><h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><ul>
<li>加载外部的properties文件</li>
</ul>
<h3 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h3><ul>
<li>全局参数配置</li>
</ul>
<h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><ul>
<li>为 Java 类型设置一个别名</li>
</ul>
<h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><ul>
<li>加载映射配置</li>
</ul>
<h3 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h3><ul>
<li>数据源环境配置</li>
</ul>
</setting></setting></setting></mapper>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/10/Mybatis%E8%A1%A8%E5%8D%95%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Mybatis%E8%A1%A8%E5%8D%95%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">Mybatis表单查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 01:37:18" itemprop="dateCreated datePublished" datetime="2020-05-10T01:37:18+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 04:40:38" itemprop="dateModified" datetime="2022-08-10T04:40:38+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Mybatis表单查询<br>1.1 resultMap标签<br>如果数据库返回结果的列名和要封装的实体的属性名完全一致的话用 resultType 属性</p>
<p>如果数据库返回结果的列名和要封装的实体的属性名有不一致的情况用 resultMap 属性</p>
<p>使用resultMap手动建立对象关系映射</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface UserMapper {<br>    public List<User> findAll();<br>    &#x2F;&#x2F;ResultSet标签<br>    public List<User> findAllResultMap();<br>UserMapper.xml</User></User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br><mapper namespace="com.test.dao.UserMapper"><br>    <!--查询所有--><br>    <select id="findAll" resulttype="User"><br>        SELECT * FROM user<br>    </select></mapper></p>
<pre><code>&lt;!--    resultMap手动建立映射
id=&quot;userResultMap&quot;
type=&quot;com.test.domain.User&quot;建立映射的java类型
id 标签 主键
id column=&quot;uid&quot; 列名
property=&quot;id&quot;实体属性名
result 标签 普通字段
column=&quot;gender&quot;  列名
property=&quot;sex&quot; 实体属性名
--&gt;

&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;bir&quot; property=&quot;birthday&quot;/&gt;
    &lt;result column=&quot;gender&quot; property=&quot;sex&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
&lt;/resultMap&gt;

&lt;!--    模拟表与实体的属性名不一致情况--&gt;
&lt;select id=&quot;findAllResultMap&quot; resultMap=&quot;userResultMap&quot;&gt;
    SELECT id AS uid,username AS `name`,birthday AS bir,sex AS gender,address FROM `user`
&lt;/select&gt;
</code></pre>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>public class UserMapperTest {</p>
<pre><code>private SqlSession sqlSession = null;

// 此方法在测试方法执行之前，执行
@Before
public void before() &#123;
    // 获取sqlSession对象
    // 此方法必须线程内独享
    sqlSession = MyBatisUtils.openSession();
&#125;

// 此方法在测试地方法执行之后，执行
@After
public void after() &#123;
    // 关闭sqlSession
    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testFindAll() throws Exception &#123;
    // 需要通过mybatis帮你根据接口规范创建实现类
    // 创建代理对象(实现类)
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    // 执行sql
    List&lt;User&gt; list = userMapper.findAll();
    System.out.println(list);
&#125;

//resultMap标签
@Test
public void testFindAllResultMap() throws Exception &#123;
    UserMapper sessionMapper = sqlSession.getMapper(UserMapper.class);
    List&lt;User&gt; list = sessionMapper.findAllResultMap();
    for (User user : list) &#123;
        System.out.println(user);
    &#125;
&#125;
</code></pre>
<p>1.2 多条件查询<br>需求</p>
<p>根据id和username查询user表</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;多条件查询:方式一<br>public List<User> findByIdAndUsernameV1(@Param(“id”) Integer id, @Param(“username”) String username);</User></p>
<p>&#x2F;&#x2F;多条件查询:方式二<br>public List<User> findByIdAndUsernameV2(User user);<br>UserMapper.xml</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<!--    多条件查询方式
如果传递多个参数，属性省略不写-->
<select id="findByIdAndUsernameV1" resulttype="User">
SELECT * FROM user WHERE id=#{id} AND username=#{username}
</select>
  

<select id="findByIdAndUsernameV2" parametertype="User" resulttype="User">
SELECT * FROM user WHERE id=#{id} AND username=#{username}
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>&#x2F;&#x2F;多条件查询<br>&#x2F;&#x2F;V1<br>@Test<br>public void testfindByIdAndUsernameV1() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByIdAndUsernameV1(41, “老王”);<br>    System.out.println(list);<br>}</User></p>
<p>&#x2F;&#x2F;V2<br>@Test<br>public void testfindByIdAndUsernameV2() throws Exception {<br>    UserMapper sessionMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    User user &#x3D; new User();<br>    user.setId(41);<br>    user.setUsername(“W”);<br>    List<User> list &#x3D; sessionMapper.findByIdAndUsernameV2(user);<br>    System.out.println(list);<br>}<br>1.3 模糊查询<br>需求</User></p>
<p>根据username模糊查询user表</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>&#x2F;&#x2F; 模糊查询，方式一<br>public List<User> findByUsername1(String username);</User></p>
<p>&#x2F;&#x2F; 模糊查询，方式二<br>public List<User> findByUsername2(String username);</User></p>
<p>&#x2F;&#x2F; 模糊查询，方式三<br>public List<User> findByUsername3(String username);</User></p>
<p>&#x2F;&#x2F; 模糊查询，方式四<br>public List<User> findByUsername4(String username);<br>UserMapper.xml</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>    <!--    模糊查询，方式一
    java代码与sql语句有耦合--><br>    <select id="findByUsername1" parametertype="string" resulttype="User"><br>SELECT * FROM user WHERE username like #{username}<br>    </select></p>
<pre><code>&lt;!--    模糊查询，方式二
mysql5.5版本之前，此拼接不支持多个单引号
oracle数据库，除了别名的位置，其余位置都不能使用双引号--&gt;
&lt;select id=&quot;findByUsername2&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt;
</code></pre>
<p>SELECT * FROM user WHERE username like “%” #{username} “%”<br>    </p>
<pre><code>&lt;!--    此方式，会出现sql注入
$&#123;&#125; 字符串拼接，如果接收的简单数据类型，表达式名称必须是value
--&gt;
&lt;select id=&quot;findByUsername3&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt;
</code></pre>
<p>SELECT * FROM user WHERE username like ‘%${value}%’<br>    </p>
<pre><code>&lt;!--    模糊查询，方式四【掌握】--&gt;
&lt;!--    使用concat()函数拼接--&gt;
&lt;!--    注意:oracle数据库 concat()函数只能传递二个参数,可以使用函数嵌套来解决--&gt;
&lt;select id=&quot;findByUsername4&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt;
</code></pre>
<p>SELECT * FROM user WHERE username like concat(concat(‘%’,#{username}),’%’)<br>    <br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>@Test<br>public void testfindByUsername1() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername1(“%王%”);<br>    System.out.println(list);<br>}<br>@Test<br>public void testfindByUsername2() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername2(“王”);<br>    System.out.println(list);<br>}<br>@Test<br>public void testfindByUsername3() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername3(“王”);<br>    System.out.println(list);<br>}<br>@Test<br>public void testfindByUsername4() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername4(“王”);<br>    System.out.println(list);<br>}<br>1.4 ${} 与 #{} 区别<br>${} :底层 Statement</User></User></User></User></p>
<p>sql与参数拼接在一起，会出现sql注入问题<br>每次执行sql语句都会编译一次<br>接收简单数据类型，命名:{value}<br>接收引用数据类型，命名: ${属性名}<br>字符串类型需要加 ‘${value}’<br>#{}底层 PreparedStatement</p>
<p>sql与参数分离，不会出现sql注入问题<br>sql只需要编译一次<br>接收简单数据类型，命名:#{随便写}<br>接收引用数据类型，命名:#{属性名}<br>二.Mybatis映射文件深入<br>2.1 返回主键<br>应用场景</p>
<p>向数据库保存一个user对象后, 然后在控制台记录下此新增user的主键值(id)</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>public interface UserMapper {<br>&#x2F;&#x2F;    返回主键，方式一<br>    public void save1(User user);<br>&#x2F;&#x2F;    返回主键，方式二<br>    public void save2(User user);<br>}<br>UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">
    <!--
    返回主键，方式一
    useGeneratedKeys属性
    useGeneratedKeys="true" 开启新增主键返回功能
    keyColumn="id" user表中主键列
    keyProperty="id" user实体主键属性
    注意:仅支持主键自增类型的数据库 MySQL 和 SqlServer ， oracle不支持-->

<pre><code>&lt;insert id=&quot;save1&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot;&gt;
    INSERT INTO user (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)
&lt;/insert&gt;

&lt;insert id=&quot;save2&quot; parameterType=&quot;User&quot;&gt;
    &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
        SELECT LAST_INSERT_ID()
    &lt;/selectKey&gt;
    INSERT INTO user (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)
&lt;/insert&gt;
</code></pre>
</mapper>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>public class UserMapperTest {</p>
<pre><code>private SqlSession sqlSession=null;
@Before
public void before()&#123;
    sqlSession= MyBatisUtils.openSession();
&#125;
@After
public void after()&#123;
    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testSave1() throws Exception&#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setUsername(&quot;Johe Eve&quot;);
    user.setBirthday(new Date());
    user.setAddress(&quot;SZ&quot;);
    user.setSex(&quot;Male&quot;);

    userMapper.save1(user);
    System.out.println(&quot;When Insert,Primary Key Returns: &quot;+user.getId());
&#125;

@Test
public void testSave2() throws Exception&#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setUsername(&quot;Johe Eve&quot;);
    user.setBirthday(new Date());
    user.setAddress(&quot;SZ&quot;);
    user.setSex(&quot;Male&quot;);

    userMapper.save2(user);
    System.out.println(&quot;When Insert,Primary Key Returns: &quot;+user.getId());
&#125;
</code></pre>
<p>}<br>2.2 动态SQL<br>2.2.1 什么是动态SQL<br>需求</p>
<p>把id和username封装到user对象中，将user对象中不为空的属性作为查询条件</p>
<p>这个时候我们执行的sql就有多种可能</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>– 如果id和用户名不为空<br>select * from user where id&#x3D; #{id} and username &#x3D; #{username}<br>– 如果只有id<br>select * from user where id&#x3D; #{id}<br>– 如果只有用户名<br>select * from user where username &#x3D; #{username}<br>– 如果id和用户名都为空<br>select * from user<br>像上面这样, 根据传入的参数不同, 需要执行的SQL的结构就会不同，这就是动态SQL</p>
<p>2.2.2 if 条件判断<br>需求</p>
<p>把id和username封装到user对象中，将user对象中不为空的属性作为查询条件</p>
<p>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; if 条件判断<br>public List<User> findByIdAndUsernameIf(User user);<br>UserMapper.xml</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<!--
if标签 条件判断
where标签 相当于 where 1=1 功能，如果没有条件情况下 where语句不在sql语句拼接
可以去掉第一个 and 或者 or
-->
<select id="findByIdAndUsernameIf" parametertype="User" resulttype="User">
    SELECT * FROM user
    <where>
        <if test="id != null">
            AND id=#{id}
        </if>
        <if test="username != null">
            AND username = #{username}
        </if>
    </where>
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>&#x2F;&#x2F; if判断<br>@Test<br>public void testfindByIdAndUsernameIf() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>// 拼接条件
User param = new User();
param.setId(41);
param.setUsername(&quot;老王&quot;);

List&lt;User&gt; list = userMapper.findByIdAndUsernameIf(param);

for (User user : list) &#123;
    System.out.println(user);
&#125;
</code></pre>
<p>}<br>2.2.3 set 用于update语句<br>需求</p>
<p>动态更新user表数据，如果该属性有值就更新，没有值不做处理</p>
<p>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; set 更新<br>public void updateIf(User user);<br>UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<!--    set标签 更新 ，将条件中的最后一个逗号抹除-->
<update id="updateIf" parametertype="User">
    update user
    <set>
        <if test="username != null">
            username=#{username},
        </if>
        <if test="birthday != null">
            birthday=#{birthday},
        </if>
        <if test="sex != null">
            sex=#{sex},
        </if>
        <if test="address != null">
            address=#{address},
        </if>
    </set>
    where id = #{id}
</update>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>&#x2F;&#x2F;update<br>@Test<br>public void testUpdateIf() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>// 设置更新内容
User user = new User();
user.setId(57);
user.setUsername(&quot;Steve&quot;);

userMapper.updateIf(user);
</code></pre>
<p>}<br>2.2.4 foreach 用于循环遍历<br>需求</p>
<p>根据多个id查询，user对象的集合</p>
<p>1<br>SELECT * FROM user WHERE id IN (41,43,46);<br><foreach>标签用于遍历集合	属性<br>collection	代表要遍历的集合元素<br>open	代表语句的开始部分<br>close	代表结束部分<br>item	代表遍历集合的每个元素，生成的变量名<br>sperator	代表分隔符<br>练习三个版本</foreach></p>
<p>普通list集合	普通array数组	实体属性list集合<br>domain&#x2F;QueryVo</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>&#x2F;*<br>    根据页面查询条件封装到实体中 View Object<br> *&#x2F;<br>public class QueryVo {</p>
<pre><code>private List&lt;Integer&gt; ids;

public List&lt;Integer&gt; getIds() &#123;
    return ids;
&#125;

public void setIds(List&lt;Integer&gt; ids) &#123;
    this.ids = ids;
&#125;
</code></pre>
<p>}<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>&#x2F;&#x2F; foreach标签，普通list集合<br>public List<User> findByList(List<Integer> ids);<br>&#x2F;&#x2F; foreach标签，普通array数组<br>public List<User> findByArray(Integer [] ids);<br>&#x2F;&#x2F; foreach标签，实体属性list集合<br>public List<User> findByQueryVo(QueryVo queryVo);<br>UserMapper.xml</User></User></Integer></User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30</p>
<!-- foreach标签，普通list集合
    传递 普通类型list集合 collection="list"
    属性取值:collection、list
-->
<select id="findByList" parametertype="list" resulttype="User">
    SELECT * FROM user WHERE id in
    <foreach collection="list" open="(" close=")" item="id" separator=",">
        #{id}
    </foreach>
</select>

<!--    foreach标签，普通array数组
     传统 普通类型array数组 collection="array"
     属性取值 array-->
<select id="findByArray" parametertype="int" resulttype="User">
    SELECT * FROM user WHERE id in
    <foreach collection="array" open="(" close=")" item="id" separator=",">
        #{id}
    </foreach>
</select>

<!--    foreach标签，实体属性list集合
     传递 实体中list属性集合的话，collection="ids"
     取值，实体的属性名-->
<select id="findByQueryVo" parametertype="QueryVo" resulttype="User">
    SELECT * FROM user WHERE id in
    <foreach collection="ids" open="(" close=")" item="id" separator=",">
        #{id}
    </foreach>
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>&#x2F;&#x2F; foreach标签，普通list集合<br>@Test<br>public void testFindByList() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>List ids = new ArrayList();
ids.add(41);
ids.add(46);
List list = userMapper.findByList(ids);
System.out.println(list);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; foreach标签，普通array数组<br>@Test<br>public void testFindByArray() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>Integer[] ids = &#123;41, 46, 49&#125;;
List&lt;User&gt; list = userMapper.findByArray(ids);
System.out.println(list);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;    foreach标签，实体属性list集合<br>@Test<br>public void testFindByQueryVo() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>List ids= new ArrayList();
ids.add(41);
ids.add(46);
QueryVo queryVo = new QueryVo();
queryVo.setIds(ids);
List&lt;User&gt; list = userMapper.findByQueryVo(queryVo);
System.out.println(list);
</code></pre>
<p>}<br>2.3 SQL片段<br>应用场景</p>
<p>映射文件中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>    <!-- foreach标签，普通list集合
        传递 普通类型list集合 collection="list"
        属性取值:collection、list
    --><br>    <select id="findByList" parametertype="list" resulttype="User"><br>        <include refid="selectUser"></include><br>        WHERE id in<br>        <foreach collection="list" open="(" close=")" item="id" separator=","><br>            #{id}<br>        </foreach><br>    </select></p>
<pre><code>&lt;!--    foreach标签，普通array数组
     传统 普通类型array数组 collection=&quot;array&quot;
     属性取值 array--&gt;
&lt;select id=&quot;findByArray&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
    &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt;
    WHERE id in
    &lt;foreach collection=&quot;array&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
        #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/select&gt;

&lt;!--    foreach标签，实体属性list集合
     传递 实体中list属性集合的话，collection=&quot;ids&quot;
     取值，实体的属性名--&gt;
&lt;select id=&quot;findByQueryVo&quot; parameterType=&quot;QueryVo&quot; resultType=&quot;User&quot;&gt;
    &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt;
    WHERE id in
    &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
        #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/select&gt;

&lt;!-- 将当前映射文件的共同的sql代码抽取一个片段，实现sql的复用性...
</code></pre>
<p>id&#x3D;”selectUser” 当前sql片段的唯一标识 –&gt;<br>    <sql id="selectUser"><br>     select id,username,birthday,sex,address from user<br>    </sql><br>2.4 知识小结<br>MyBatis映射文件配置</p>
<p>关键字	配置<br><select>	查询<br><insert>	插入<br><update>	修改<br><delete>	删除<br><selectKey>	返回主键<br><where>	where条件<br><if>	if判断<br><foreach>	for循环<br><set>	set设置<br><sql>	sql片段抽取<br>三.表关系回顾<br>在关系型数据库当中，表关系分为三种</sql></set></foreach></if></where></selectKey></delete></update></insert></select></p>
<p>关系	说明<br>特殊情况	一个订单只能从属于一个用户，mybatis框架就把这个多对一看做成一对一来实现<br>数据建立表关系	通过主外键关联<br>实体建立关系	通过属性关联</p>
<p>四.Mybatis多表查询<br>4.1 一对一(多对一)<br>一对一查询模型</p>
<p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户</p>
<p>一对一查询的需求:查询一个订单，与此同时查询出该订单所属的用户</p>
<p>实体和表映射关系</p>
<p>1<br>SELECT * FROM orders o INNER JOIN <code>user</code> u ON o.<code>uid</code> &#x3D; u.<code>id</code> WHERE o.<code>id</code> &#x3D; 1<br>Order实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>public class Order {<br>    private Integer id;<br>    private Date ordertime;<br>    private Double money;</p>
<pre><code>// 一个订单从属于一个用户
private User user;
</code></pre>
<p> &#x2F;&#x2F;此处省略getter&#x2F;setter，toString，User实体类<br>OrderMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface OrderMapper {<br>    &#x2F;&#x2F; 一对一关联查询<br>    public Order findByIdWithUser(Integer id);<br>}<br>OrderMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.OrderMapper"></mapper></p>
<pre><code>&lt;resultMap id=&quot;orderMap&quot; type=&quot;Order&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;/&gt;
    &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;

    &lt;!--
    一对一多表关联 association标签
    property=&quot;user&quot; 关联实体的属性名 javaType=&quot;cn.test.domain.User&quot; 关联实体java类型
    --&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
        &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;

&lt;!--    一对一关联查询
    resultType:单表映射封装
    resultMap:多表查询必须手动映射封装--&gt;
&lt;select id=&quot;findByIdWithUser&quot; parameterType=&quot;int&quot; resultMap=&quot;orderMap&quot;&gt;
    SELECT * FROM orders o INNER JOIN `user` u ON o.`uid`=u.`id` WHERE o.`id`=#&#123;id&#125;
&lt;/select&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>public class OrderMapperTest {<br>    private SqlSession sqlSession &#x3D; null;</p>
<pre><code>@Before
public void before() &#123;
    sqlSession = MyBatisUtils.openSession();
&#125;

@After
public void after() &#123;
    MyBatisUtils.close(sqlSession);
&#125;

// 一对一关联测试
@Test
public void testFindByIdWithUser() throws Exception&#123;
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);

    Order order = orderMapper.findByIdWithUser(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}<br>4.2 一对多<br>一对多查询模型</p>
<p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户</p>
<p>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p>实体和表关系</p>
<p>1<br>SELECT *,o.id AS oid FROM <code>user</code> u INNER JOIN orders o ON u.<code>id</code> &#x3D; o.<code>uid</code> WHERE u.<code>id</code>&#x3D;41<br>User实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class User {<br>    private Integer id;<br>    private String username;<br>    private Date birthday;<br>    private String sex;<br>    private String address;</p>
<pre><code>// 一个用户具有多个订单
private List&lt;Order&gt; orderList;
</code></pre>
<p>  &#x2F;&#x2F;此处省略getter&#x2F;setter,toString<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface UserMapper {<br>    &#x2F;&#x2F; 一对多关联<br>    public User findByIdWithOrders(Integer id);<br>}<br>UserMapper.xml</p>
<p>有多少记录，就创建多少order对象<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;

    &lt;!--
    一对多关联 collection标签
    property=&quot;orderList&quot; 关联实体集合的属性名
    ofType=&quot;cn.itcast.domain.Order&quot; 关联实体的java类型(集合泛型的类型)
    --&gt;
    &lt;collection property=&quot;orderList&quot; ofType=&quot;Order&quot;&gt;
        &lt;id column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;

&lt;!--       一对多关联--&gt;
&lt;select id=&quot;findByIdWithOrders&quot; parameterType=&quot;int&quot; resultMap=&quot;userMap&quot;&gt;
    SELECT *,o.id AS oid FROM `user` u INNER JOIN orders `o` ON u.`id`=o.`uid` WHERE u.`id`=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
</mapper>
测试

<p>test&#x2F;BaseMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class BaseMapperTest {<br>    protected SqlSession sqlSession &#x3D; null;</p>
<pre><code>@Before
public void before() &#123;
    sqlSession = MyBatisUtils.openSession();
&#125;

@After
public void after() &#123;
    MyBatisUtils.close(sqlSession);
&#125;
</code></pre>
<p>}<br>UserMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class UserMapperTest extends BaseMapperTest{</p>
<pre><code>// 一对多测试
@Test
public void testFindByIdWithOrders() throws Exception&#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findByIdWithOrders(41);
    System.out.println(user);
&#125;
</code></pre>
<p>}<br>4.3 多对多(由二个一对多组成)<br>实体和表关系</p>
<p>1<br>2<br>3<br>4<br>SELECT * FROM <code>user</code> u<br>INNER JOIN user_role ur ON u.<code>id</code> &#x3D; ur.<code>uid</code> – 用户连接中间表<br>INNER JOIN role r ON ur.<code>rid</code> &#x3D; r.<code>id</code> – 再根据中间表连接角色<br>WHERE u.id &#x3D; 41 – 用户id 作为条件<br>User和Role实体</p>
<p>Role</p>
<p>1<br>2<br>3<br>4<br>5<br>public class Role {<br>    private Integer id;<br>    private String roleName;<br>    private String roleDesc;<br>}<br>User</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>public class User {<br>    private Integer id;<br>    private String username;<br>    private Date birthday;<br>    private String sex;<br>    private String address;</p>
<pre><code>// 一个用户具有多个订单
private List&lt;Order&gt; orderList;

// 一个用户具有多个角色
private List&lt;Role&gt; roleList;
</code></pre>
<p>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; 多对多关联<br>public User findByIdWithRoles(Integer id);<br>UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br><resultMap id="userWithRoleMap" type="User"><br>    <id column="id" property="id"></id><br>    <result column="username" property="username"></result><br>    <result column="birthday" property="birthday"></result><br>    <result column="sex" property="sex"></result><br>    <result column="address" property="address"></result></resultMap></p>
<pre><code>&lt;!--多对多实现步骤和一对多是一样的(区别在于sql语句)--&gt;
&lt;collection property=&quot;roleList&quot; ofType=&quot;Role&quot;&gt;
    &lt;id column=&quot;rid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;&gt;&lt;/result&gt;
&lt;/collection&gt;
</code></pre>



<select id="findByIdWithRoles" parametertype="int" resultmap="userWithRoleMap">
    SELECT * FROM `user` u INNER JOIN user_role ur
    ON u.`id`=ur.`uid` INNER JOIN role r ON ur.`rid`=r.`id`
    WHERE u.id=#{id}
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>@Test<br>public void testFindByIdWithRoles() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>User user = userMapper.findByIdWithRoles(41);
System.out.println(user);
</code></pre>
<p>}<br>4.4 知识小结<br>一对一配置:使用<resultMap>+<association>做配置			<br>association:		<br>property	关联的实体属性名<br>javaType	关联的实体类型(别名)<br>一对多配置:使用<resultMap>+<collection>做配置			<br>collection:		<br>property	关联的集合属性名<br>ofType	关联的集合泛型类型(别名)<br>多对多配置:使用<resultMap>+<collection>做配置			<br>collection:		<br>property	关联的集合属性名<br>ofType	关联的集合泛型类型(别名)<br>多对多的配置跟一对多很相似，难度在于SQL语句的编写。</collection></resultMap></collection></resultMap></association></resultMap></p>
<p>4.5 优化测试<br>BaseMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class BaseMapperTest {<br>    protected SqlSession sqlSession &#x3D; null;</p>
<pre><code>@Before
public void before() &#123;
    sqlSession = MyBatisUtils.openSession();
&#125;

@After
public void after() &#123;
    MyBatisUtils.close(sqlSession);
&#125;
</code></pre>
<p>}<br>OrderMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public class OrderMapperTest extends BaseMapperTest{<br>    &#x2F;&#x2F; 一对一关联测试<br>    @Test<br>    public void testFindByIdWithUser() throws Exception{<br>        OrderMapper orderMapper &#x3D; sqlSession.getMapper(OrderMapper.class);</p>
<pre><code>    Order order = orderMapper.findByIdWithUser(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">200</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
