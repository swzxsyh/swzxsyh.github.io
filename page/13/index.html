<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swzxsyh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="swzxsyh">
<meta property="og:url" content="https://swzxsyh.github.io/page/13/index.html">
<meta property="og:site_name" content="swzxsyh">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swzxsyh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swzxsyh.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>swzxsyh</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="swzxsyh" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">swzxsyh</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">--笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/20/Redis-%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Redis-%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Redis & 优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 01:39:59" itemprop="dateCreated datePublished" datetime="2020-05-20T01:39:59+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.NoSQL<br>1.1 NoSQL介绍<br>NoSQL(Not-Only SQL)，泛指非关系型的数据库，它可以作为关系型数据库的良好补充。</p>
<p>关系型数据库	非关系型数据库<br>特点	数据直接存在关联关系	数据之间没有关联关系<br>所有数据都在磁盘中	所有数据都在内存中<br>总结	存储复杂关系模型，硬盘io速度较慢	只能存储简单数据模型，内存io查询速度快<br>为什么学习NoSQL</p>
<p>高并发、高可用、高性能、海量数据</p>
<p>传统的关系型数据库出现了性能和扩展的瓶颈，所以非关系型数据库应时而生，解决了互联网产品的三 高和海量数据的问题</p>
<p>NoSQL和关系型的数据库是互补关系，在各自的应用场景中都有自己的特点，一般情况下我们使用关系 型数据库持久化数据(处理复杂的业务场景)，对一些热点数据通过NoSQL来作为缓存提高效率</p>
<p>使用后</p>
<p>先查找缓存<br>没有数据再查找数据库<br>1.2 NoSQL的主流产品<br>分类	特点	代表产品<br>键值存储	数据一般存在内存中，读写速度快(10w&#x2F;s)，适合作为缓存服务	redis<br>文档型数据库	数据结构要求不严格，适合存储结构不确定或者价值较低的数据	mongodb<br>列存储数据库	查找速度快，更容易进行分布式扩展，适合作为文件存储服务	Hbase<br>图形数据库	使用“图结构”进行存储，适合做社交网络计算等等	Neo4j<br>图形数据库介绍</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/79085901">https://blog.csdn.net/xlgen157387/article/details/79085901</a></p>
<p>二.Redis<br>2.1 Redis介绍<br>Redis(Remote Dictionary Server)是用C语言开发的一个开源的高性能键值对数据库。它的所有数据 都是保存在内存中的,这也就决定了其读写速度之快,是其它硬盘保存数据的系统所无法匹敌的。</p>
<p>官方曾经给出过一组测试数据，50个并发执行100000个请求: 读的速度是110000次&#x2F;s,写的速度是 81000次&#x2F;s</p>
<p>2.2 Redis安装和使用<br>下载</p>
<p>Reids官网地址:<a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io</a></p>
<p>中文网地址:<a target="_blank" rel="noopener" href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p>
<p>docker</p>
<p>docker pull redis</p>
<p>Linux</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>$ wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-6.0.3.tar.gz">http://download.redis.io/releases/redis-6.0.3.tar.gz</a><br>$ tar xzf redis-6.0.3.tar.gz<br>$ cd redis-6.0.3<br>$ make</p>
<p>$ src&#x2F;redis-server</p>
<p>$ src&#x2F;redis-cli<br>redis&gt; set foo bar<br>OK<br>redis&gt; get foo<br>“bar”<br>目录</p>
<p>redis.conf:配置文件</p>
<p>2.3 Redis客户端图形化工具<br>Redis Client 、Redis Desktop Manager 、Redis Studio.</p>
<p>2.4 Redis数据结构<br>Redis采用的键值对存储数据，键(key)的类型只能为字符串，值(value)支持五种数据类型:</p>
<p>K-V类型	key(字符串)	value(支持5种类型)<br>字符串：String	mystr	stringcode<br>哈希：HashMap	myhash	map集合(key:0),(value:100)<br>双向链表：LinkedList	mylist	左压栈—A-A–B–右压栈(有序且可重复)<br>无序集合：HashSet	myset	A|C|B|E|D (无序但不可重复)<br>有序集合：LinkedHashSet	myzset	A|B|C|D|E (有序但不可重复)<br>2.5 Redis命令操作<br>Redis命令是用来操作Redis数据库的, 就相当于操作MySql数据库时的SQL语句。</p>
<p>Redis的命令根据要操作的值(value)的数据结构的不同而不同, 每种数据类型都有自己的操作命令</p>
<p>2.5.1 String字符串<br>字符串类型是Redis中最为基础的数据存储类型。</p>
<p>在Redis中字符串类型的Value最多可以容纳的数据长度是512MB。</p>
<p>用法<br>新增	set key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL]<br>查询	get key<br>删除	del key [key …]<br>新增并指定存活时间	setex key seconds value<br>ttl key 查看存活时间<br>主键自增器	incr key (value默认加1)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>127.0.0.1:6379&gt; set mystr stringcode<br>OK<br>127.0.0.1:6379&gt; get mystr<br>“stringcode”<br>127.0.0.1:6379&gt; set mystr new_stringcode<br>OK<br>127.0.0.1:6379&gt; get mystr<br>“new_stringcode”<br>127.0.0.1:6379&gt; setex testcount 10 test10seconds<br>OK<br>127.0.0.1:6379&gt; ttl testcount<br>(integer) 5<br>127.0.0.1:6379&gt; get testcount<br>“test10seconds”<br>127.0.0.1:6379&gt; ttl testcount<br>(integer) -2<br>127.0.0.1:6379&gt; get testcount<br>(nil)<br>127.0.0.1:6379&gt;<br>2.5.2 Hash哈希<br>Hash类型极其类似于java中的Map,值里面可以存放一组组的键值对</p>
<p>该类型非常适合于存储java中对象的信息</p>
<p>用法<br>新增	hset key field value [field value …]<br>查询	hget key field<br>hgetall key<br>删除	hdel key field [field …]<br>del key [key …]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>127.0.0.1:6379&gt; hset user_1 name Jack<br>(integer) 1<br>127.0.0.1:6379&gt; hset user_1 age 18<br>(integer) 1<br>127.0.0.1:6379&gt; hget user_1 name<br>“Jack”<br>127.0.0.1:6379&gt; hgetall user_1</p>
<ol>
<li>“name”</li>
<li>“Jack”</li>
<li>“age”</li>
<li>“18”<br>127.0.0.1:6379&gt; hdel user_1 age<br>(integer) 1<br>127.0.0.1:6379&gt; hgetall user_1</li>
<li>“name”</li>
<li>“Jack”<br>127.0.0.1:6379&gt; del user_1<br>(integer) 1<br>127.0.0.1:6379&gt; keys *</li>
<li>“mystr”<br>127.0.0.1:6379&gt;<br>2.5.3 List列表<br>List类型底层是一个双向字符串链表。里面的元素是有序的，可重复的</li>
</ol>
<p>我们可以从链表的任何一端进行元素的增删</p>
<h1 id="redis的list是一个双向列表"><a href="#redis的list是一个双向列表" class="headerlink" title="redis的list是一个双向列表"></a>redis的list是一个双向列表</h1><p>b	<br>a<br>c<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>用法	<br>新增	lpush key element [element …]	将元素压入左侧顶端<br>rpush key element [element …]	将元素压入右侧顶端<br>查询	lrange key start stop	从左向右查询<br>0 -1 查看所有<br>删除	lpop key	将左侧顶端元素弹出<br>rpop key	将右侧顶端元素弹出<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>127.0.0.1:6379&gt; lpush mylist a<br>(integer) 1<br>127.0.0.1:6379&gt; lpush mylist b<br>(integer) 2<br>127.0.0.1:6379&gt; lpush mylist c<br>(integer) 3<br>127.0.0.1:6379&gt; lrange mylist 0 -1</p>
<ol>
<li>“c”</li>
<li>“b”</li>
<li>“a”<br>127.0.0.1:6379&gt; rpush mylist a<br>(integer) 4<br>127.0.0.1:6379&gt; lrange mylist 0 -1</li>
<li>“c”</li>
<li>“b”</li>
<li>“a”</li>
<li>“a”<br>127.0.0.1:6379&gt; lpop mylist<br>“c”<br>127.0.0.1:6379&gt; rpop mylist<br>“a”<br>127.0.0.1:6379&gt; lrange mylist 0 -1</li>
<li>“b”</li>
<li>“a”<br>127.0.0.1:6379&gt;<br>2.5.4 Set集合（无序）<br>Set类型底层是一张hash表。里面的元素是无序的，不可重复的</li>
</ol>
<p>用法	<br>新增	sadd key member [member …]	新增指定key元素<br>查询	smembers key	查询指定key元素<br>删除	srem key member [member …]	删除指定元素<br>del key [key …]	删除整个set集合<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>127.0.0.1:6379&gt; sadd myset a<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset b<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset c<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset f<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset e<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset d<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset a<br>(integer) 0<br>127.0.0.1:6379&gt; smembers myset</p>
<ol>
<li>“c”</li>
<li>“f”</li>
<li>“b”</li>
<li>“e”</li>
<li>“a”</li>
<li>“d”<br>127.0.0.1:6379&gt; srem myset a<br>(integer) 1<br>127.0.0.1:6379&gt; smembers myset</li>
<li>“c”</li>
<li>“f”</li>
<li>“b”</li>
<li>“e”</li>
<li>“d”<br>127.0.0.1:6379&gt; del myset<br>(integer) 1<br>127.0.0.1:6379&gt; smembers myset<br>(empty array)<br>127.0.0.1:6379&gt;<br>2.5.5 ZSet集合（有序）<br>Zset,也称sortedSet, 在Set的基础上，加入了有序功能，在添加元素的时候，允许指定一个分数，它会 按照这个分数排序</li>
</ol>
<p>用法	<br>新增	zadd key [NX | XX] [CH] [INCR] score member [score member …]	新增指定key元素<br>查询	zrange key start stop [WITHSCORES]	升序<br>zrevrange key start stop [WITHSCORES]	降序<br>删除	zrem key member [member …]	删除指定元素<br>del key [key …]	删除整个zset集合<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>127.0.0.1:6379&gt; zadd myzset 10 aaaaa<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myzset 30 bbbbb<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myzset 20 ccccc<br>(integer) 1<br>127.0.0.1:6379&gt; zrange myzset 0 100</p>
<ol>
<li>“aaaaa”</li>
<li>“ccccc”</li>
<li>“bbbbb”<br>127.0.0.1:6379&gt; zrange myzset 0 100 withscores</li>
<li>“aaaaa”</li>
<li>“10”</li>
<li>“ccccc”</li>
<li>“20”</li>
<li>“bbbbb”</li>
<li>“30”<br>127.0.0.1:6379&gt; zrevrange myzset 0 100</li>
<li>“bbbbb”</li>
<li>“ccccc”</li>
<li>“aaaaa”<br>127.0.0.1:6379&gt; zrevrange myzset 0 100 withscores</li>
<li>“bbbbb”</li>
<li>“30”</li>
<li>“ccccc”</li>
<li>“20”</li>
<li>“aaaaa”</li>
<li>“10”<br>127.0.0.1:6379&gt; zrem myzset aaaaa<br>(integer) 1<br>127.0.0.1:6379&gt; zrevrange myzset 0 100</li>
<li>“bbbbb”</li>
<li>“ccccc”<br>127.0.0.1:6379&gt; del myzset<br>(integer) 1<br>127.0.0.1:6379&gt; zrevrange myzset 0 100<br>(empty array)<br>127.0.0.1:6379&gt;<br>2.5.6 通用命令<br>命令<br>模糊查询键	keys *<br>删除多个键	del key [key …]<br>根据键判断记录是否存在	exists key[key …]<br>根据键判断值类型	type key<br>选择数据库	select index (0~15)<br>清空当前数据库	flushdb [ASYNC]<br>清空所有数据库	flushall [ASYNC]<br>2.6 Redis持久化<br>Redis的数据都是存在在内存之中的，那么这样一旦出现宕机，势必会导致数据的丢失，这就需要持久化操作，也就是要将redis在内存中的数据写到硬盘上保存。</li>
</ol>
<p>注意，redis虽然有持久化操作，但是其全部数据依旧都在内存中存在,也就是说硬盘上的只是为了安全和备份。</p>
<p>Redis提供了两种数据持久化的方式，分别是 RDB 和 AOF</p>
<p>RDB:默认开启</p>
<p>在redis运行期间，根据指定时间节点对内存的数据进行快照拍摄，持久化到磁盘文件(dump.rdb文件) 指定时间规则拍摄快照</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>cat redis.conf | tail -n +265 | head -n 25    </p>
<p>################################ SNAPSHOTTING  ################################<br>#</p>
<h1 id="Save-the-DB-on-disk"><a href="#Save-the-DB-on-disk" class="headerlink" title="Save the DB on disk:"></a>Save the DB on disk:</h1><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="save"><a href="#save" class="headerlink" title="save  "></a>save <seconds> <changes></changes></seconds></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h1 id="Will-save-the-DB-if-both-the-given-number-of-seconds-and-the-given"><a href="#Will-save-the-DB-if-both-the-given-number-of-seconds-and-the-given" class="headerlink" title="Will save the DB if both the given number of seconds and the given"></a>Will save the DB if both the given number of seconds and the given</h1><h1 id="number-of-write-operations-against-the-DB-occurred"><a href="#number-of-write-operations-against-the-DB-occurred" class="headerlink" title="number of write operations against the DB occurred."></a>number of write operations against the DB occurred.</h1><h1 id="-2"><a href="#-2" class="headerlink" title></a></h1><h1 id="In-the-example-below-the-behaviour-will-be-to-save"><a href="#In-the-example-below-the-behaviour-will-be-to-save" class="headerlink" title="In the example below the behaviour will be to save:"></a>In the example below the behaviour will be to save:</h1><h1 id="after-900-sec-15-min-if-at-least-1-key-changed"><a href="#after-900-sec-15-min-if-at-least-1-key-changed" class="headerlink" title="after 900 sec (15 min) if at least 1 key changed"></a>after 900 sec (15 min) if at least 1 key changed</h1><h1 id="after-300-sec-5-min-if-at-least-10-keys-changed"><a href="#after-300-sec-5-min-if-at-least-10-keys-changed" class="headerlink" title="after 300 sec (5 min) if at least 10 keys changed"></a>after 300 sec (5 min) if at least 10 keys changed</h1><h1 id="after-60-sec-if-at-least-10000-keys-changed"><a href="#after-60-sec-if-at-least-10000-keys-changed" class="headerlink" title="after 60 sec if at least 10000 keys changed"></a>after 60 sec if at least 10000 keys changed</h1><h1 id="-3"><a href="#-3" class="headerlink" title></a></h1><h1 id="Note-you-can-disable-saving-completely-by-commenting-out-all-“save”-lines"><a href="#Note-you-can-disable-saving-completely-by-commenting-out-all-“save”-lines" class="headerlink" title="Note: you can disable saving completely by commenting out all “save” lines."></a>Note: you can disable saving completely by commenting out all “save” lines.</h1><h1 id="-4"><a href="#-4" class="headerlink" title></a></h1><h1 id="It-is-also-possible-to-remove-all-the-previously-configured-save"><a href="#It-is-also-possible-to-remove-all-the-previously-configured-save" class="headerlink" title="It is also possible to remove all the previously configured save"></a>It is also possible to remove all the previously configured save</h1><h1 id="points-by-adding-a-save-directive-with-a-single-empty-string-argument"><a href="#points-by-adding-a-save-directive-with-a-single-empty-string-argument" class="headerlink" title="points by adding a save directive with a single empty string argument"></a>points by adding a save directive with a single empty string argument</h1><h1 id="like-in-the-following-example"><a href="#like-in-the-following-example" class="headerlink" title="like in the following example:"></a>like in the following example:</h1><h1 id="-5"><a href="#-5" class="headerlink" title></a></h1><h1 id="save-“”"><a href="#save-“”" class="headerlink" title="save “”"></a>save “”</h1><p>#1个key修改，15min后拍摄一次快照<br>save 900 1<br>#10个key修改，5min后拍摄一次快照<br>save 300 10<br>#10000个key修改，1min后拍摄一次快照<br>save 60 10000<br>AOF:默认关闭，需要手动开启</p>
<p>在redis运行期间，以日志记录的方式监听set操作，持久化到磁盘文件(appendonly.aof)</p>
<p>开启AOF:修改 redis.conf配置</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>cat redis.conf | tail -n +1018 | head -n 53          </p>
<p>############################## APPEND ONLY MODE ###############################</p>
<p>……</p>
<h1 id="Please-check-http-redis-io-topics-persistence-for-more-information"><a href="#Please-check-http-redis-io-topics-persistence-for-more-information" class="headerlink" title="Please check http://redis.io/topics/persistence for more information."></a>Please check <a target="_blank" rel="noopener" href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a> for more information.</h1><p>#若开启设置为yes<br>appendonly no</p>
<h1 id="The-name-of-the-append-only-file-default-“appendonly-aof”"><a href="#The-name-of-the-append-only-file-default-“appendonly-aof”" class="headerlink" title="The name of the append only file (default: “appendonly.aof”)"></a>The name of the append only file (default: “appendonly.aof”)</h1><p>appendfilename “appendonly.aof”</p>
<h1 id="The-fsync-call-tells-the-Operating-System-to-actually-write-data-on-disk"><a href="#The-fsync-call-tells-the-Operating-System-to-actually-write-data-on-disk" class="headerlink" title="The fsync() call tells the Operating System to actually write data on disk"></a>The fsync() call tells the Operating System to actually write data on disk</h1><h1 id="instead-of-waiting-for-more-data-in-the-output-buffer-Some-OS-will-really-flush"><a href="#instead-of-waiting-for-more-data-in-the-output-buffer-Some-OS-will-really-flush" class="headerlink" title="instead of waiting for more data in the output buffer. Some OS will really flush"></a>instead of waiting for more data in the output buffer. Some OS will really flush</h1><h1 id="data-on-disk-some-other-OS-will-just-try-to-do-it-ASAP"><a href="#data-on-disk-some-other-OS-will-just-try-to-do-it-ASAP" class="headerlink" title="data on disk, some other OS will just try to do it ASAP."></a>data on disk, some other OS will just try to do it ASAP.</h1><h1 id="-6"><a href="#-6" class="headerlink" title></a></h1><p>……</p>
<p>#日志持久化机制</p>
<p>#每次执行set操作时都会持久化一次</p>
<h1 id="appendfsync-always"><a href="#appendfsync-always" class="headerlink" title="appendfsync always"></a>appendfsync always</h1><p>#每秒持久化一次<br>appendfsync everysec</p>
<p>#根据服务器，cpu处于idle情况，持久化一次</p>
<h1 id="appendfsync-no"><a href="#appendfsync-no" class="headerlink" title="appendfsync no"></a>appendfsync no</h1><p>2.6.1 知识小结<br>这二种持久化机制可以共存</p>
<p>RDB:把redis作为缓存来用	AOF:把redis作为独立数据库<br>优点	性能高	几乎不会丢失数据<br>缺点	可能会丢失部分数据	性能较差<br>2.7 应用场景<br>2.7.1 缓存<br>将一些经常访问但又不会经常修改的数据，进行缓存，提高查询效率</p>
<p>2.7.2 秒杀<br>浏览器	➡秒杀	redis服务器	➡同步	MySQL<br>商品		扣库存		同步数据<br>生成订单		<br>支付发货		<br>2.7.3 微博热搜<br>微博app	➡	redis<br>微博热搜		ZSet评分有序集合<br>2.7.4 分布式session<br>User	➡	Tomcat服务器	➡	redis<br>第一次访问	Server_1	设置	<br>User				User<br>第二次访问	Server_2	查询	<br>2.7.5 验证码存储<br>网站	➡	redis<br>发送短信		手机号:6位随机验证码<br>精准控制session只有5min<br>三.Jedis<br>3.1 Jedis使用<br>Redis作为一款优秀的缓存服务器存在，大多数语言都提供了连接Redis的驱动包，在java中，比较出名</p>
<p>的是Jedis和Redisson，我们今天以Jedis为例学习，看看如何是用程序操作redis。</p>
<p>常用API</p>
<p>方法	解释<br>new Jedis(host, port)	创建jedis对象，参数host是redis服务器地址，参数port是redis服务端口<br>set(key,value)	设置字符串类型的数据<br>get(key)	获得字符串类型的数据<br>hset(key,field,value)	设置哈希类型的数据<br>hget(key,field)	获得哈希类型的数据<br>lpush(key,values)	设置列表类型的数据<br>lpop(key)	列表左面弹栈<br>rpop(key)	列表右面弹栈<br>del(key)	删除指定的key<br>快速入门</p>
<p>导入相关坐标</p>
<p>1<br>2<br>3<br>4<br>5<br>6</p>
<!--jedis-->
<dependency>
  <groupId>redis.clients</groupId>
  <artifactId>jedis</artifactId>
  <version>2.9.0</version>
</dependency>
编写代码

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>public class JedisTest {</p>
<p>  &#x2F;&#x2F; 快速入门之，向redis设置string类型的数据<br>  @Test<br>  public void testSet() throws Exception{<br>    &#x2F;&#x2F; 1.创建连接对象<br>    &#x2F;&#x2F; 默认连接 127.0.0.1 主机 和 6379 端口<br>    Jedis jedis &#x3D; new Jedis();<br>    &#x2F;&#x2F; 2.调用set方法设置数据<br>    jedis.set(“Java”, “Hello,World”);<br>    &#x2F;&#x2F; 3.释放资源<br>    jedis.close();<br>  }</p>
<p>  &#x2F;&#x2F; 快速入门之，查询string类型数据<br>  @Test<br>  public void testQuery() throws Exception{<br>    &#x2F;&#x2F; 1.创建连接对象<br>    Jedis jedis &#x3D; new Jedis();<br>    &#x2F;&#x2F; 2.调用get方法获取<br>    String java &#x3D; jedis.get(“Java”);<br>    System.out.println(java);<br>    &#x2F;&#x2F; 3.释放资源<br>    jedis.close();<br>  }<br>}<br>3.2 Jedis连接池<br>jedis连接资源的创建与销毁是非常消耗性能的，所以我们不希望频繁的创建和销毁它.基于这样的需求,就有了JedisPool技术。</p>
<p>快速入门</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>public class JedisPoolTest {<br>  &#x2F;&#x2F; 测试jedis内置的连接池<br>  @Test<br>  public void testJedisPool() throws Exception {</p>
<pre><code>// 0.连接池配置对象
JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
// 最大连接数
jedisPoolConfig.setMaxTotal(100);
// 最大等待时间，单位是毫秒
jedisPoolConfig.setMaxWaitMillis(3000);
// 最大空闲连接数
jedisPoolConfig.setMaxIdle(10);

// 1.创建连接池对象
JedisPool jedisPool = new JedisPool();

// 2.从池中获取连接
Jedis jedis = jedisPool.getResource();

// 3.操作api
jedis.hset(&quot;myhash&quot;, &quot;id&quot;, &quot;1&quot;);

// 4.归还到连接池
jedis.close();
</code></pre>
<p>  }<br>}<br>抽取为连接池工具类</p>
<p>1<br>2<br>3<br>4<br>jedis.host&#x3D;localhost<br>jedis.port&#x3D;6379<br>jedis.maxTotal&#x3D;20<br>jedis.maxIdle&#x3D;10<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>public class JedisUtils {</p>
<p>  private static JedisPool jedisPool;</p>
<p>  private static String host;<br>  private static Integer port;<br>  private static Integer maxTotal;<br>  private static Integer maxIdle;</p>
<p>  &#x2F;&#x2F; 初始化连接池<br>  static {<br>    try {</p>
<pre><code>  ResourceBundle jedis = ResourceBundle.getBundle(&quot;jedis&quot;);

  // 读取配置文件给变量赋值
  // 获取类加载读取 jedis.properties 获取io流
  InputStream is = JedisUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);
  // 创建properties对象 加载io流
  Properties properties = new Properties();
  properties.load(is);
  // 给变量赋值
  host = properties.getProperty(&quot;jedis.host&quot;);
  port = Integer.parseInt(properties.getProperty(&quot;jedis.port&quot;));
  maxTotal = Integer.parseInt(properties.getProperty(&quot;jedis.maxTotal&quot;));
  maxIdle = Integer.parseInt(properties.getProperty(&quot;jedis.maxIdle&quot;));

  // 创建连接池配置对象
  JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
  jedisPoolConfig.setMaxTotal(maxTotal);
  jedisPoolConfig.setMaxIdle(maxIdle);
  // 创建连接池对象
  jedisPool = new JedisPool(jedisPoolConfig, host, port);
&#125; catch (IOException e) &#123;
  e.printStackTrace();
&#125;
</code></pre>
<p>  }</p>
<p>  &#x2F;&#x2F; 提供获取jedis连接的方法<br>  public static Jedis getJedis() {<br>    return jedisPool.getResource();<br>  }<br>}<br>四.<br>4.1 缓存：导航条分类<br>4.1.1 需求分析<br>前端页面	➡	JavaServer	➡	SQL<br>首页 门票 周边游		CategroyService	➡	NoSQL<br>先查询缓存(redis)，有就直接返回		redis<br>没有，再查MySQL，先同步到redis再返回	➡	MySQL<br>List<Categroy> list;<br>将list转为json数组字符串返回		<br>4.1.2 代码实现<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>public class CategoryServiceImpl implements CategoryService {<br>  @Override<br>  public List<Category> findAll() {</Category></Categroy></p>
<pre><code>//        SqlSession sqlSession = MyBatisUtils.openSession();
//        CategoryDao categoryDao = sqlSession.getMapper(CategoryDao.class);
//
//        List&lt;Category&gt; categoryList = categoryDao.findAll();
//
//        MyBatisUtils.close(sqlSession);

List&lt;Category&gt; categoryList = null;
ObjectMapper objectMapper = new ObjectMapper();

Jedis jedis = JedisUtils.getJedis();

if (jedis.exists(&quot;travel_category&quot;)) &#123;
  String json = jedis.get(&quot;travel_category&quot;);

  try &#123;
    categoryList = objectMapper.readValue(json, List.class);
    System.out.println(&quot;Find In Redis&quot;);
  &#125; catch (IOException e) &#123;
    e.printStackTrace();
  &#125;
&#125; else &#123;
  SqlSession sqlSession = MyBatisUtils.openSession();
  CategoryDao categoryDao = sqlSession.getMapper(CategoryDao.class);

  categoryList = categoryDao.findAll();

  MyBatisUtils.close(sqlSession);

  try &#123;
    String json = objectMapper.writeValueAsString(categoryList);
    jedis.set(&quot;travel_category&quot;, json);
  &#125; catch (IOException e) &#123;
    e.printStackTrace();
  &#125;

&#125;
jedis.close();


return categoryList;
</code></pre>
<p>  }<br>}<br>4.2 短信验证码存活时间5分钟<br>4.2.1 需求分析</p>
<p>4.2.2 代码实现<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>protected void sendSms(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {<br>  &#x2F;&#x2F; 1.获取请求参数<br>  String telephone &#x3D; req.getParameter(“telephone”);<br>  &#x2F;&#x2F; 2.生成6位随机数(apache提供的)<br>  String smsCode &#x3D; RandomStringUtils.randomNumeric(6);<br>  &#x2F;&#x2F; 3.调用service完成短信发送，返回resultInfo<br>  ResultInfo resultInfo &#x3D; userService.sendSms(telephone, smsCode);</p>
<p>  &#x2F;&#x2F; 4.如果发送成功，将验证码写入到session中<br>  &#x2F;&#x2F;        if (resultInfo.getSuccess()) {<br>  &#x2F;&#x2F;            req.getSession().setAttribute(“smsCode_” + telephone, smsCode);<br>  &#x2F;&#x2F;            System.out.println(“smsCode: “ + smsCode);<br>  &#x2F;&#x2F;        }</p>
<p>  &#x2F;&#x2F; 4.如果发送成功，将验证码写入到session中<br>  if (resultInfo.getSuccess()) {</p>
<pre><code>// a.获取jedis连接
Jedis jedis = JedisUtils.getJedis();

// b.将验证码设置到jedis中，存活1分钟
jedis.setex(&quot;smsCode_&quot; + telephone, 60, smsCode);

// c.释放资源
jedis.close();
System.out.println(&quot;smsCode: &quot; + smsCode);
</code></pre>
<p>  }<br>  javaToJsonWriteClient(resultInfo, resp);</p>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>protected void register(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {</p>
<p>  &#x2F;&#x2F; a.获取请求参数<br>  String telephone &#x3D; req.getParameter(“telephone”);<br>  String smsCode &#x3D; req.getParameter(“smsCode”);</p>
<p>  &#x2F;&#x2F; b.获取session中验证码<br>  &#x2F;&#x2F;        String sessionCode &#x3D; (String) req.getSession().getAttribute(“smsCode_” + telephone);</p>
<p>  Jedis jedis &#x3D; JedisUtils.getJedis();<br>  String sessionCode &#x3D; jedis.get(“smsCode_” + telephone);</p>
<p>  &#x2F;&#x2F; c.进行校验<br>  if (sessionCode &#x3D;&#x3D; null || (!sessionCode.equals(smsCode))) {</p>
<pre><code>// 验证码不正确
req.setAttribute(&quot;resultInfo&quot;, new ResultInfo(false, &quot;SMS Code not correct&quot;));
req.getRequestDispatcher(&quot;/register.jsp&quot;).forward(req, resp);
return;
</code></pre>
<p>  }</p>
<p>  &#x2F;&#x2F;获取请求参数<br>  Map&lt;String, String[]&gt; parameterMap &#x3D; req.getParameterMap();</p>
<p>  &#x2F;&#x2F;封装User中<br>  User param &#x3D; new User();</p>
<p>  try {<br>    BeanUtils.populate(param, parameterMap);<br>  } catch (Exception e) {<br>    throw new RuntimeException(“Entity class encapsulation failed”);<br>  }</p>
<p>  &#x2F;&#x2F;调用service，实现注册<br>  ResultInfo resultInfo &#x3D; userService.register(param);</p>
<p>  if (resultInfo.getSuccess()) {<br>    resp.sendRedirect(req.getContextPath() + “&#x2F;register_ok.jsp”);<br>    &#x2F;&#x2F;            req.getSession().removeAttribute(“smsCode_” + telephone);<br>    &#x2F;&#x2F; d.升级为，清除redis<br>    jedis.del(“smsCode” + telephone);<br>  } else {<br>    req.setAttribute(“resultInfo”, resultInfo);<br>    req.getRequestDispatcher(“&#x2F;register.jsp”).forward(req, resp);<br>  }<br>  jedis.close();<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>protected void telLogin(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>  &#x2F;&#x2F; 1.接收请求参数telephone<br>  String telephone &#x3D; req.getParameter(“telephone”);</p>
<p>  &#x2F;&#x2F; 2.调用service查询<br>  User currentUser &#x3D; userService.findByTelephone(telephone);</p>
<p>  &#x2F;&#x2F; 3.校验手机号<br>  ResultInfo resultInfo &#x3D; null;</p>
<p>  &#x2F;&#x2F; 4.3 校验<br>  if (currentUser &#x3D;&#x3D; null) {<br>    resultInfo &#x3D; new ResultInfo(false, “Phone Number not Registered”);<br>  } else {<br>    &#x2F;&#x2F;成功<br>    String smsCode &#x3D; req.getParameter(“smsCode”);</p>
<pre><code>//            String sessionCode = (String) req.getSession().getAttribute(&quot;smsCode_&quot; + telephone);

// 升级为从redis中获取
Jedis jedis = JedisUtils.getJedis();
String sessionCode = jedis.get(&quot;smsCode_&quot; + telephone);

if (sessionCode == null || (!sessionCode.equals(smsCode))) &#123;
  resultInfo = new ResultInfo(false, &quot;Wrong SMS Code&quot;);
&#125; else &#123;
  req.getSession().setAttribute(&quot;currentUser&quot;, currentUser);
  // 清除session中验证码
  resultInfo = new ResultInfo(true, &quot;Login Success&quot;);

  //req.getSession().removeAttribute(&quot;smsCode_&quot; + telephone);
  // 清除redis中验证码
  jedis.del(&quot;smsCode_&quot; + telephone);
&#125;
// 释放资源
jedis.close();
</code></pre>
<p>  }<br>  &#x2F;&#x2F;将resultInfo转为Json响应到客户端<br>  javaToJsonWriteClient(resultInfo, resp);<br>}<br>总结</p>
<h2 id="一-NoSQL"><a href="#一-NoSQL" class="headerlink" title="一 NoSQL"></a>一 NoSQL</h2><h3 id="非关系型数据库，not-only-sql，弥补关系型数据库一些不足"><a href="#非关系型数据库，not-only-sql，弥补关系型数据库一些不足" class="headerlink" title="非关系型数据库，not only sql，弥补关系型数据库一些不足"></a>非关系型数据库，not only sql，弥补关系型数据库一些不足</h3><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>关系性</li>
</ul>
<p>​ - 1）数据之间存在关联关系</p>
<p>​ - 2）数据存储在硬盘</p>
<ul>
<li>非关系型</li>
</ul>
<p>​ - 1）数据之间不存在关联关系</p>
<p>​ - 2）数据存储在内存</p>
<h3 id="解决：互联和行业特点"><a href="#解决：互联和行业特点" class="headerlink" title="解决：互联和行业特点"></a>解决：互联和行业特点</h3><ul>
<li><p>高并发</p>
</li>
<li><p>高性能</p>
</li>
<li><p>高可用</p>
</li>
<li><p>海量数据</p>
</li>
</ul>
<h3 id="nosql分类"><a href="#nosql分类" class="headerlink" title="nosql分类"></a>nosql分类</h3><ul>
<li>键值对</li>
</ul>
<p>​ - redis</p>
<ul>
<li>文档类型（json）</li>
</ul>
<p>​ - mongoDB</p>
<ul>
<li>列存储</li>
</ul>
<p>​ - hbase</p>
<ul>
<li>图形（关系结构）</li>
</ul>
<h2 id="二-Redis"><a href="#二-Redis" class="headerlink" title="二 Redis"></a>二 Redis</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>C语言编写高性能键值对数据库</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>string</p>
</li>
<li><p>hash</p>
</li>
<li><p>linkedList</p>
</li>
<li><p>hashset</p>
</li>
<li><p>linkedHashSet</p>
</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>字符串</li>
</ul>
<p>​ - set key value</p>
<p>​ - get key</p>
<p>​ - del key</p>
<p>​ - setex key 存活时间 value</p>
<p>​ - incr key</p>
<p>​ - value+1</p>
<ul>
<li>哈希</li>
</ul>
<p>​ - hset key hkey hvalue</p>
<p>​ - hget key hkey</p>
<p>​ - hgetall key</p>
<p>​ - hrem key hkey</p>
<p>​ - del key</p>
<ul>
<li>列表</li>
</ul>
<p>​ - lpush key value</p>
<p>​ - rpush key value</p>
<p>​ - lrange key 0 -1</p>
<p>​ - lpop key</p>
<p>​ - rpop key</p>
<p>​ - del key</p>
<ul>
<li>集合</li>
</ul>
<p>​ - sadd key value</p>
<p>​ - smembers key</p>
<p>​ - srem key value</p>
<ul>
<li>有序集合</li>
</ul>
<p>​ - zadd key score value</p>
<p>​ - zrange key 0 -1 withscores</p>
<p>​ - zrevrange key 0 -1 withscores</p>
<p>​ - zrem key value</p>
<ul>
<li>通用命令</li>
</ul>
<p>​ - keys *</p>
<p>​ - del key1 key2 key3</p>
<p>​ - exists key</p>
<p>​ - type key</p>
<p>​ - select 0~15</p>
<p>​ - flushdb</p>
<p>​ - flushal</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li>RDB</li>
</ul>
<p>​ - 默认开启，在指定间隔时间将内存的数据拍摄快照，持久化到磁盘</p>
<p>​ - 1）优点：性能高</p>
<p>​ - 2）缺点：丢失数据</p>
<ul>
<li>AOF</li>
</ul>
<p>​ - 手动开启，根据日志记录方式监听redis的写（set）操作，持久化到磁盘</p>
<p>​ - 1）优点：保证数据的安全</p>
<p>​ - 2）缺点：性能稍差</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>1）缓存</p>
</li>
<li><p>2）秒杀</p>
</li>
<li><p>3）微博热搜</p>
</li>
<li><p>4）验证码存储</p>
</li>
<li><p>5）分布式session</p>
</li>
</ul>
<h2 id="三-Jedis"><a href="#三-Jedis" class="headerlink" title="三 Jedis"></a>三 Jedis</h2><h3 id="通过java语言操作redis，api与redis命令相似"><a href="#通过java语言操作redis，api与redis命令相似" class="headerlink" title="通过java语言操作redis，api与redis命令相似"></a>通过java语言操作redis，api与redis命令相似</h3><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul>
<li><p>1）导入jar坐标</p>
</li>
<li><p>2）编写代码</p>
</li>
</ul>
<p>​ - &#x2F;&#x2F;1.创建连接对象</p>
<p>​ - &#x2F;&#x2F;2.操作api</p>
<p>​ - &#x2F;&#x2F;3.关闭连接</p>
<h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/14/Maven%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/Maven%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Maven基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 01:39:29" itemprop="dateCreated datePublished" datetime="2020-05-14T01:39:29+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Maven简介<br>1.1 Maven是什么<br>Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM:Project Object Model)，一组标准集合，一个项 目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周 期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p>
<p>1.2 Maven能解决什么问题<br>一种工具，可以构建工程，管理 jar包，编译代码，还 能帮你自动运行单元测试，打包，生成报表，部署项目，生成 Web 站点。</p>
<p>1.3 Maven的两个核心功能<br>1.3.1 依赖管理<br>Maven的一个核心特性就是依赖管理。MVN依赖管理，就是一个管理jar包的过程</p>
<p>CRM项目<br>使用mvn工程实现	➡项目中给定坐标，去仓库拉取jar包➡<br>索引的存在，使拉取jar包过程，可以认为是自己项目中有的	MVN仓库<br>jar的仓库<br>坐标:将来要找某个jar包，就是要确定这个jar包的坐标	<br>jar包如何给出坐标:公司&#x2F;组织名+项目名+版本号一起确定	<br>maven工程中不直接将jar包导入到工程中，而是通过在pom.xml文件中添加所需jar包的坐标，避免了jar直接引入进来，在需要用到jar包的时候，只要查找pom.xml文件，再通过pom.xml文件中的坐标，到一个专门用于”存放jar包的仓库”(maven仓库)中根据坐标从而找到这些jar包，再把这些jar包拿去运行。</p>
<p>通过读取pom.xml 文件中的坐标，再到仓库中找到jar包，会不会很慢</p>
<p>通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包，为了解决这个过程中速度慢的问题，maven中也有索引的概念，通过建立索引，可以大大提高加载jar包的速度，使得我们认为jar包基本跟放在本地的工程文件中再读取出来的速度是一样的。</p>
<p>1.3.2 项目构建<br>什么是项目构建</p>
<p>项目从编译、测试、运行、打包、安装 ，部署整个过程都交给maven进行管理，这个过程称为构建。</p>
<p>一键构建 指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。</p>
<p>Maven规范化构建流程</p>
<p>清理	➡	编译	➡	测试	➡	报告	➡	打包	➡	部署<br>二 Maven安装和使用<br>2.1 Maven下载和安装<br>2.1.1 Maven下载<br>Maven官网下载地址:<a target="_blank" rel="noopener" href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></p>
<p>目前使用@3.5版本</p>
<p>2.1.2 Maven安装<br>将apache-maven-3.5.2-bin.zip解压并添加至path</p>
<p>maven目录结构</p>
<p>目录	介绍<br>bin	存放了 maven 的命令<br>boot	存放了一些 maven 本身的引导程序，如类加载器等<br>conf	存放了 maven 的一些配置文件，如 setting.xml 文件<br>lib	存放了 maven 本身运行所需的一些 jar 包<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>apache-maven-3.5.2<br>├── LICENSE<br>├── NOTICE<br>├── README.txt<br>├── bin<br>│   ├── m2.conf<br>│   ├── mvn<br>│   ├── mvn.cmd<br>│   ├── mvnDebug<br>│   ├── mvnDebug.cmd<br>│   └── mvnyjp<br>├── boot<br>│   └── plexus-classworlds-2.5.2.jar<br>├── conf<br>│   ├── logging<br>│   ├── settings.xml<br>│   └── toolchains.xml<br>└── lib<br>    ├── aopalliance-1.0.jar<br>        ├── …省略<br>    └── wagon-provider-api.license</p>
<p>7 directories, 91 files<br>2.1.3 Maven及JDK配置<br>Maven 3.3+ require JDK 1.7 or above to execute - they still allow you to build against 1.3 and other JDK versions by Using Toolchains</p>
<p>配置PATH</p>
<p>1<br>2<br>3<br>4<br>5<br>vi .zshrc</p>
<p>#MAVEN_HOME<br>export MAVEN_HOME&#x3D;&#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;apache-maven-3.5.2<br>export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin<br>2.1.4 Maven软件版本测试<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br> ~ #mvn -v<br>Apache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)<br>Maven home: &#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;apache-maven-3.5.2<br>Java version: 1.8.0_221, vendor: Oracle Corporation<br>Java home: &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_221.jdk&#x2F;Contents&#x2F;Home&#x2F;jre<br>Default locale: en_CN, platform encoding: UTF-8<br>OS name: “mac os x”, version: “10.15.4”, arch: “x86_64”, family: “mac”<br>2.3 Maven仓库<br>2.3.1 Maven仓库的分类<br>Maven仓库分为本地仓库和远程仓库二大类。而远程仓库又可分成中央仓库，私服，第三方仓库。</p>
<p>Maven仓库	<br>本地仓库		远程仓库<br>⬇<br>中央仓库<br>私服<br>第三方公共库<br>依赖寻找流程</p>
<p>在本地仓库中，根据Maven坐标系寻找指定依赖，如果存在，直接返回。</p>
<p>如果Maven仓库中不存在，或者需要检查依赖的版本时，maven则会去远程仓库中寻找，下载到本地仓库中再使 用。</p>
<p>本地仓库</p>
<p>用来存储从远程仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找。</p>
<p>中央仓库</p>
<p>在maven软件中内置一个远程仓库地址<a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。</p>
<p>第三方公共库</p>
<p>Maven 仓库默认中央仓库在国外且只有一个， 国内使用难免很慢，我们可以更换为第三方公共库，例如:阿里云镜 像。</p>
<p>私服</p>
<p>私服是一种特殊的远程仓库，其内容是来自于其他的远程仓库，一般架设在局域网内，提供给一个组织的人员使用。 当Maven需要下载依赖时，从私服请求，如果私服上不存在该依赖，则从其他远程仓库下载，同时缓存在私服上，提 供给其他人使用。如果项目中的一些内部模块，无法发布到外部远程仓库中，也可发布在私服上，提供给项目中的其 他人员使用。</p>
<p>2.3.2 Maven本地仓库的配置<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>cd  $MAVEN_HOME&#x2F;conf<br>vi settings.xml</p>
<h1 id="找到"><a href="#找到" class="headerlink" title="找到"></a>找到</h1><p><settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"><br>  <!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: ${user.home}/.m2/repository
  <localRepository>/path/to/local/repo</localRepository>
  --><br>  将<localRepository>&#x2F;path&#x2F;to&#x2F;local&#x2F;repo</localRepository>改为本地仓库路径添加到注释后<br>2.3.4 Maven仓库国内镜像配置<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br><mirrors><br>  <!-- mirror
   | Specifies a repository mirror site to use instead of a given repository. The repository that
   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
   |
  <mirror>
    <id>mirrorId</id>
    <mirrorOf>repositoryId</mirrorOf>
    <name>Human Readable Name for this Mirror.</name>
    <url>http://my.repository.com/repo/path</url>
  </mirror>
   --><br>  <!-- 添加阿里云镜像 --><br><mirror><br>    <id>alimaven</id><br>    <name>aliyun maven</name><br>    <url><a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></url><br>    <mirrorOf>central</mirrorOf><br>  </mirror><br></mirrors><br>2.3.4 全局setting与用户setting<br>maven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。</settings></p>
<p>在maven安装目录下 的有 conf&#x2F;setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。 如需要 个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在:${user.dir} &#x2F;.m2&#x2F;settings.xml目录 中,${user.dir} 指windows 中的用户目录。</p>
<p>maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全 局配置文件。</p>
<p>2.3 Maven坐标和依赖<br>Maven的一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。为了能自动化的解析任何一个Java构 件，Maven必须将这些Jar包或者其他资源进行唯一标识，这是管理项目的依赖的基础，也就是我们要说的坐标。包 括我们自己开发的项目，也是要通过坐标进行唯一标识的，这样才能才其它项目中进行依赖引用。</p>
<p>坐标的定义元素如下</p>
<p>元素	作用<br>groupId	定义当前Maven项目名称<br>artifactId	定义项目模块<br>version	定义当前项目的当前版本<br>例如</p>
<p>创建一个Maven的web项目，在pom.xml文件中生成坐标</p>
<p>1<br>2<br>3<br>4<br>5</p>
<!--当前项目坐标--> 
<p><groupId>com.test</groupId><br><artifactId>maven_helloword</artifactId><br><version>1.0-SNAPSHOT</version><br><packaging>war</packaging><br>要引入junit的测试jar，只需要在pom.xml配置文件中配置引入junit的坐标依赖即可</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<!-- 依赖关系 --> 
<dependencies>
<!-- 此项目运行使用junit，所以此项目依赖junit --> 
  <dependency>
<!-- junit的项目名称 --> 
    <groupId>junit</groupId>
<!-- junit的模块名称 --> 
    <artifactId>junit</artifactId> <!-- junit版本 --> 
    <version>4.12</version>
<!-- 依赖范围:单元测试时使用junit -->
        <scope>test</scope>
    </dependency>
</dependencies>
2.4 Maven工程的认识
2.4.1 Maven工程的目录结构
作为一个maven工程，它的src目录和pom.xml是必备的。

<p>1<br>2<br>3<br>4<br>├── maven_java.iml<br>├── pom.xml<br>├── src<br>└── target<br>进入src目录后，我们发现它里面的目录结构如下</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>src<br>├── main<br>│   ├── java					#项目代码<br>│   ├── resources			#配置文件<br>│   └── webapp				#页面资源<br>└── test<br>        ├── java					#测试代码<br>    └──resources 					</p>
<p>6 directories, 0 files<br>文件	说明<br>src&#x2F;main&#x2F;java	存放项目的.java文件<br>src&#x2F;main&#x2F;resources	存放项目资源文件，如spring, mybatis配置文件<br>src&#x2F;test&#x2F;java	存放所有单元测试.java文件，如junit测试类<br>src&#x2F;test&#x2F;resources	测试资源文件<br>target	项目输出位置，编译后的class文件会输出到此目录<br>pom.xml	maven项目核心配置文<br>注意:如果是普通的java项目，那么就没有webapp目录。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>完整java项目<br>    java工程名（项目名）<br>        |– src目录<br>            |– main目录（主干代码）<br>                |– java目录（java代码）<br>                |– resources目录（配置文件）<br>            |– test目录（测试代码）<br>                |– java目录（java代码）<br>                |– resources目录（配置文件）<br>        |– pom.xml（maven工程核心配置文件）<br>        |– target目录（存放编译后的class文件…..）</p>
<ul>
<li>web项目【重点】<br>  web工程名（项目名）<br>  |– src目录<br>      |– main目录（主干代码）<br>          |– java目录（java代码）<br>          |– resources目录（配置文件）<br>          |– webapp目录（页面资源）<br>              |– WEB-INF<br>                  |– web.xml(web工程核心配置文件)<br>              |– index.jsp<br>              |– css、js、img..<br>      |– test目录（测试代码）<br>          |– java目录（java代码）<br>          |– resources目录（配置文件）<br>  |– pom.xml（maven工程核心配置文件）<br>  |– target目录（存放编译后的class文件…..）<br>2.4.2 Maven工程的运行<br>进入maven工程目录(当前目录有pom.xml文件)，运行tomcat7:run命令</li>
</ul>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>~ mvn tomcat7:run</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] &gt;&gt;&gt; tomcat7-maven-plugin:2.2:run (default-cli) &gt; process-classes @ maven_web &gt;&gt;&gt;<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 1 source file to &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;classes<br>[INFO]<br>[INFO] &lt;&lt;&lt; tomcat7-maven-plugin:2.2:run (default-cli) &lt; process-classes @ maven_web &lt;&lt;&lt;<br>[INFO]<br>[INFO]<br>[INFO] — tomcat7-maven-plugin:2.2:run (default-cli) @ maven_web —<br>[INFO] Running war on <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a><br>[INFO] Creating Tomcat server configuration at &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;tomcat<br>[INFO] create webapp with contextPath:<br>May 15, 2020 10:29:37 PM org.apache.coyote.AbstractProtocol init<br>INFO: Initializing ProtocolHandler [“http-bio-8080”]<br>May 15, 2020 10:29:37 PM org.apache.catalina.core.StandardService startInternal<br>INFO: Starting service Tomcat<br>May 15, 2020 10:29:37 PM org.apache.catalina.core.StandardEngine startInternal<br>INFO: Starting Servlet Engine: Apache Tomcat&#x2F;7.0.47<br>May 15, 2020 10:29:38 PM org.apache.coyote.AbstractProtocol start<br>INFO: Starting ProtocolHandler [“http-bio-8080”]<br>根据上边的提示信息,访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 即可</p>
<p>三.Maven生命周期和插件<br>3.1 Maven常用命令和插件<br>3.1.1 clean<br>clean是maven工程的清理命令，执行 clean会删除target目录及内容。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>~ mvn clean</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-clean-plugin:2.5:clean (default-clean) @ maven_web —<br>[INFO] Deleting &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 0.228 s<br>[INFO] Finished at: 2020-05-15T23:52:52+08:00<br>[INFO] Final Memory: 9M&#x2F;309M<br>[INFO] ————————————————————————<br>3.1.2 compile<br>compile是maven工程的编译命令，作用是将src&#x2F;main&#x2F;java下的文件编译为class文件输出到target目录下。</p>
<p>将src中main目录下java代码进行编译，将src中main目录下配置抽取，输出到target目录: classes目录</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>~ mvn compile</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 1 source file to &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;classes<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 0.952 s<br>[INFO] Finished at: 2020-05-15T23:56:28+08:00<br>[INFO] Final Memory: 13M&#x2F;209M<br>[INFO] ————————————————————————</p>
<p>～ ll  .&#x2F;target&#x2F;classes&#x2F;cn&#x2F;itcast&#x2F;web&#x2F;servlet&#x2F;</p>
<p>total 8<br>-rw-r–r–  1 swzxsyh  staff   1.1K May 15 23:56 HelloServlet.class<br>3.1.3 test<br>test是maven工程的测试命令 mvn test，会执行src&#x2F;test&#x2F;java下的单元测试类，并编译为class文件。</p>
<p>mvn test&#x3D;&gt;target编译main代码&#x3D;&gt;编译test代码&#x3D;&gt;执行所有测试代码，类名xxxTest结尾，必须有@Test注解的方法</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>~ mvn test</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO] </p>
<p>#清理target目录<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>#编译src&#x2F;main主干<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>#编译src&#x2F;test测试目录<br>[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven_web —<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 1 source file to &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;test-classes<br>[INFO] </p>
<h1 id="针对test目录下的测试代码，逐一测试"><a href="#针对test目录下的测试代码，逐一测试" class="headerlink" title="针对test目录下的测试代码，逐一测试"></a>针对test目录下的测试代码，逐一测试</h1><p>[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ maven_web —<br>[INFO] Surefire report directory: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;surefire-reports</p>
<hr>
<h2 id="T-E-S-T-S"><a href="#T-E-S-T-S" class="headerlink" title=" T E S T S"></a> T E S T S</h2><p>Running cn.itcast.test.HelloTest<br>仅在测试期有效<br>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.065 sec</p>
<p>Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>
<p>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 1.509 s<br>[INFO] Finished at: 2020-05-16T00:00:02+08:00<br>[INFO] Final Memory: 15M&#x2F;212M<br>[INFO] ————————————————————————<br>3.1.4 package<br>package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。</p>
<p>mvn package&#x3D;&gt;编译main代码&#x3D;&gt;编译test代码&#x3D;&gt;执行测试&#x3D;&gt;将项目打成war包</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>~ mvn package</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ maven_web —<br>[INFO] Surefire report directory: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;surefire-reports</p>
<hr>
<h2 id="T-E-S-T-S-1"><a href="#T-E-S-T-S-1" class="headerlink" title=" T E S T S"></a> T E S T S</h2><p>Running cn.itcast.test.HelloTest<br>仅在测试期有效<br>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.048 sec</p>
<p>Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>
<p>[INFO]<br>[INFO] — maven-war-plugin:2.2:war (default-war) @ maven_web —<br>[INFO] Packaging webapp<br>[INFO] Assembling webapp [maven_web] in [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT]<br>[INFO] Processing war project<br>[INFO] Copying webapp resources [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;src&#x2F;main&#x2F;webapp]<br>[INFO] Webapp assembled in [49 msecs]<br>[INFO] Building war: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war<br>[INFO] WEB-INF&#x2F;web.xml already added, skipping<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 1.528 s<br>[INFO] Finished at: 2020-05-16T00:05:14+08:00<br>[INFO] Final Memory: 12M&#x2F;294M<br>[INFO] ————————————————————————</p>
<p>~ find . -name ‘*war’<br>.&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war<br>#此包可以直接放在tomcat的webapp下执行<br>注意：为什么maven_hello是war包而不是jar包呢？</p>
<p>1<br>2<br>3<br>cat pom.xml| grep -ri ‘packaging’<br>(standard input):    <packaging>war</packaging><br>#导包方式：jar默认，手动指定war<br>3.1.5 install<br>install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。</p>
<p>mvn install&#x3D;&gt;编译main代码&#x3D;&gt;编译test代码&#x3D;&gt;执行测试&#x3D;&gt;将项目打成war包&#x3D;&gt;安装到本地库</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>~ mvn install</p>
<p>[INFO] Scanning for projects…<br>[INFO]<br>[INFO] ————————————————————————<br>[INFO] Building maven_web 1.0-SNAPSHOT<br>[INFO] ————————————————————————<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:resources (default-resources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:compile (default-compile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-resources-plugin:2.6:testResources (default-testResources) @ maven_web —<br>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] Copying 0 resource<br>[INFO]<br>[INFO] — maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven_web —<br>[INFO] Nothing to compile - all classes are up to date<br>[INFO]<br>[INFO] — maven-surefire-plugin:2.12.4:test (default-test) @ maven_web —<br>[INFO] Surefire report directory: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;surefire-reports</p>
<hr>
<h2 id="T-E-S-T-S-2"><a href="#T-E-S-T-S-2" class="headerlink" title=" T E S T S"></a> T E S T S</h2><p>Running cn.itcast.test.HelloTest<br>仅在测试期有效<br>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.053 sec</p>
<p>Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</p>
<p>[INFO]<br>[INFO] — maven-war-plugin:2.2:war (default-war) @ maven_web —<br>[INFO] Packaging webapp<br>[INFO] Assembling webapp [maven_web] in [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT]<br>[INFO] Processing war project<br>[INFO] Copying webapp resources [&#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;src&#x2F;main&#x2F;webapp]<br>[INFO] Webapp assembled in [32 msecs]<br>[INFO] Building war: &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war<br>[INFO] WEB-INF&#x2F;web.xml already added, skipping<br>[INFO] </p>
<h1 id="将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署"><a href="#将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署" class="headerlink" title="将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署"></a>将自己的代码，编译到本地仓库，之后可以上传到远程仓库，服务器自动下载部署</h1><p>[INFO] — maven-install-plugin:2.4:install (default-install) @ maven_web —<br>[INFO] Installing &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;target&#x2F;maven_web-1.0-SNAPSHOT.war to &#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;repository&#x2F;cn&#x2F;itcast&#x2F;maven_web&#x2F;1.0-SNAPSHOT&#x2F;maven_web-1.0-SNAPSHOT.war<br>[INFO] Installing &#x2F;Users&#x2F;swzxsyh&#x2F;Downloads&#x2F;Day54-maven基础&amp;环境搭建&#x2F;代码&#x2F;maven_web&#x2F;pom.xml to &#x2F;Users&#x2F;swzxsyh&#x2F;Program&#x2F;repository&#x2F;cn&#x2F;itcast&#x2F;maven_web&#x2F;1.0-SNAPSHOT&#x2F;maven_web-1.0-SNAPSHOT.pom<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 1.522 s<br>[INFO] Finished at: 2020-05-16T00:08:09+08:00<br>[INFO] Final Memory: 12M&#x2F;297M<br>[INFO] ————————————————————————<br>从运行结果中，可以看出: 当后面的命令执行时，前面的操作过程也都会自动执行</p>
<p>3.1.6 deploy<br>maven工程部署命令，将jar或war包部署（上传）到私服中。</p>
<p>3.2 Maven生命周期<br>maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”。</p>
<p>在同一个生命周期中的命令,执行后面的命令,前面的命令自动执行</p>
<p>三套名称	描述	命令<br>Clean Lifecycle	在进行真正的构建之前进行一些清理工作。	clean<br>Default Lifecycle	构建的核心部分，编译，测试，打包，部署等等。	compile,test,package,install,deploy<br>Site Lifecycle	生成项目报告，站点，发布站点。	site<br>3.2.1 clean生命周期 clean生命周期的目的是清理项目<br>阶段	描述<br>pre-clean	执行一些需要在clean之前完成的工作<br>clean	移除所有上一次构建生成的文件<br>post-clean	执行一些需要在clean之后立刻完成的工作<br>3.2.2 default生命周期<br>default生命周期定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分</p>
<p>生命周期阶段	描述<br>validate(校验)	校验项目是否正确并且所有必要的信息可以完成项目的构建过程。<br>initialize(初始化)	初始化构建状态，比如设置属性值。<br>generate-sources(生成源代码)	生成包含在编译阶段中的任何源代码。<br>process-sources(处理源代码)	处理源代码，比如说，过滤任意值。<br>generate-resources(生成资源文件)	生成将会包含在项目包中的资源文件。<br>process-resources (处理资源文件)	复制和处理资源到目标目录，为打包阶段最好准备。<br>compile(编译)	编译项目的源代码。<br>process-classes(处理类文件)	处理编译生成的文件，比如说对Java class文件做字节码改善优化。<br>generate-test-sources(生成测试源代 码)	生成包含在编译阶段中的任何测试源代码。<br>process-test-sources(处理测试源代 码)	处理测试源代码，比如说，过滤任意值。<br>generate-test-resources(生成测试资源 文件)	为测试创建资源文件。<br>process-test-resources(处理测试资源 文件)	复制和处理测试资源到目标目录。<br>test-compile(编译测试源码)	编译测试源代码到测试目标目录.<br>process-test-classes(处理测试类文件)	处理测试源码编译生成的文件。<br>test(测试)	使用合适的单元测试框架运行测试(Juint是其中之一)。<br>prepare-package(准备打包)	在实际打包之前，执行任何的必要的操作为打包做准备。<br>package(打包)	将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者 EAR文件。<br>pre-integration-test(集成测试前)	在执行集成测试前进行必要的动作。比如说，搭建需要的环境。<br>integration-test(集成测试)	处理和部署项目到可以运行集成测试环境中。<br>post-integration-test(集成测试后)	在执行集成测试完成后进行必要的动作。比如说，清理集成测试 环境。<br>verify (验证)	运行任意的检查来验证项目包有效且达到质量标准。<br>install(安装)	安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。<br>deploy(部署)	将最终的项目包复制到远程仓库中与其他开发者和项目共享。<br>3.2.3 site生命周期<br>site生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团 队交流和发布项目信息。</p>
<p>阶段	描述<br>pre-site	执行一些需要在生成站点文档之前完成的工作<br>site	生成项目的站点文档<br>post-site	执行一些需要在生成站点文档之后完成的工作，并且为部署做准备<br>site-deploy	将生成的站点文档部署到特定的服务器上<br>3.3 Maven概念模型<br>Maven 包含了一个项目对象模型 (POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插 件(plugin)目标(goal)的逻辑。</p>
<p>项目对象模型 (Project Object Model)</p>
<p>一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。</p>
<p>依赖管理系统(Dependency Management System)</p>
<p>通过maven的依赖管理对项目所依赖的jar 包进行统一管理。比如:项目依赖junit4.12，通过在pom.xml中定义 junit4.12的依赖即使用junit4.12，如下所示是junit4.12的依赖定义:</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<!-- 依赖关系 --> <dependencies>
<!-- 此项目运行使用junit，所以此项目依赖junit --> <dependency>
<!-- junit的项目名称 --> <groupId>junit</groupId>
<!-- junit的模块名称 --> <artifactId>junit</artifactId> <!-- junit版本 --> <version>4.12</version>
<!-- 依赖范围:单元测试时使用junit -->
<pre><code>    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</dependency></dependencies>
一个项目生命周期(Project Lifecycle)

<p>使用maven完成项目的构建，项目构建包括:清理、编译、测试、部署等过程，maven将这些过程规范为一个生命</p>
<p>周期</p>
<p>清理	➡	编译	➡	测试	➡	报告	➡	打包	➡	部署<br>一组标准集合</p>
<p>maven将整个项目管理过程定义一组标准。</p>
<p>比如:通过maven构建工程有标准的目录结构，有标准的生命周期阶 段、依赖管理有标准的坐标定义等。</p>
<p>插件(plugin)目标(goal)</p>
<p>maven 管理项目生命周期过程都是基于插件完成的。</p>
<p>四.IDEA创建Maven工程<br>4.1 IDEA配置本地Maven<br>进入configure–&gt;settings–&gt;build–&gt;build tools–&gt;Maven中，设置maven工具和本地仓库</p>
<p>进入configure–&gt;settings–&gt;build–&gt;build tools–&gt;Maven–&gt;Runner中，设置VM Options:-DarchetypeCatalog&#x3D;internal -Dfile.encoding&#x3D;GB2312</p>
<p>4.2 IDEA创建工程<br>Java工程</p>
<p>选择Maven，下一步，设置GroupID域名倒写，ArtifactID项目名，Version版本号</p>
<p>手动创建test测试配置文件目录</p>
<p>test目录右击创建resources目录，然后Mark Directory AS选Resources Root</p>
<p>指定maven环境的jdk版本和字符集</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<!-- pom.xml -->

<build>
    <plugins>
        <!-- 设置编译版本为1.8 -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.1</version>
            <configuration>
                <source>1.8
                <target>1.8</target>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
    </plugins>
</build>
maven工程命令操作

<p>打开右侧maven栏，双击命令即可</p>
<p>如何导入依赖</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<!-- pom.xml -->  

<!--依赖管理-->
  <dependencies>
    <!--mysql驱动-->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.47</version>
      <scope>runtime</scope>
    </dependency>
</dependencies>
安装一个插件JBLJavaToWeb

<p>点击项目，选择插件功能JBLJavaToWeb即可将Java项目转换为Web项目</p>
<p>4.3 发布web工程<br>idea使用外置tomcat运行</p>
<p>Add Configurations–&gt;ADD&#x3D;&gt;Tomcat(Local)，设置名称Tomcat，其他跟之前项目一样</p>
<p>idea使用maven内置tomcat插件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br><build><br>        <plugins><br>            <!-- 设置编译版本为1.8 --><br>            <plugin><br>                <groupId>org.apache.maven.plugins</groupId><br>                <artifactId>maven-compiler-plugin</artifactId><br>                <version>3.1</version><br>                <configuration><br>                    <source>1.8<br>                    <target>1.8</target><br>                    <encoding>UTF-8</encoding><br>                </configuration><br>            </plugin><br>            <plugin><br>                <groupId>org.apache.tomcat.maven</groupId><br>                <artifactId>tomcat7-maven-plugin</artifactId><br>                <version>2.2</version><br>                <configuration><br>                    <port>8080</port><br>                    <path></path>&#x2F;<br>                    <uriEncoding>utf-8</uriEncoding><br>                </configuration><br>            </plugin><br>        </plugins><br>    </build><br>4.4 依赖管理<br>我们不考虑依赖范围引起的问题</p>
<p>依赖范围	对于编译classpath有效	对于测试classpath有效	对于运行时classpath有效	例子<br>compile（默认）	Y	Y	Y	mybatis<br>test	-	Y	-	junit<br>provided	Y	Y	-	servlet-api<br>runtime	-	Y	Y	JDBC驱动<br>system	Y	Y	-	本地，maven仓库之外的库<br>依赖范围	描述<br>compile	默认依赖范围，作用域在编译、测试、运行时都有效。<br>test	作用域在测试时有效。编译和运行时不需要，比如：Junit。<br>provided	作用域在编译、测试时有效。运行时不需要，比如： servlet api 被 tomcat 容器提供。<br>runtime	作用域在测试、运行时有效。编译时不需要，比如：jdbc的驱动包。<br>system	system范围依赖与provided类似，jar包在本地磁盘而不是maven仓库<br>在maven_web工程中测试scope:</p>
<p>默认引入 的jar包</p>
<p>compile 【默认范围 可以不写】(编译、测试、运行 都有效 )</p>
<p>servlet-api 、jsp-api</p>
<p>provided (编译、测试 有效， 运行时无效 防止和tomcat下jar冲突)</p>
<p>jdbc驱动jar包</p>
<p>runtime (测试、运行 有效 )</p>
<p>junit</p>
<p>test (测试有效)</p>
<p>依赖范围由强到弱的顺序是:compile&gt;provided&gt;runtime&gt;test</p>
<p>总结</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h3><ul>
<li>依赖管理</li>
</ul>
<p>​ - 通过maven管理jar包的整个过程</p>
<ul>
<li>一键构建</li>
</ul>
<p>​ - 通过一个maven的一个命令就可以完成工程整个构建的过程</p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h3><ul>
<li><p>下载 3.5.2 版本</p>
</li>
<li><p>安装解压到非中文路径</p>
</li>
<li><p>配置MAVEN_HOME环境变量</p>
</li>
</ul>
<p>​ - 依赖java环境</p>
<h2 id="仓库分类"><a href="#仓库分类" class="headerlink" title="仓库分类"></a>仓库分类</h2><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li><p>1.中央仓库</p>
</li>
<li><p>2.第三方远程仓库</p>
</li>
</ul>
<p>​ - 阿里云镜像</p>
<ul>
<li>3.私服</li>
</ul>
<h3 id="配置指定本地仓库"><a href="#配置指定本地仓库" class="headerlink" title="配置指定本地仓库"></a>配置指定本地仓库</h3><ul>
<li>帅哥提供5G</li>
</ul>
<p>​ - 不建议覆盖</p>
<h3 id="配置阿里云镜像"><a href="#配置阿里云镜像" class="headerlink" title="配置阿里云镜像"></a>配置阿里云镜像</h3><ul>
<li>提高下载速度</li>
</ul>
<h2 id="命令和插件"><a href="#命令和插件" class="headerlink" title="命令和插件"></a>命令和插件</h2><h3 id="1）clean"><a href="#1）clean" class="headerlink" title="1）clean"></a>1）clean</h3><ul>
<li>清理target目录</li>
</ul>
<h3 id="2）compile"><a href="#2）compile" class="headerlink" title="2）compile"></a>2）compile</h3><ul>
<li>编译 src&#x2F;main&#x2F;java</li>
</ul>
<h3 id="3）test"><a href="#3）test" class="headerlink" title="3）test"></a>3）test</h3><ul>
<li>测试 src&#x2F;test&#x2F;java</li>
</ul>
<h3 id="4）package"><a href="#4）package" class="headerlink" title="4）package"></a>4）package</h3><ul>
<li>将工程进行打包</li>
</ul>
<p>​ - jar</p>
<p>​ - war</p>
<h3 id="5）install"><a href="#5）install" class="headerlink" title="5）install"></a>5）install</h3><ul>
<li>将打包后的工程安装到本地仓库</li>
</ul>
<h3 id="6）deploy"><a href="#6）deploy" class="headerlink" title="6）deploy"></a>6）deploy</h3><ul>
<li>将本地仓库的jar包或war包上传到私服</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="清理生命周期"><a href="#清理生命周期" class="headerlink" title="清理生命周期"></a>清理生命周期</h3><ul>
<li>clean</li>
</ul>
<h3 id="默认生命周期"><a href="#默认生命周期" class="headerlink" title="默认生命周期"></a>默认生命周期</h3><ul>
<li>compile</li>
</ul>
<p>​ - test</p>
<p>​ - package</p>
<p>​ - install</p>
<p>​ - deploy</p>
<h3 id="站点生命周期"><a href="#站点生命周期" class="headerlink" title="站点生命周期"></a>站点生命周期</h3><ul>
<li>site</li>
</ul>
<h2 id="IDEA配置maven工具"><a href="#IDEA配置maven工具" class="headerlink" title="IDEA配置maven工具"></a>IDEA配置maven工具</h2><h3 id="全局settings配置"><a href="#全局settings配置" class="headerlink" title="全局settings配置"></a>全局settings配置</h3><ul>
<li><p>指定maven工具路径</p>
</li>
<li><p>指定maven工具配置文件路径</p>
</li>
<li><p>指定maven工具本地仓库的路径</p>
</li>
</ul>
<h3 id="指定本地创建maven时，使用本地骨架"><a href="#指定本地创建maven时，使用本地骨架" class="headerlink" title="指定本地创建maven时，使用本地骨架"></a>指定本地创建maven时，使用本地骨架</h3><ul>
<li>-DarchetypeCatalog&#x3D;internal -Dfile.encoding&#x3D;GB2312</li>
</ul>
<h2 id="IDEA创建maven工程"><a href="#IDEA创建maven工程" class="headerlink" title="IDEA创建maven工程"></a>IDEA创建maven工程</h2><h3 id="1-创建java工程"><a href="#1-创建java工程" class="headerlink" title="1)创建java工程"></a>1)创建java工程</h3><h3 id="2）创建web工程"><a href="#2）创建web工程" class="headerlink" title="2）创建web工程"></a>2）创建web工程</h3><ul>
<li>下载JBLJavaToWeb插件</li>
</ul>
<h2 id="IDEA发布web工程"><a href="#IDEA发布web工程" class="headerlink" title="IDEA发布web工程"></a>IDEA发布web工程</h2><h3 id="1）使用本地tomcat"><a href="#1）使用本地tomcat" class="headerlink" title="1）使用本地tomcat"></a>1）使用本地tomcat</h3><h3 id="2）使用tomcat插件"><a href="#2）使用tomcat插件" class="headerlink" title="2）使用tomcat插件"></a>2）使用tomcat插件</h3><ul>
<li>pom.xml</li>
</ul>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><h3 id="1）我们编写的web工程需要手动导入servlet-api-坐标"><a href="#1）我们编写的web工程需要手动导入servlet-api-坐标" class="headerlink" title="1）我们编写的web工程需要手动导入servlet-api 坐标"></a>1）我们编写的web工程需要手动导入servlet-api 坐标</h3><h3 id="2）在打成-war包的时候将servlet-api-设置到-x2F-WEB-INF-x2F-lib目录下"><a href="#2）在打成-war包的时候将servlet-api-设置到-x2F-WEB-INF-x2F-lib目录下" class="headerlink" title="2）在打成 war包的时候将servlet-api 设置到 &#x2F;WEB-INF&#x2F;lib目录下"></a>2）在打成 war包的时候将servlet-api 设置到 &#x2F;WEB-INF&#x2F;lib目录下</h3><h3 id="3）如果与tomcat软件内置的版本不一致，可能会启动报错"><a href="#3）如果与tomcat软件内置的版本不一致，可能会启动报错" class="headerlink" title="3）如果与tomcat软件内置的版本不一致，可能会启动报错"></a>3）如果与tomcat软件内置的版本不一致，可能会启动报错</h3><h3 id="4）需要指定jar包的作用范围（provided）"><a href="#4）需要指定jar包的作用范围（provided）" class="headerlink" title="4）需要指定jar包的作用范围（provided）"></a>4）需要指定jar包的作用范围（provided）</h3><h3 id="有哪些依赖范围呢？"><a href="#有哪些依赖范围呢？" class="headerlink" title="有哪些依赖范围呢？"></a>有哪些依赖范围呢？</h3><ul>
<li>compile</li>
</ul>
<p>​ - 默认，在编译、测试、运行期有效</p>
<ul>
<li>test</li>
</ul>
<p>​ - 仅在测试期有效</p>
<ul>
<li>provided</li>
</ul>
<p>​ - 在编译、测试期有效</p>
<ul>
<li>runtime</li>
</ul>
<p>​ - 在测试、运行期有效</p>
<ul>
<li>system</li>
</ul>
<p>​ - 从本地中导入jar包</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/13/MyBatis%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/MyBatis%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">MyBatis注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-13 01:38:24" itemprop="dateCreated datePublished" datetime="2020-05-13T01:38:24+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.MyBatis注解<br>1.1 MyBatis常用注解<br>注解	作用<br>@Insert	实现新增，代替了<insert></insert><br>@Update	实现更新，代替了<update></update><br>@Delete	实现删除，代替了<delete></delete><br>@Select	实现查询，代替了<select></select><br>@Result	实现结果集封装，代替了<result></result><br>@Results	可以与@Result 一起使用，封装多个结果集，代替了<resultMap></resultMap><br>@One	实现一对一结果集封装，代替了<association></association><br>@Many	实现一对多结果集封装，代替了<collection></collection><br>1.2 MyBatis 单表操作<br>需求</p>
<p>基于user模块通过注解实现，增删改查</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>public interface UserMapper {</p>
<pre><code>//查询所有
@Select(&quot;SELECT id AS uid,username AS uname,birthday AS bir,sex AS gender,address AS addr FROM user&quot;)
@Results(value = &#123;
        //resultMap标签手动映射封装
        @Result(column = &quot;uid&quot;, property = &quot;id&quot;, id = true),
        @Result(column = &quot;uname&quot;, property = &quot;username&quot;),
        @Result(column = &quot;bir&quot;, property = &quot;birthday&quot;),
        @Result(column = &quot;gender&quot;, property = &quot;sex&quot;),
        @Result(column = &quot;addr&quot;, property = &quot;address&quot;)
&#125;)
public List&lt;User&gt; findAll();


//id查询
@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)
public User findById(Integer id);


//新增
@Insert(&quot;INSERT INTO user (username,birthday,sex,address) VALUES(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&quot;)
public void save(User user);


//修改(动态sql推荐使用xml)
@Update(&quot;UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id = #&#123;id&#125;&quot;)
public void update(User user);

//删除
@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)
public void delete(Integer id);
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>public class UserMapperTest extends BaseMapperTest {<br>    &#x2F;&#x2F;单表测试<br>    @Test<br>    public void testFindAll() throws Exception {<br>        UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>        List<User> list &#x3D; userMapper.findAll();<br>        System.out.println(list);<br>    }</User></p>
<pre><code>//单表测试,查询一个
@Test
public void testFindById() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findById(41);
    System.out.println(user);
&#125;

//新增
@Test
public void testInsert() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setUsername(&quot;A&quot;);
    user.setBirthday(new Date());
    user.setAddress(&quot;GZ&quot;);
    user.setSex(&quot;Male&quot;);
    userMapper.save(user);
&#125;

//修改
@Test
public void testUpdate() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setId(58);
    user.setUsername(&quot;B&quot;);
    userMapper.save(user);
&#125;

//删除
@Test
public void testDelete() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    userMapper.delete(58);
&#125;
</code></pre>
<p>}<br>1.3 MyBatis多表操作<br>注解多表操作是基于嵌套查询来实现</p>
<p>注解	说明<br>@Results	结果映射的列表，包含了一个特别结果列如何被映射到属性或字段的详情。属性有：value, id。value 属性是 Result 注解的数组。这个 id 的属性是结果映射的名称。<br>@Result	在列和属性或字段之间的单独结果映射。属性有：id, column, javaType, jdbcType, typeHandler, one, many。id 属性是一个布尔值，来标识应该被用于比较（和在 XML 映射中的相似）的属性。one 属性是单独的联系，和 相似，而 many 属性是对集合而言的，和相似。它们这样命名是为了避免名称冲突。<br>@One	复杂类型的单独属性值映射。属性有：select，已映射语句（也就是映射器方法）的全限定名，它可以加载合适类型的实例。fetchType会覆盖全局的配置参数 lazyLoadingEnabled。注意 联合映射在注解 API中是不支持的。这是因为 Java 注解的限制,不允许循环引用。<br>@Many	映射到复杂类型的集合属性。属性有：select，已映射语句（也就是映射器方法）的全限定名，它可以加载合适类型的实例的集合，fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。注意 联合映射在注解 API中是不支持的。这是因为 Java 注解的限制，不允许循环引用<br>1.3.1 一对一查询<br>需求</p>
<p>查询一个订单，与此同时查询出该订单所属的用户</p>
<p>一对一查询语句</p>
<p>1<br>2<br>SELECT * FROM orders where id &#x3D; #{id};<br>SELECT * FROM <code>user</code> WHERE id &#x3D; #{订单的uid};<br>OrderMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>public interface OrderMapper {</p>
<pre><code>//一对一嵌套注解
@Select(&quot;SELECT * FROM orders WHERE id = #&#123;id&#125;&quot;)
@Results(value = &#123;
        //resultMap标签手动映射封装
        @Result(column = &quot;uid&quot;, property = &quot;id&quot;, id = true),
        @Result(column = &quot;uname&quot;, property = &quot;username&quot;),
        @Result(column = &quot;bir&quot;, property = &quot;birthday&quot;),
        @Result(column = &quot;gender&quot;, property = &quot;sex&quot;),
        @Result(column = &quot;addr&quot;, property = &quot;address&quot;),
        @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.test.dao.UserMapper.findById&quot;,fetchType = FetchType.EAGER))

&#125;)
public Order findByIdWithUsers(Integer id);
</code></pre>
<p>}<br>UserMapper接口</p>
<p>1<br>2<br>3<br>&#x2F;&#x2F;id查询<br>@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>public User findById(Integer id);<br>注解嵌套</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>public interface OrderMapper {</p>
<pre><code>//一对一嵌套注解
@Select(&quot;SELECT * FROM orders WHERE id = #&#123;id&#125;&quot;)
@Results(value = &#123;
        //resultMap标签手动映射封装
        @Result(column = &quot;uid&quot;, property = &quot;id&quot;, id = true),
        @Result(column = &quot;uname&quot;, property = &quot;username&quot;),
        @Result(column = &quot;bir&quot;, property = &quot;birthday&quot;),
        @Result(column = &quot;gender&quot;, property = &quot;sex&quot;),
        @Result(column = &quot;addr&quot;, property = &quot;address&quot;),
  
  //注解嵌套
  @Result(property = &quot;user&quot;, javaType = User.class, column = &quot;uid&quot;, one = @One(select = &quot;com.test.dao.UserMapper.findById&quot;,fetchType = FetchType.EAGER))
  

&#125;)
public Order findByIdWithUsers(Integer id);
</code></pre>
<p>}<br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public class OrderMapperTest extends BaseMapperTest {</p>
<pre><code>//一对一嵌套注解测试
@Test
public void testFindByIdWithUsers() throws Exception &#123;
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);
    Order order = orderMapper.findByIdWithUsers(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}<br>1.3.2 一对多查询<br>需求</p>
<p>查询一个用户，与此同时查询出该用户具有的订单</p>
<p>一对多查询语句</p>
<p>1<br>2<br>SELECT * FROM <code>user</code> where id &#x3D; #{id};<br>SELECT * FROM orders where uid &#x3D; #{用户id};<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>&#x2F;&#x2F;一对多注解嵌套查询<br>@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>@Results({ &#x2F;&#x2F; resultMap标签手动映射<br>        @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>        @Result(column &#x3D; “username”,property &#x3D; “username”),<br>        @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>        @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>        @Result(column &#x3D; “address”,property &#x3D; “address”),<br>        @Result(property &#x3D; “orderList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>})<br>public User findByIdWithOrders(Integer id);</p>
<p>OrderMapper接口</p>
<p>1<br>2<br>@Select(“SELECT * FROM orders WHERE uid &#x3D; #{id}”)<br>public List<Order> findByUid(Integer id);<br>注解嵌套</Order></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>    &#x2F;&#x2F;一对多注解嵌套查询<br>    @Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>    @Results({ &#x2F;&#x2F; resultMap标签手动映射<br>            @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>            @Result(column &#x3D; “username”,property &#x3D; “username”),<br>            @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>            @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>            @Result(column &#x3D; “address”,property &#x3D; “address”),</p>
<p>@Result(property &#x3D; “orderList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>    })<br>    public User findByIdWithOrders(Integer id);</p>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>&#x2F;&#x2F;一对多注解测试<br>@Test<br>public void testFindByIdWithOrders() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    User user &#x3D; userMapper.findByIdWithOrders(41);<br>    System.out.println(user);<br>    System.out.println(user.getOrderList());<br>}<br>1.3.3 多对多查询<br>需求</p>
<p>查询用户同时查询出该用户的所有角色</p>
<p>多对多查询语句</p>
<p>1<br>2<br>3<br>SELECT * FROM <code>user</code> where id &#x3D; #{id};<br>SELECT * FROM role r INNER JOIN user_role ur ON r.<code>id</code> &#x3D; ur.<code>rid</code><br>    WHERE ur.<code>uid</code> &#x3D; #{用户id};<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>&#x2F;&#x2F;多对多注解嵌套查询<br>@Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>@Results({ &#x2F;&#x2F; resultMap标签手动映射<br>        @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>        @Result(column &#x3D; “username”,property &#x3D; “username”),<br>        @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>        @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>        @Result(column &#x3D; “address”,property &#x3D; “address”),<br>        @Result(property &#x3D; “roleList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>})<br>public User findByIdWithRoles(Integer id);</p>
<p>RoleMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public interface RoleMapper {<br>    @Select(“SELECT * FROM role r INNER JOIN user_role ur ON ur.<code>rid = r.</code>id<code> WHERE ur.</code>uid&#96;&#x3D;#{uid}”)<br>    @Results(value &#x3D; {<br>            @Result(column &#x3D; “id”,property &#x3D; “id”,id &#x3D; true),<br>            @Result(column &#x3D; “role_name”,property &#x3D; “roleName”),<br>            @Result(column &#x3D; “role_desc”,property &#x3D; “roleDesc”)<br>    })<br>    public List<Role> findByUid(Integer id);</Role></p>
<p>}<br>注解嵌套</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>    &#x2F;&#x2F;多对多注解嵌套查询<br>    @Select(“SELECT * FROM user WHERE id &#x3D; #{id}”)<br>    @Results({ &#x2F;&#x2F; resultMap标签手动映射<br>            @Result(column &#x3D; “id”,property &#x3D; “id”,id&#x3D;true), &#x2F;&#x2F; result标签映射封装<br>            @Result(column &#x3D; “username”,property &#x3D; “username”),<br>            @Result(column &#x3D; “birthday”,property &#x3D; “birthday”),<br>            @Result(column &#x3D; “sex”,property &#x3D; “sex”),<br>            @Result(column &#x3D; “address”,property &#x3D; “address”),</p>
<p>@Result(property &#x3D; “roleList”,javaType &#x3D; List.class,column &#x3D; “id”,many &#x3D; @Many(select &#x3D; “com.test.dao.OrderMapper.findByUid”))<br>    })<br>    public User findByIdWithRoles(Integer id);</p>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>&#x2F;&#x2F; 多对多注解测试<br>@Test<br>public void testFindByIdWithRoles() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>User user = userMapper.findByIdWithRoles(41);
System.out.println(user);
System.out.println(user.getOrderList());
</code></pre>
<p>}<br>1.4 延迟加载<br>不管是一对多还是多对多 ，在注解配置中都有fetchType的属性</p>
<p>fetchType &#x3D; FetchType.LAZY 表示懒加载</p>
<p>fetchType &#x3D; FetchType.EAGER 表示立即加载</p>
<p>fetchType &#x3D; FetchType.DEFAULT 表示使用全局配置</p>
<p>1.5 二级缓存<br>配置SqlMapConfig.xml文件开启二级缓存的支持</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><settings><br>    <!--
        因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。
        为true代表开启二级缓存；为false代表不开启二级缓存。
    --><br>    <setting name="cacheEnabled" value="true"><br></setting></settings><br>在Mapper接口中使用注解配置二级缓存</p>
<p>1<br>2<br>@CacheNamespace<br>public interface UserMapper {…}<br>1.6 知识小结<br>注解开发和xml配置相比，从开发效率来说，注解编写更简单，效率更高。</p>
<p>从可维护性来说，注解如果要修改，必须修改源码，会导致维护成本增加。xml维护性更强。</p>
<p>经验：单表简单CRUD可以使用注解、多表及动态sql就用xml</p>
<p>二.MyBatis案例练习<br>2.1 编程风格<br>浏览器：Chrome、Firefox</p>
<p>包目录：cn(com).公司名.项目名（都是小写）</p>
<p>类：大驼峰式命名</p>
<p>方法名：小驼峰式命名</p>
<p>2.2 环境搭建<br>编写中文过滤器</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>@WebFilter(“&#x2F;*”)<br>public class EncodeFilter implements Filter {<br>    @Override<br>    public void init(FilterConfig filterConfig) throws ServletException {</p>
<pre><code>&#125;

@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
    servletRequest.setCharacterEncoding(&quot;UTF-8&quot;);
    filterChain.doFilter(servletRequest, servletResponse);
&#125;

@Override
public void destroy() &#123;

&#125;
</code></pre>
<p>}<br>2.3 查询所有<br>2.3.1 需求和效果实现<br>通过三层架构+接口+mybatis，查询员工信息，在页面展示</p>
<p>2.3.2需求分析<br>index.jsp–&gt;EmpServlet–&gt;EmpService接口EmpServiceImp实现类–&gt;EmpDao接口+EmpDao映射，最终返给list.jsp</p>
<p>2.3.3 代码实现<br>index.jsp</p>
<p>1<br><a href="${pageContext.request.contextPath}/emp?action=findAll">员工列表</a><br>Emp实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class Emp {<br>    private Integer id;<br>    private String name;<br>    private String sex;<br>    private String joindate;<br>    private Double salary;<br>    private String address;<br>&#x2F;&#x2F;此处省略getter&#x2F;setter，toString<br>EmpServlet</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>@WebServlet(“&#x2F;EmpServlet”)<br>public class EmpServlet extends HttpServlet {</p>
<pre><code>// 重写service方法
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    // 获取action请求参数
    String action = request.getParameter(&quot;action&quot;);
    // 判断
    if (action.equals(&quot;findAll&quot;)) &#123;
        this.findAll(request, response);
    &#125;
&#125;

// 查询所有
protected void findAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    // 1.调用service查询
    EmpService empService = new EmpServiceImpl();
    List&lt;Emp&gt; list = empService.findAll();
    // 2.将list写入request域
    request.setAttribute(&quot;list&quot;, list);
    // 3.转发
    request.getRequestDispatcher(&quot;/list.jsp&quot;).forward(request, response);
&#125;
</code></pre>
<p>}<br>EmpServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>public class EmpServiceImpl implements EmpService {</p>
<pre><code>@Override
public List&lt;Emp&gt; findAll() &#123;
    // 通过mybatis工具类获取sqlSession
    SqlSession sqlSession = MyBatisUtils.openSession();
    // 创建EmpDao代理对象
    EmpDao empDao = sqlSession.getMapper(EmpDao.class);
    // 查询
    List&lt;Emp&gt; list= empDao.findAll();
    // 关闭sqlSession
    MyBatisUtils.close(sqlSession);
    return list;
&#125;
</code></pre>
<p>}<br>EmpDao（接口+映射）</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.EmpDao"><br>    <select id="findAll" resulttype="Emp"><br>        SELECT * FROM emp<br>    </select><br></mapper><br>list.jsp</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>&lt;c:forEach items&#x3D;”${list}” var&#x3D;”emp”&gt;<br>    <tr><br>        <td>${emp.id}</td><br>        <td>${emp.ename}</td><br>        <td>${emp.joindate}</td><br>        <td>${emp.salary}</td><br>        <td>${emp.address}</td><br>    </tr><br><br>2.4 分页查询<br>2.4.1 导入数据<br>2.4.2 分页介绍<br>在实际开发中，如果数据库数据太多，一般我们需要进行分页查询，提高效率</p>
<p>分页技术实现</p>
<p>物理分页：数据库实现（MySQL、Oracle）</p>
<p>内存分页：查询全部，在通过java代码进行分页</p>
<p>使用MySQL操作物理分页</p>
<p>语法： select * from 表名 limit 开始索引,每页个数;</p>
<p>模拟百度分页，一个显示5条，数据库共有16条记录</p>
<p>第一页</p>
<p>select * from 表名 limit 0,5;</p>
<p>第二页</p>
<p>select * from 表名 limit 5,5;</p>
<p>第三页</p>
<p>select * from 表名 limit 10,5;</p>
<p>第四页</p>
<p>select * from 表名 limit 15,5;</p>
<p>索引公式</p>
<p>开始索引&#x3D;(当前页-1) × 每页个数</p>
<p>如何获得当前页和每页个数</p>
<p>前端页提供</p>
<p>2.4.3 需求和效果实现<br>通过mysql物理分页，一个显示5条，数据库共有16条记录</p>
<p>2.4.3 需求分析</p>
<p>后端代码流程图</p>
<p>2.4.4 代码实现<br>index.jsp</p>
<p>1<br>2<br>3<br>4</p>
<body>
<%--<a href="${pageContext.request.contextPath}/EmpServlet?action=findAll">员工列表--%>
<a href="${pageContext.request.contextPath}/EmpServlet?action=findByPage&currentPage=1&pageSize=5">员工列表</a>
</%--<a></body>
PageBean

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class PageBean<E> {</E></p>
<pre><code>private Integer totalCount; // 总记录数

private Integer totalPage;// 总页数

private List&lt;E&gt; list; // 结果集

private Integer currentPage; // 当前页

private Integer pageSize; // 每页个数
</code></pre>
<p>  &#x2F;&#x2F;此处省略getter&#x2F;setter，toString<br>EmpServlet</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>@WebServlet(“&#x2F;EmpServlet”)<br>public class EmpServlet extends HttpServlet {</p>
<pre><code>// 重写service方法
@Override
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    // 获取action请求参数
    String action = req.getParameter(&quot;action&quot;);
    // 判断
    if (action.equals(&quot;findAll&quot;)) &#123;
        this.findAll(req, resp);
    &#125; else if (action.equals(&quot;findByPage&quot;)) &#123;
        this.findByPage(req, resp);
    &#125;
&#125;

EmpService empService = new EmpServiceImpl();

// 分页查询
protected void findByPage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    // 1.接收请求参数
    String currentPageStr = req.getParameter(&quot;currentPage&quot;);
    String pageSizeStr = req.getParameter(&quot;pageSize&quot;);
    // 2.转为整型
    int currentPage = Integer.parseInt(currentPageStr);
    int pageSize = Integer.parseInt(pageSizeStr);
    // 3.调用service查询
    PageBean&lt;Emp&gt; pb = empService.findByPage(currentPage, pageSize);
    // 4.设置到request域
    req.setAttribute(&quot;pb&quot;, pb);
    // 5.转发
    req.getRequestDispatcher(&quot;/list.jsp&quot;).forward(req, resp);
&#125;
</code></pre>
<p>EmpServiceImpl</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>public class EmpServiceImpl implements EmpService {<br>    @Override<br>    public List<Emp> findAll() {<br>        &#x2F;&#x2F; 通过mybatis工具类获取sqlSession<br>        SqlSession sqlSession &#x3D; MyBatisUtils.openSession();<br>        &#x2F;&#x2F; 创建EmpDao代理对象<br>        EmpDao empDao &#x3D; sqlSession.getMapper(EmpDao.class);<br>        &#x2F;&#x2F; 查询<br>        List<Emp> list &#x3D; empDao.findAll();<br>        &#x2F;&#x2F; 关闭sqlSession<br>        MyBatisUtils.close(sqlSession);<br>        return list;<br>    }<br>    @Override<br>    public PageBean<Emp> findByPage(int currentPage,int pageSize){<br>        &#x2F;&#x2F; 通过mybatis工具类获取sqlSession<br>        SqlSession sqlSession &#x3D; MyBatisUtils.openSession();</Emp></Emp></Emp></p>
<pre><code>    // 创建EmpDao代理对象
    EmpDao empDao = sqlSession.getMapper(EmpDao.class);

    // 1.创建 PageBean
    PageBean&lt;Emp&gt; pageBean = new PageBean();

    // 2.封装当前页和每页个数
    pageBean.setCurrentPage(currentPage);
    pageBean.setPageSize(pageSize);

    // 3.调用dao查询总记录数并封装
    Integer totalCount = empDao.findCount();
    pageBean.setTotalCount(totalCount);

    // 4.计算并封装总页数
    int totalPage = (int)Math.ceil(totalCount*1.0/pageSize);
    pageBean.setTotalPage(totalPage);

    // 5.计算开始索引
    int index = (currentPage - 1) * pageSize;

    // 6.调用dao查询结果集并封装
    List&lt;Emp&gt; list = empDao.findList(index,pageSize);
    pageBean.setList(list);

    // 关闭sqlSession
    MyBatisUtils.close(sqlSession);
    // 7.返回pageBean对象
    return pageBean;
&#125;
</code></pre>
<p>}<br>EmpDao（接口+映射）</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>public interface EmpDao {<br>    List<Emp> findAll();</Emp></p>
<pre><code>//查看总记录
Integer findCount();

//分页查询结果
List&lt;Emp&gt; findList(@Param(&quot;index&quot;) int index,@Param(&quot;pageSize&quot;) int pageSize);
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.EmpDao"><br>    <select id="findAll" resulttype="Emp"><br>        SELECT * FROM emp<br>    </select></mapper></p>
<pre><code>&lt;!--  查看总记录数 --&gt;
&lt;select id=&quot;findCount&quot; resultType=&quot;java.lang.Integer&quot;&gt;
    SELECT count(*) FROM emp
&lt;/select&gt;

&lt;!--    查看结果集--&gt;
&lt;select id=&quot;findList&quot; resultType=&quot;com.test.domain.Emp&quot;&gt;
    SELECT * FROM emp limit #&#123;index&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>

list.jsp

<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        table &#123;</span><br><span class="line">            margin: 30px auto;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #page td &#123;</span><br><span class="line">            width: 20px;</span><br><span class="line">            border: 1px solid gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> cellpadding=<span class="string">&quot;0&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;600px&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;入职日期&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;薪资&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;住址&lt;/td&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;emps&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;emp&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.name&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.sex&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.joindate&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.salary&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.address&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td style=<span class="string">&quot;text-align: left&quot;</span>&gt;总共检索到$&#123;pb.totalCount&#125;条记录,共分$&#123;pb.totalPage&#125;页&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;table id=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;pb.currentPage&gt;1&#125;&quot;</span>&gt;</span><br><span class="line">            &lt;td style=<span class="string">&quot;width:50px&quot;</span>&gt;</span><br><span class="line">                &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                   href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;pb.currentPage-1&#125;&amp;pageSize=5&quot;</span>&gt;上一页&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;c:forEach begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;$&#123;pb.totalPage&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;page&quot;</span>&gt;</span><br><span class="line">            &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;page == pb.currentPage&#125;&quot;</span>&gt;</span><br><span class="line">                &lt;td bgcolor=<span class="string">&quot;#ffd700&quot;</span>&gt;</span><br><span class="line">                    &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                       href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;page&#125;&amp;pageSize=5&quot;</span>&gt;$&#123;page&#125;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;page != pb.currentPage&#125;&quot;</span>&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                       href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;page&#125;&amp;pageSize=5&quot;</span>&gt;$&#123;page&#125;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;pb.currentPage &lt; pb.totalPage&#125;&quot;</span>&gt;</span><br><span class="line">            &lt;td style=<span class="string">&quot;width:50px&quot;</span>&gt;</span><br><span class="line">                &lt;a style=<span class="string">&quot;text-decoration: none&quot;</span></span><br><span class="line">                   href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/EmpServlet?action=findByPage&amp;currentPage=$&#123;pb.currentPage+1&#125;&amp;pageSize=5&quot;</span>&gt;下一页&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">txt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">    <span class="comment">// var txt = document.querySelector（&quot;#uname&quot;）;</span></span><br><span class="line">    txt.innerText = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/12/Mybatis%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2-%E5%8A%A0%E8%BD%BD-%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/12/Mybatis%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2-%E5%8A%A0%E8%BD%BD-%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Mybatis嵌套查询 & 加载 & 缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-12 01:37:47" itemprop="dateCreated datePublished" datetime="2020-05-12T01:37:47+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Mybatis嵌套查询<br>1.1 什么事嵌套查询<br>嵌套查询就是将原来多表查询中的联合查询语句拆成多个单表的查询，再使用mybatis的语法嵌套在一起。</p>
<p>例</p>
<p>需求:查询一个订单，与此同时查询出该订单所属的用户</p>
<p>关联查询:</p>
<p>1<br>select * from orders o inner join user u on o.uid &#x3D; u.id where o.id &#x3D; 1;<br>缺点:<br>sql语句编写难度大</p>
<p>数据量过大，笛卡尔积数量倍增，可能造成内存溢出</p>
<p>嵌套查询</p>
<p>1<br>2<br>3<br>4<br>5<br>–根据订单id查询订单表<br>  select * from orders where id &#x3D; 1;<br>–再根据订单表中uid(外键)查询用户表<br>    select * from user where id &#x3D; 订单表uid;<br>–最后由mybatis框架进行嵌套组合<br>优点</p>
<p>sql语句编写简单</p>
<p>没有多表关联，不会产生笛卡尔积</p>
<p>1.2 一对一嵌套查询<br>需求</p>
<p>查询一个订单，与此同时查询出该订单所属的用户</p>
<p>sql语句</p>
<p>1<br>2<br>3<br>4<br>– 1.根据订单id查询订单表<br>    select * from orders where id &#x3D; 1;<br>– 2.再根据订单表中uid(外键)查询用户表<br>    select * from user where id &#x3D; 41;<br>OrderMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface OrderMapper {</p>
<pre><code>//一对一嵌套查询
public Order findByIdWithUser(Integer id);
</code></pre>
<p>OrderMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.OrderMapper"></mapper></p>
<pre><code>&lt;resultMap id=&quot;orderMap&quot; type=&quot;Order&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;

    &lt;!--通过mybatis嵌套查询user表--&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;uid&quot; select=&quot;com.test.dao.OrderMapper.findById&quot;&gt;

    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<!--    一对一嵌套查询-->
<pre><code>&lt;!--    resultType:单表映射封装 --&gt;
&lt;!--    resultMap:多表查询必须手动映射封装--&gt;

&lt;select id=&quot;findByIdWithUser&quot; parameterType=&quot;int&quot; resultMap=&quot;orderMap&quot;&gt;
    SELECT * FROM orders WHERE id=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>public interface UserMapper {<br>    &#x2F;&#x2F; 根据用户id查询user对象<br>    public User findById(Integer id);<br>UserMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;!--    根据用户id查询user对象--&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
SELECT * FROM user WHERE id=#&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<p>通过mybatis进行嵌套组合</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br><resultMap id="orderMap" type="Order"><br>    <id column="id" property="id"></id><br>    <result column="ordertime" property="ordertime"></result><br>    <result column="money" property="money"></result></resultMap></p>
<pre><code>&lt;!--通过mybatis嵌套查询user表
一对一association
column=&quot;uid&quot; 订单查询的用户外键字段，需要作为条件
select=&quot;com.test.dao.OrderMapper.findById&quot;查询用户表(用户接口+执行方法名)
--&gt;
&lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;uid&quot; select=&quot;com.test.dao.UserMapper.findById&quot;/&gt;


&lt;/association&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>public class OrderMapperTest extends BaseMapperTest {</p>
<pre><code>// 一对一嵌套测试
@Test
public void testFindByIdWithUser() throws Exception &#123;
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);

    // 根据id查询
    Order order = orderMapper.findByIdWithUser(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>[2020-05-12 21:21:03,060] DEBUG o.OrderMapper.findByIdWithUser  - &#x3D;&#x3D;&gt;  Preparing: </p>
<p>&#x2F;&#x2F;先查询订单<br>SELECT * FROM orders WHERE id&#x3D;? </p>
<p>[2020-05-12 21:21:03,111] DEBUG o.OrderMapper.findByIdWithUser  - &#x3D;&#x3D;&gt; Parameters: 1(Integer)<br>[2020-05-12 21:21:03,159] DEBUG     com.test.dao.UserMapper  - Cache Hit Ratio [com.test.dao.UserMapper]: 0.0<br>[2020-05-12 21:21:03,159] DEBUG theima.dao.UserMapper.findById  - &#x3D;&#x3D;&#x3D;&#x3D;&gt;  Preparing: </p>
<p>&#x2F;&#x2F;再查询用户<br>SELECT * FROM user WHERE id&#x3D;? </p>
<p>[2020-05-12 21:21:03,159] DEBUG theima.dao.UserMapper.findById  - &#x3D;&#x3D;&#x3D;&#x3D;&gt; Parameters: 41(Integer)<br>[2020-05-12 21:21:03,162] DEBUG theima.dao.UserMapper.findById  - &lt;&#x3D;&#x3D;&#x3D;&#x3D;      Total: 1<br>[2020-05-12 21:21:03,165] DEBUG o.OrderMapper.findByIdWithUser  - &lt;&#x3D;&#x3D;      Total: 1</p>
<p>&#x2F;&#x2F;用mybatis嵌套组合在一起<br>Order{id&#x3D;1, ordertime&#x3D;Mon May 20 15:58:02 CST 2019, money&#x3D;999.5, user&#x3D;User{id&#x3D;41, username&#x3D;’老王’, birthday&#x3D;Tue May 28 06:47:08 CST 2019, sex&#x3D;’男’, address&#x3D;’北京’, orderList&#x3D;null, roleList&#x3D;null}}<br>嵌套关系</p>
<p>步骤	<br>&#x2F;&#x2F;一对一嵌套查询<br>public Order findByIdWithUser(Integer id);<br>&#x2F;&#x2F; 根据用户id查询user对象<br>public User findById(Integer id);<br>用mybatis嵌套组合在一起<br><association property="”user”" javatype="”User”" column="”uid”" select="”com.test.dao.UserMapper.findById”" fetchtype="”eager”/"><br>1.3 一对多嵌套查询<br>需求</association></p>
<p>查询一个用户，与此同时查询出该用户具有的订单</p>
<p>sql语句</p>
<p>1<br>2<br>3<br>4<br>– 1. 先根据用户id，查询用户表(一个)<br>    SELECT * FROM USER WHERE id &#x3D; 41;<br>– 2. 再根据用户id，查询订单表(多个)<br>    SELECT * FROM orders WHERE uid &#x3D; 41;<br>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; 一对多嵌套查询<br>public User findByIdWithOrders(Integer id);<br>UserMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br><resultMap id="userWithOrdersMap" type="User"><br>    <id column="id" property="id"><br>    <result column="username" property="username"><br>    <result column="sex" property="sex"><br>    <result column="birthday" property="birthday"><br>    <result column="address" property="address"><br>    <!--一对多嵌套组合--><br>    <collection property="orderList" oftype="Order" column="id" select="com.test.dao.OrderMapper.findByUid"><br></collection></result></result></result></result></id></resultMap></p>
<!--一对多嵌套查询-->
<select id="findByIdWithOrders" parametertype="int" resultmap="userWithOrdersMap">
    SELECT * FROM user WHERE id=#{id}
</select>
OrderMapper接口

<p>1<br>2<br>&#x2F;&#x2F; 根据用户id，查询订单列表<br>public List<Order> findByUid(Integer id);<br>OrderMapper映射</Order></p>
<p>1<br>2<br>3<br><select id="findByUid" parametertype="int" resulttype="Order"><br>    SELECT * FROM orders WHERE uid&#x3D;#{uid}<br></select><br>通过mybatis进行嵌套组合</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br><resultMap id="userWithOrdersMap" type="User"><br>    <id column="id" property="id"><br>    <result column="username" property="username"><br>    <result column="sex" property="sex"><br>    <result column="birthday" property="birthday"><br>    <result column="address" property="address"><br>    <!--一对多嵌套组合
    collection
    column="id" 根据用户查询的结果，id作为条件
    select="com.test.dao.OrderMapper.findByUid" 去查询订单表(映射接口+执行方法)
    --><br>    <collection property="orderList" oftype="Order" column="id" select="com.test.dao.OrderMapper.findByUid"><br></collection></result></result></result></result></id></resultMap><br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class UserMapperTest extends BaseMapperTest {</p>
<pre><code>@Test
public void testFindByIdWithOrders() throws Exception &#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findByIdWithOrders(41);
    System.out.println(user);
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;先查询用户<br>    SELECT * FROM USER WHERE id &#x3D; 41;<br>&#x2F;&#x2F;再查询订单<br>    SELECT * FROM orders WHERE uid &#x3D; 41;<br>&#x2F;&#x2F;用mybatis嵌套组合在一起<br>嵌套关系</p>
<p>步骤	<br>&#x2F;&#x2F;先查询用户<br>public User findByIdWithOrders(Integer id);<br>&#x2F;&#x2F; 再查询订单<br>public List<Order> findByUid(Integer id);<br>用mybatis嵌套组合在一起<br><collection property="”orderList”" oftype="”Order”" column="”id”" select="”com.test.dao.OrderMapper.findByUid”/"><br>1.4 多对多嵌套查询<br>需求</collection></Order></p>
<p>查询用户同时查询出该用户的所有角色</p>
<p>mybatis的实现方案就是(一对多)，区别在于sql语句不同</p>
<p>sql语句</p>
<p>1<br>2<br>3<br>4<br>– 1. 先根据用户id，查询用户表(一个)<br>SELECT * FROM USER WHERE id &#x3D; 41;<br>– 2. 再根据用户id，查询角色表(多个)<br>SELECT * FROM role r INNER JOIN user_role ur ON ur.<code>rid</code> &#x3D; r.<code>id</code> WHERE ur.<code>uid</code> &#x3D; 41;<br>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; 多对多嵌套查询<br>public User findByIdWithRoles(Integer id);<br>UserMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br><resultMap id="userWithRolesMap" type="User"><br>    <id column="id" property="id"><br>    <result column="username" property="username"><br>    <result column="sex" property="sex"><br>    <result column="birthday" property="birthday"><br>    <result column="address" property="address"><br>    <!-- 多对多嵌套--><br>    <collection property="roleList" oftype="Role" column="id" select="com.test.dao.RoleMapper.findByUid"></collection><br></result></result></result></result></id></resultMap></p>
<select id="findByIdWithRoles" parametertype="int" resultmap="userWithRolesMap">
    SELECT * FROM user WHERE id=#{id}
</select>
RoleMapper接口

<p>1<br>2<br>3<br>4<br>5<br>public interface RoleMapper {</p>
<pre><code>// 根据用户id，查询角色列表
public List&lt;Role&gt; findByUid(Integer id);
</code></pre>
<p>}<br>RoleMapper映射</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.RoleMapper"></mapper></p>
<pre><code>&lt;resultMap id=&quot;roleResultMap&quot; type=&quot;Role&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;/&gt;
    &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;/&gt;
&lt;/resultMap&gt;

&lt;!--    根据用户id，查询角色列表--&gt;
&lt;select id=&quot;findByUid&quot; parameterType=&quot;int&quot; resultMap=&quot;roleResultMap&quot;&gt;
    SELECT * FROM role r INNER JOIN user_role ur ON ur.`rid`=r.`id` WHERE ur.`uid`=#&#123;uid&#125;
&lt;/select&gt;
</code></pre>
</mapper>
通过mybatis进行嵌套组合

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;cache&gt;&lt;/cache&gt;

&lt;resultMap id=&quot;userWithOrdersMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!--一对多嵌套组合
    collection
    column=&quot;id&quot; 根据用户查询的结果，id作为条件
    select=&quot;com.test.dao.OrderMapper.findByUid&quot; 去查询订单表(映射接口+执行方法)
    --&gt;
    &lt;collection property=&quot;orderList&quot; ofType=&quot;Order&quot; column=&quot;id&quot; select=&quot;com.test.dao.OrderMapper.findByUid&quot;/&gt;
&lt;/resultMap&gt;


&lt;resultMap id=&quot;userWithRolesMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;!-- 多对多嵌套
    column=&quot;id&quot; 用户id作为条件
    select=&quot;com.test.dao.RoleMapper.findByUid&quot;查询角色表(角色映射接口+执行方法)
    --&gt;
    &lt;collection property=&quot;roleList&quot; ofType=&quot;Role&quot; column=&quot;id&quot;
                select=&quot;com.test.dao.RoleMapper.findByUid&quot;&gt;&lt;/collection&gt;
&lt;/resultMap&gt;


&lt;!--    根据用户id查询user对象--&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
SELECT * FROM user WHERE id=#&#123;id&#125;
</code></pre>


<pre><code>&lt;!--一对多嵌套查询--&gt;
&lt;select id=&quot;findByIdWithOrders&quot; parameterType=&quot;int&quot; resultMap=&quot;userWithOrdersMap&quot;&gt;
    SELECT * FROM user WHERE id=#&#123;id&#125;
&lt;/select&gt;

&lt;select id=&quot;findByIdWithRoles&quot; parameterType=&quot;int&quot; resultMap=&quot;userWithRolesMap&quot;&gt;
    SELECT * FROM user WHERE id=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
</mapper>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>&#x2F;&#x2F; 多对多测试(根据用户查询角色)<br>@Test<br>public void testFindByIdWithRoles() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>User user = userMapper.findByIdWithRoles(41);
System.out.println(user);
</code></pre>
<p>}<br>嵌套关系</p>
<p>步骤	<br>&#x2F;&#x2F;先查询用户<br>public User findByIdWithRoles(Integer id);<br>&#x2F;&#x2F; 再查询角色列表<br>public List<Order> findByUid(Integer id);<br>用mybatis嵌套组合在一起<br><collection property="”roleList”" oftype="”Role”" column="”id”" select="”com.test.dao.RoleMapper.findByUid”/"><br>1.5 知识小结<br>步骤:一对多举例</collection></Order></p>
<p>先查询(一方)单表&#x3D;&gt;再查询(多方)单表&#x3D;&gt;最后由mybatis嵌套组合</p>
<p>配置	<br>一对一配置	使用<resultMap>+<association>做配置，通过column条件，执行select查询<br>一对多配置	使用<resultMap>+<collection>做配置，通过column条件，执行select查询<br>多对多配置	使用<resultMap>+<collection>做配置，通过column条件，执行select查询<br>优点:	缺点<br>简化sql语句编写<br>不会产生笛卡尔积	麻烦<br>开发中到底使用哪一种</collection></resultMap></collection></resultMap></association></resultMap></p>
<p>传统开发，数据量小</p>
<p>使用关联查询</p>
<p>互联网开发，数据量大</p>
<p>使用嵌套查询</p>
<p>二.Mybatis加载策略<br>2.1 什么是加载策略<br>当多个模型(表)之间存在关联关系时, 加载一个模型(表)的同时, 是否要立即加载其关联的模型, 我们把这种决策 称为加载策略</p>
<p>如果加载一个模型(表)的时候, 需要立即加载出其关联的所有模型(表), 这种策略称为立即加载</p>
<p>如果加载一个模型的时候, 不需要立即加载出其关联的所有模型, 等到真正需要的时候再加载, 这种策略称为延迟加载(懒加载)<br>Mybatis中的加载策略有两种:立即加载和延迟加载, 默认是立即加载</p>
<p>注意:延迟加载是在嵌套查询基础上实现的</p>
<p>什么样的场景使用立即加载</p>
<p>一对一</p>
<p>什么样的场景使用延迟加载(什么时候用，什么时候查询，提高数据库性能)</p>
<p>一对多、多对多</p>
<p>2.2 配置延迟加载<br>2.2.1 全局<br>SqlMapConfig.xml,设置开启全局延迟加载</p>
<p>1<br>2<br>3<br>4<br>5<br><settings><br>    <!--开启延迟(懒)加载 true 开始 false(默认值) 关闭--><br>    <setting name="lazyLoadingEnabled" value="true"></setting></settings></p>

2.2.2 局部
mapper映射文件，指定某一个select标签配置

<p>1<br>2<br>3<br>4<br>5<br><association></association> 标签<br><collection></collection> 标签<br>fetchType&#x3D;””属性<br>    eager 立即加载<br>    lazy 延迟加载<br>注意:局部优先级高于全局，就近原则</p>
<p>2.3 触发加载<br>有这样一个全局配置 lazyLoadTriggerMethods ,它定义的方法会触发立即加载</p>
<p>也就说当你调用它定义的方法时, 会执行数据加载, 它的默认值是 equals,clone,hashCode,toString</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br><settings><br>    <!--开启延迟(懒)加载 true 开始 false(默认值) 关闭--><br>    <setting name="lazyLoadingEnabled" value="true"><br>    <!--触发立即加载的配置
      默认值:equals,clone,hashCode,toString
      value="" 覆盖了默认值，表示在执行上述四个方法时，不会触发立即加载
      只有在执行get方法获取时，触发数据加载
    --><br>    <setting name="lazyLoadTriggerMethods" value><br></setting></setting></settings><br>三.Mybatis缓存<br>什么是缓存</p>
<p>服务器内存(硬盘)中的一块区域</p>
<p>为什么使用缓存</p>
<p>提高查询效率</p>
<p>什么样的数据适合做缓存</p>
<p>经常访问但又不经常修改的数据</p>
<p>缓存是用来提高查询效率的，所有的持久层框架基本上都有缓存机制 Mybatis也提供了缓存策略，分为一级缓存，二 级缓存</p>
<p>3.1 一级缓存<br>3.1.1 介绍<br>MyBatis一级缓存是:SqlSession级别的缓存，默认开启，不需要手动配置</p>
<p>3.1.2 验证<br>需求</p>
<p>根据id查询用户</p>
<p>一级缓存测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>&#x2F;&#x2F; 一级缓存测试<br>@Test<br>public void testFindByIdWithBufferLevel1() throws Exception {<br>    &#x2F;&#x2F;需要用工具类开启&#x2F;关闭session，否则会出现session错误<br>    SqlSession sqlSession &#x3D; MyBatisUtils.openSession();<br>    UserMapper userMapper1 &#x3D; sqlSession.getMapper(UserMapper.class);<br>    &#x2F;&#x2F; 走数据库<br>    User user1 &#x3D; userMapper1.findById(41);<br>    System.out.println(user1);</p>
<pre><code>// 清除缓存(自己测试增、删、改)
sqlSession.clearCache();

// 获取第二个代理对象
UserMapper userMapper2 = sqlSession.getMapper(UserMapper.class);
// 走缓存(如果上面清除缓存，还是走数据库)
User user2 = userMapper2.findById(41);
System.out.println(user2);

// sqlSession关闭(清除缓存)
MyBatisUtils.close(sqlSession);
</code></pre>
<p>}<br>3.1.3 分析<br>一级缓存是SqlSession范围的缓存，不同的SqlSession之间的缓存区域是互相不影响的，执行SqlSession的C(增</p>
<p>加)U(更新)D(删除)操作，或者调用clearCache()、commit()、close()方法，都会清空缓存</p>
<p>SqlSession对象		LocalCache(Map集合)<br>第一次查询	写入<br>➡	LocalCache<br>如果中间发生了DML(增删改)事务操作，清除缓存	清除<br>➡	LocalCache<br>第N次查询	读取<br>⬅	LocalCache<br>一级缓存源码</p>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;org.apache.ibatis.cache.impl.PerpetualCache</p>
<p>public class PerpetualCache implements Cache {<br>    private final String id;<br>    private Map&lt;Object, Object&gt; cache &#x3D; new HashMap();<br>3.2 二级缓存<br>3.2.1 介绍<br>MyBatis的二级缓存虽然是默认开启的，但需要在映射文件中配置 <cache> 标签才能使用，而且要求实体类的必须 实现序列化接口</cache></p>
<p>3.2.2 验证<br>mybatis全局配置，默认值就是开启了二级缓存</p>
<p>指定需要开启二级缓存的映射配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;!--    当前映射文件，使用二级缓存--&gt;
&lt;cache&gt;&lt;/cache&gt;
</code></pre>
<p>指定User实现序列化接口</p>
<p>1<br>public class User implements Serializable<br>二级缓存测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>&#x2F;&#x2F; 二级缓存测试<br>@Test<br>public void testFindByIdWithBufferLevel2() throws Exception {<br>&#x2F;&#x2F;需要用工具类开启&#x2F;关闭session，否则会出现session错误<br>    &#x2F;&#x2F; 模拟第一个用户<br>    SqlSession sqlSession1 &#x3D; MyBatisUtils.openSession();<br>    UserMapper userMapper1 &#x3D; sqlSession1.getMapper(UserMapper.class);<br>    User user1 &#x3D; userMapper1.findById(41);<br>    System.out.println(user1);</p>
<pre><code>sqlSession1.close();

// 模拟第二个用户
SqlSession sqlSession2 = MyBatisUtils.openSession();
UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);
User user2 = userMapper2.findById(41);
System.out.println(user2);
sqlSession2.close();
</code></pre>
<p>}<br>3.2.3 分析<br>二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共</p>
<p>用二级缓存，二级缓存是跨SqlSession的。</p>
<p>二级缓存相比一级缓存的范围更大(按namespace来划分)</p>
<p>3.3 知识小结</p>
<p>mybatis的缓存，不需要手动存储和获取数据。mybatis自动维护的。</p>
<p>使用mybatis，如果是中小型项目，使用自带缓存的机制是可以满足需求的。如果是大型(分布式)项目，mybatis的 缓存灵活性不足，需要使用第三方的缓存技术解决问题。</p>
<p>四.核心配置文件回顾<br>4.1 properties标签<br>加载外部的properties文件</p>
<p>1<br><properties resource="jdbc.properties"></properties><br>4.2 settings标签<br>全局参数配置</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br><settings></settings></p>
<!--开启懒加载-->
<setting name="lazyLoadingEnabled" value="true">
<!-- 指定触发延迟加载的方法，只有get方法执行时才会触发立即加载 --> <setting name="lazyLoadTriggerMethods" value> <!--开启二级缓存 true开启(默认) false关闭-->
<setting name="cacheEnabled" value="true">

4.3 typeAliases标签
1
2
3
4
5
6
7
8
<!-- 单个定义别名 -->
<typeAliases>
<typeAlias type="cn.itcast.domain.User" alias="user"></typeAlias>
    </typeAliases>
<!-- 使用包的形式批量定义别名 -->
<typeAliases>
<package name="cn.itcast.domain"></package>
    </typeAliases>
4.4 mappers标签
加载映射配置

<p>1<br>2<br>3<br>4</p>
<ol>
<li>加载指定的src目录下的映射文件，例如:<mapper resource="com/test/mapper/UserMapper.xml"></mapper></li>
<li>加载并扫描指定包下所有的映射文件(接口)，例如: <package name="com.test.mapper">
4.5 environments标签
数据源环境配置</package></li>
</ol>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<!--数据库环境配置-->
<environments default="mysql">
    <!--使用MySQL环境-->
    <environment id="mysql">
        <!--事务管理器,底层JDBC-->
        <transactionManager type="JDBC">
        <!--连接池,内置POOLED-->
        <dataSource type="POOLED">
            <property name="driver" value="${jdbc.driver}">
            <property name="url" value="${jdbc.url}">
            <property name="username" value="${jdbc.user}">
            <property name="password" value="${jdbc.password}">
        </property></property></property></property></dataSource>
    </transactionManager></environment>
</environments>
总结
## 一 MyBatis嵌套查询

<h3 id="将原来多表查询中的联合查询语句，拆成多个单表的查询"><a href="#将原来多表查询中的联合查询语句，拆成多个单表的查询" class="headerlink" title="将原来多表查询中的联合查询语句，拆成多个单表的查询"></a>将原来多表查询中的联合查询语句，拆成多个单表的查询</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>一对一配置：使用<resultMap>+<association>做配置，通过column条件，执行select查询</association></resultMap></p>
</li>
<li><p>一对多配置：使用<resultMap>+<collection>做配置，通过column条件，执行select查询</collection></resultMap></p>
</li>
<li><p>多对多配置：使用<resultMap>+<collection>做配置，通过column条件，执行select查询</collection></resultMap></p>
</li>
</ul>
<h2 id="二-MyBatis加载策略"><a href="#二-MyBatis加载策略" class="headerlink" title="二 MyBatis加载策略"></a>二 MyBatis加载策略</h2><h3 id="全局延迟加载"><a href="#全局延迟加载" class="headerlink" title="全局延迟加载"></a>全局延迟加载</h3><ul>
<li><settings></settings></li>
</ul>
<p>​ &lt;!–开启全局延迟加载功能–&gt;</p>
<p>​ <setting name="”lazyLoadingEnabled”" value="”true”/"></setting></p>


<h3 id="局部延迟加载"><a href="#局部延迟加载" class="headerlink" title="局部延迟加载"></a>局部延迟加载</h3><ul>
<li><association> 和 <collection> 标签</collection></association></li>
</ul>
<p>​ - fetchType&#x3D;”lazy | eager”</p>
<ul>
<li>局部的加载策略优先级高于全局的加载策略。</li>
</ul>
<h2 id="三-MyBatis缓存"><a href="#三-MyBatis缓存" class="headerlink" title="三 MyBatis缓存"></a>三 MyBatis缓存</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><ul>
<li>是SqlSession级别的缓存</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ul>
<li>是mapper映射级别的缓存，需要手动配置且实体类实现serializable接口</li>
</ul>
<h2 id="四-核心配置文件回顾"><a href="#四-核心配置文件回顾" class="headerlink" title="四 核心配置文件回顾"></a>四 核心配置文件回顾</h2><h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><ul>
<li>加载外部的properties文件</li>
</ul>
<h3 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h3><ul>
<li>全局参数配置</li>
</ul>
<h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><ul>
<li>为 Java 类型设置一个别名</li>
</ul>
<h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><ul>
<li>加载映射配置</li>
</ul>
<h3 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h3><ul>
<li>数据源环境配置</li>
</ul>
</setting></setting></setting></mapper>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/10/Mybatis%E8%A1%A8%E5%8D%95%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Mybatis%E8%A1%A8%E5%8D%95%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">Mybatis表单查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 01:37:18" itemprop="dateCreated datePublished" datetime="2020-05-10T01:37:18+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.Mybatis表单查询<br>1.1 resultMap标签<br>如果数据库返回结果的列名和要封装的实体的属性名完全一致的话用 resultType 属性</p>
<p>如果数据库返回结果的列名和要封装的实体的属性名有不一致的情况用 resultMap 属性</p>
<p>使用resultMap手动建立对象关系映射</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface UserMapper {<br>    public List<User> findAll();<br>    &#x2F;&#x2F;ResultSet标签<br>    public List<User> findAllResultMap();<br>UserMapper.xml</User></User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br><mapper namespace="com.test.dao.UserMapper"><br>    <!--查询所有--><br>    <select id="findAll" resulttype="User"><br>        SELECT * FROM user<br>    </select></mapper></p>
<pre><code>&lt;!--    resultMap手动建立映射
id=&quot;userResultMap&quot;
type=&quot;com.test.domain.User&quot;建立映射的java类型
id 标签 主键
id column=&quot;uid&quot; 列名
property=&quot;id&quot;实体属性名
result 标签 普通字段
column=&quot;gender&quot;  列名
property=&quot;sex&quot; 实体属性名
--&gt;

&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;bir&quot; property=&quot;birthday&quot;/&gt;
    &lt;result column=&quot;gender&quot; property=&quot;sex&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
&lt;/resultMap&gt;

&lt;!--    模拟表与实体的属性名不一致情况--&gt;
&lt;select id=&quot;findAllResultMap&quot; resultMap=&quot;userResultMap&quot;&gt;
    SELECT id AS uid,username AS `name`,birthday AS bir,sex AS gender,address FROM `user`
&lt;/select&gt;
</code></pre>
<p>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>public class UserMapperTest {</p>
<pre><code>private SqlSession sqlSession = null;

// 此方法在测试方法执行之前，执行
@Before
public void before() &#123;
    // 获取sqlSession对象
    // 此方法必须线程内独享
    sqlSession = MyBatisUtils.openSession();
&#125;

// 此方法在测试地方法执行之后，执行
@After
public void after() &#123;
    // 关闭sqlSession
    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testFindAll() throws Exception &#123;
    // 需要通过mybatis帮你根据接口规范创建实现类
    // 创建代理对象(实现类)
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    // 执行sql
    List&lt;User&gt; list = userMapper.findAll();
    System.out.println(list);
&#125;

//resultMap标签
@Test
public void testFindAllResultMap() throws Exception &#123;
    UserMapper sessionMapper = sqlSession.getMapper(UserMapper.class);
    List&lt;User&gt; list = sessionMapper.findAllResultMap();
    for (User user : list) &#123;
        System.out.println(user);
    &#125;
&#125;
</code></pre>
<p>1.2 多条件查询<br>需求</p>
<p>根据id和username查询user表</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>&#x2F;&#x2F;多条件查询:方式一<br>public List<User> findByIdAndUsernameV1(@Param(“id”) Integer id, @Param(“username”) String username);</User></p>
<p>&#x2F;&#x2F;多条件查询:方式二<br>public List<User> findByIdAndUsernameV2(User user);<br>UserMapper.xml</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<!--    多条件查询方式
如果传递多个参数，属性省略不写-->
<select id="findByIdAndUsernameV1" resulttype="User">
SELECT * FROM user WHERE id=#{id} AND username=#{username}
</select>
  

<select id="findByIdAndUsernameV2" parametertype="User" resulttype="User">
SELECT * FROM user WHERE id=#{id} AND username=#{username}
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>&#x2F;&#x2F;多条件查询<br>&#x2F;&#x2F;V1<br>@Test<br>public void testfindByIdAndUsernameV1() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByIdAndUsernameV1(41, “老王”);<br>    System.out.println(list);<br>}</User></p>
<p>&#x2F;&#x2F;V2<br>@Test<br>public void testfindByIdAndUsernameV2() throws Exception {<br>    UserMapper sessionMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    User user &#x3D; new User();<br>    user.setId(41);<br>    user.setUsername(“W”);<br>    List<User> list &#x3D; sessionMapper.findByIdAndUsernameV2(user);<br>    System.out.println(list);<br>}<br>1.3 模糊查询<br>需求</User></p>
<p>根据username模糊查询user表</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>&#x2F;&#x2F; 模糊查询，方式一<br>public List<User> findByUsername1(String username);</User></p>
<p>&#x2F;&#x2F; 模糊查询，方式二<br>public List<User> findByUsername2(String username);</User></p>
<p>&#x2F;&#x2F; 模糊查询，方式三<br>public List<User> findByUsername3(String username);</User></p>
<p>&#x2F;&#x2F; 模糊查询，方式四<br>public List<User> findByUsername4(String username);<br>UserMapper.xml</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>    <!--    模糊查询，方式一
    java代码与sql语句有耦合--><br>    <select id="findByUsername1" parametertype="string" resulttype="User"><br>SELECT * FROM user WHERE username like #{username}<br>    </select></p>
<pre><code>&lt;!--    模糊查询，方式二
mysql5.5版本之前，此拼接不支持多个单引号
oracle数据库，除了别名的位置，其余位置都不能使用双引号--&gt;
&lt;select id=&quot;findByUsername2&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt;
</code></pre>
<p>SELECT * FROM user WHERE username like “%” #{username} “%”<br>    </p>
<pre><code>&lt;!--    此方式，会出现sql注入
$&#123;&#125; 字符串拼接，如果接收的简单数据类型，表达式名称必须是value
--&gt;
&lt;select id=&quot;findByUsername3&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt;
</code></pre>
<p>SELECT * FROM user WHERE username like ‘%${value}%’<br>    </p>
<pre><code>&lt;!--    模糊查询，方式四【掌握】--&gt;
&lt;!--    使用concat()函数拼接--&gt;
&lt;!--    注意:oracle数据库 concat()函数只能传递二个参数,可以使用函数嵌套来解决--&gt;
&lt;select id=&quot;findByUsername4&quot; parameterType=&quot;string&quot; resultType=&quot;User&quot;&gt;
</code></pre>
<p>SELECT * FROM user WHERE username like concat(concat(‘%’,#{username}),’%’)<br>    <br>测试</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>@Test<br>public void testfindByUsername1() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername1(“%王%”);<br>    System.out.println(list);<br>}<br>@Test<br>public void testfindByUsername2() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername2(“王”);<br>    System.out.println(list);<br>}<br>@Test<br>public void testfindByUsername3() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername3(“王”);<br>    System.out.println(list);<br>}<br>@Test<br>public void testfindByUsername4() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>    List<User> list &#x3D; userMapper.findByUsername4(“王”);<br>    System.out.println(list);<br>}<br>1.4 ${} 与 #{} 区别<br>${} :底层 Statement</User></User></User></User></p>
<p>sql与参数拼接在一起，会出现sql注入问题<br>每次执行sql语句都会编译一次<br>接收简单数据类型，命名:{value}<br>接收引用数据类型，命名: ${属性名}<br>字符串类型需要加 ‘${value}’<br>#{}底层 PreparedStatement</p>
<p>sql与参数分离，不会出现sql注入问题<br>sql只需要编译一次<br>接收简单数据类型，命名:#{随便写}<br>接收引用数据类型，命名:#{属性名}<br>二.Mybatis映射文件深入<br>2.1 返回主键<br>应用场景</p>
<p>向数据库保存一个user对象后, 然后在控制台记录下此新增user的主键值(id)</p>
<p>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>public interface UserMapper {<br>&#x2F;&#x2F;    返回主键，方式一<br>    public void save1(User user);<br>&#x2F;&#x2F;    返回主键，方式二<br>    public void save2(User user);<br>}<br>UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">
    <!--
    返回主键，方式一
    useGeneratedKeys属性
    useGeneratedKeys="true" 开启新增主键返回功能
    keyColumn="id" user表中主键列
    keyProperty="id" user实体主键属性
    注意:仅支持主键自增类型的数据库 MySQL 和 SqlServer ， oracle不支持-->

<pre><code>&lt;insert id=&quot;save1&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot;&gt;
    INSERT INTO user (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)
&lt;/insert&gt;

&lt;insert id=&quot;save2&quot; parameterType=&quot;User&quot;&gt;
    &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
        SELECT LAST_INSERT_ID()
    &lt;/selectKey&gt;
    INSERT INTO user (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)
&lt;/insert&gt;
</code></pre>
</mapper>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>public class UserMapperTest {</p>
<pre><code>private SqlSession sqlSession=null;
@Before
public void before()&#123;
    sqlSession= MyBatisUtils.openSession();
&#125;
@After
public void after()&#123;
    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testSave1() throws Exception&#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setUsername(&quot;Johe Eve&quot;);
    user.setBirthday(new Date());
    user.setAddress(&quot;SZ&quot;);
    user.setSex(&quot;Male&quot;);

    userMapper.save1(user);
    System.out.println(&quot;When Insert,Primary Key Returns: &quot;+user.getId());
&#125;

@Test
public void testSave2() throws Exception&#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = new User();
    user.setUsername(&quot;Johe Eve&quot;);
    user.setBirthday(new Date());
    user.setAddress(&quot;SZ&quot;);
    user.setSex(&quot;Male&quot;);

    userMapper.save2(user);
    System.out.println(&quot;When Insert,Primary Key Returns: &quot;+user.getId());
&#125;
</code></pre>
<p>}<br>2.2 动态SQL<br>2.2.1 什么是动态SQL<br>需求</p>
<p>把id和username封装到user对象中，将user对象中不为空的属性作为查询条件</p>
<p>这个时候我们执行的sql就有多种可能</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>– 如果id和用户名不为空<br>select * from user where id&#x3D; #{id} and username &#x3D; #{username}<br>– 如果只有id<br>select * from user where id&#x3D; #{id}<br>– 如果只有用户名<br>select * from user where username &#x3D; #{username}<br>– 如果id和用户名都为空<br>select * from user<br>像上面这样, 根据传入的参数不同, 需要执行的SQL的结构就会不同，这就是动态SQL</p>
<p>2.2.2 if 条件判断<br>需求</p>
<p>把id和username封装到user对象中，将user对象中不为空的属性作为查询条件</p>
<p>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; if 条件判断<br>public List<User> findByIdAndUsernameIf(User user);<br>UserMapper.xml</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<!--
if标签 条件判断
where标签 相当于 where 1=1 功能，如果没有条件情况下 where语句不在sql语句拼接
可以去掉第一个 and 或者 or
-->
<select id="findByIdAndUsernameIf" parametertype="User" resulttype="User">
    SELECT * FROM user
    <where>
        <if test="id != null">
            AND id=#{id}
        </if>
        <if test="username != null">
            AND username = #{username}
        </if>
    </where>
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>&#x2F;&#x2F; if判断<br>@Test<br>public void testfindByIdAndUsernameIf() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>// 拼接条件
User param = new User();
param.setId(41);
param.setUsername(&quot;老王&quot;);

List&lt;User&gt; list = userMapper.findByIdAndUsernameIf(param);

for (User user : list) &#123;
    System.out.println(user);
&#125;
</code></pre>
<p>}<br>2.2.3 set 用于update语句<br>需求</p>
<p>动态更新user表数据，如果该属性有值就更新，没有值不做处理</p>
<p>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; set 更新<br>public void updateIf(User user);<br>UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19</p>
<!--    set标签 更新 ，将条件中的最后一个逗号抹除-->
<update id="updateIf" parametertype="User">
    update user
    <set>
        <if test="username != null">
            username=#{username},
        </if>
        <if test="birthday != null">
            birthday=#{birthday},
        </if>
        <if test="sex != null">
            sex=#{sex},
        </if>
        <if test="address != null">
            address=#{address},
        </if>
    </set>
    where id = #{id}
</update>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>&#x2F;&#x2F;update<br>@Test<br>public void testUpdateIf() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>// 设置更新内容
User user = new User();
user.setId(57);
user.setUsername(&quot;Steve&quot;);

userMapper.updateIf(user);
</code></pre>
<p>}<br>2.2.4 foreach 用于循环遍历<br>需求</p>
<p>根据多个id查询，user对象的集合</p>
<p>1<br>SELECT * FROM user WHERE id IN (41,43,46);<br><foreach>标签用于遍历集合	属性<br>collection	代表要遍历的集合元素<br>open	代表语句的开始部分<br>close	代表结束部分<br>item	代表遍历集合的每个元素，生成的变量名<br>sperator	代表分隔符<br>练习三个版本</foreach></p>
<p>普通list集合	普通array数组	实体属性list集合<br>domain&#x2F;QueryVo</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>&#x2F;*<br>    根据页面查询条件封装到实体中 View Object<br> *&#x2F;<br>public class QueryVo {</p>
<pre><code>private List&lt;Integer&gt; ids;

public List&lt;Integer&gt; getIds() &#123;
    return ids;
&#125;

public void setIds(List&lt;Integer&gt; ids) &#123;
    this.ids = ids;
&#125;
</code></pre>
<p>}<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>&#x2F;&#x2F; foreach标签，普通list集合<br>public List<User> findByList(List<Integer> ids);<br>&#x2F;&#x2F; foreach标签，普通array数组<br>public List<User> findByArray(Integer [] ids);<br>&#x2F;&#x2F; foreach标签，实体属性list集合<br>public List<User> findByQueryVo(QueryVo queryVo);<br>UserMapper.xml</User></User></Integer></User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30</p>
<!-- foreach标签，普通list集合
    传递 普通类型list集合 collection="list"
    属性取值:collection、list
-->
<select id="findByList" parametertype="list" resulttype="User">
    SELECT * FROM user WHERE id in
    <foreach collection="list" open="(" close=")" item="id" separator=",">
        #{id}
    </foreach>
</select>

<!--    foreach标签，普通array数组
     传统 普通类型array数组 collection="array"
     属性取值 array-->
<select id="findByArray" parametertype="int" resulttype="User">
    SELECT * FROM user WHERE id in
    <foreach collection="array" open="(" close=")" item="id" separator=",">
        #{id}
    </foreach>
</select>

<!--    foreach标签，实体属性list集合
     传递 实体中list属性集合的话，collection="ids"
     取值，实体的属性名-->
<select id="findByQueryVo" parametertype="QueryVo" resulttype="User">
    SELECT * FROM user WHERE id in
    <foreach collection="ids" open="(" close=")" item="id" separator=",">
        #{id}
    </foreach>
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>&#x2F;&#x2F; foreach标签，普通list集合<br>@Test<br>public void testFindByList() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>List ids = new ArrayList();
ids.add(41);
ids.add(46);
List list = userMapper.findByList(ids);
System.out.println(list);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; foreach标签，普通array数组<br>@Test<br>public void testFindByArray() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>Integer[] ids = &#123;41, 46, 49&#125;;
List&lt;User&gt; list = userMapper.findByArray(ids);
System.out.println(list);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;    foreach标签，实体属性list集合<br>@Test<br>public void testFindByQueryVo() throws Exception {<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>List ids= new ArrayList();
ids.add(41);
ids.add(46);
QueryVo queryVo = new QueryVo();
queryVo.setIds(ids);
List&lt;User&gt; list = userMapper.findByQueryVo(queryVo);
System.out.println(list);
</code></pre>
<p>}<br>2.3 SQL片段<br>应用场景</p>
<p>映射文件中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>    <!-- foreach标签，普通list集合
        传递 普通类型list集合 collection="list"
        属性取值:collection、list
    --><br>    <select id="findByList" parametertype="list" resulttype="User"><br>        <include refid="selectUser"></include><br>        WHERE id in<br>        <foreach collection="list" open="(" close=")" item="id" separator=","><br>            #{id}<br>        </foreach><br>    </select></p>
<pre><code>&lt;!--    foreach标签，普通array数组
     传统 普通类型array数组 collection=&quot;array&quot;
     属性取值 array--&gt;
&lt;select id=&quot;findByArray&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
    &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt;
    WHERE id in
    &lt;foreach collection=&quot;array&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
        #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/select&gt;

&lt;!--    foreach标签，实体属性list集合
     传递 实体中list属性集合的话，collection=&quot;ids&quot;
     取值，实体的属性名--&gt;
&lt;select id=&quot;findByQueryVo&quot; parameterType=&quot;QueryVo&quot; resultType=&quot;User&quot;&gt;
    &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt;
    WHERE id in
    &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
        #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/select&gt;

&lt;!-- 将当前映射文件的共同的sql代码抽取一个片段，实现sql的复用性...
</code></pre>
<p>id&#x3D;”selectUser” 当前sql片段的唯一标识 –&gt;<br>    <sql id="selectUser"><br>     select id,username,birthday,sex,address from user<br>    </sql><br>2.4 知识小结<br>MyBatis映射文件配置</p>
<p>关键字	配置<br><select>	查询<br><insert>	插入<br><update>	修改<br><delete>	删除<br><selectKey>	返回主键<br><where>	where条件<br><if>	if判断<br><foreach>	for循环<br><set>	set设置<br><sql>	sql片段抽取<br>三.表关系回顾<br>在关系型数据库当中，表关系分为三种</sql></set></foreach></if></where></selectKey></delete></update></insert></select></p>
<p>关系	说明<br>特殊情况	一个订单只能从属于一个用户，mybatis框架就把这个多对一看做成一对一来实现<br>数据建立表关系	通过主外键关联<br>实体建立关系	通过属性关联</p>
<p>四.Mybatis多表查询<br>4.1 一对一(多对一)<br>一对一查询模型</p>
<p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户</p>
<p>一对一查询的需求:查询一个订单，与此同时查询出该订单所属的用户</p>
<p>实体和表映射关系</p>
<p>1<br>SELECT * FROM orders o INNER JOIN <code>user</code> u ON o.<code>uid</code> &#x3D; u.<code>id</code> WHERE o.<code>id</code> &#x3D; 1<br>Order实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>public class Order {<br>    private Integer id;<br>    private Date ordertime;<br>    private Double money;</p>
<pre><code>// 一个订单从属于一个用户
private User user;
</code></pre>
<p> &#x2F;&#x2F;此处省略getter&#x2F;setter，toString，User实体类<br>OrderMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface OrderMapper {<br>    &#x2F;&#x2F; 一对一关联查询<br>    public Order findByIdWithUser(Integer id);<br>}<br>OrderMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="com.test.dao.OrderMapper"></mapper></p>
<pre><code>&lt;resultMap id=&quot;orderMap&quot; type=&quot;Order&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;/&gt;
    &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;

    &lt;!--
    一对一多表关联 association标签
    property=&quot;user&quot; 关联实体的属性名 javaType=&quot;cn.test.domain.User&quot; 关联实体java类型
    --&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
        &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;

&lt;!--    一对一关联查询
    resultType:单表映射封装
    resultMap:多表查询必须手动映射封装--&gt;
&lt;select id=&quot;findByIdWithUser&quot; parameterType=&quot;int&quot; resultMap=&quot;orderMap&quot;&gt;
    SELECT * FROM orders o INNER JOIN `user` u ON o.`uid`=u.`id` WHERE o.`id`=#&#123;id&#125;
&lt;/select&gt;
</code></pre>

测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>public class OrderMapperTest {<br>    private SqlSession sqlSession &#x3D; null;</p>
<pre><code>@Before
public void before() &#123;
    sqlSession = MyBatisUtils.openSession();
&#125;

@After
public void after() &#123;
    MyBatisUtils.close(sqlSession);
&#125;

// 一对一关联测试
@Test
public void testFindByIdWithUser() throws Exception&#123;
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);

    Order order = orderMapper.findByIdWithUser(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}<br>4.2 一对多<br>一对多查询模型</p>
<p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户</p>
<p>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p>实体和表关系</p>
<p>1<br>SELECT *,o.id AS oid FROM <code>user</code> u INNER JOIN orders o ON u.<code>id</code> &#x3D; o.<code>uid</code> WHERE u.<code>id</code>&#x3D;41<br>User实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class User {<br>    private Integer id;<br>    private String username;<br>    private Date birthday;<br>    private String sex;<br>    private String address;</p>
<pre><code>// 一个用户具有多个订单
private List&lt;Order&gt; orderList;
</code></pre>
<p>  &#x2F;&#x2F;此处省略getter&#x2F;setter,toString<br>UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface UserMapper {<br>    &#x2F;&#x2F; 一对多关联<br>    public User findByIdWithOrders(Integer id);<br>}<br>UserMapper.xml</p>
<p>有多少记录，就创建多少order对象<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">

<pre><code>&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;

    &lt;!--
    一对多关联 collection标签
    property=&quot;orderList&quot; 关联实体集合的属性名
    ofType=&quot;cn.itcast.domain.Order&quot; 关联实体的java类型(集合泛型的类型)
    --&gt;
    &lt;collection property=&quot;orderList&quot; ofType=&quot;Order&quot;&gt;
        &lt;id column=&quot;oid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;

&lt;!--       一对多关联--&gt;
&lt;select id=&quot;findByIdWithOrders&quot; parameterType=&quot;int&quot; resultMap=&quot;userMap&quot;&gt;
    SELECT *,o.id AS oid FROM `user` u INNER JOIN orders `o` ON u.`id`=o.`uid` WHERE u.`id`=#&#123;id&#125;
&lt;/select&gt;
</code></pre>
</mapper>
测试

<p>test&#x2F;BaseMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class BaseMapperTest {<br>    protected SqlSession sqlSession &#x3D; null;</p>
<pre><code>@Before
public void before() &#123;
    sqlSession = MyBatisUtils.openSession();
&#125;

@After
public void after() &#123;
    MyBatisUtils.close(sqlSession);
&#125;
</code></pre>
<p>}<br>UserMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class UserMapperTest extends BaseMapperTest{</p>
<pre><code>// 一对多测试
@Test
public void testFindByIdWithOrders() throws Exception&#123;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findByIdWithOrders(41);
    System.out.println(user);
&#125;
</code></pre>
<p>}<br>4.3 多对多(由二个一对多组成)<br>实体和表关系</p>
<p>1<br>2<br>3<br>4<br>SELECT * FROM <code>user</code> u<br>INNER JOIN user_role ur ON u.<code>id</code> &#x3D; ur.<code>uid</code> – 用户连接中间表<br>INNER JOIN role r ON ur.<code>rid</code> &#x3D; r.<code>id</code> – 再根据中间表连接角色<br>WHERE u.id &#x3D; 41 – 用户id 作为条件<br>User和Role实体</p>
<p>Role</p>
<p>1<br>2<br>3<br>4<br>5<br>public class Role {<br>    private Integer id;<br>    private String roleName;<br>    private String roleDesc;<br>}<br>User</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>public class User {<br>    private Integer id;<br>    private String username;<br>    private Date birthday;<br>    private String sex;<br>    private String address;</p>
<pre><code>// 一个用户具有多个订单
private List&lt;Order&gt; orderList;

// 一个用户具有多个角色
private List&lt;Role&gt; roleList;
</code></pre>
<p>UserMapper接口</p>
<p>1<br>2<br>&#x2F;&#x2F; 多对多关联<br>public User findByIdWithRoles(Integer id);<br>UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br><resultMap id="userWithRoleMap" type="User"><br>    <id column="id" property="id"></id><br>    <result column="username" property="username"></result><br>    <result column="birthday" property="birthday"></result><br>    <result column="sex" property="sex"></result><br>    <result column="address" property="address"></result></resultMap></p>
<pre><code>&lt;!--多对多实现步骤和一对多是一样的(区别在于sql语句)--&gt;
&lt;collection property=&quot;roleList&quot; ofType=&quot;Role&quot;&gt;
    &lt;id column=&quot;rid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;role_desc&quot; property=&quot;roleDesc&quot;&gt;&lt;/result&gt;
&lt;/collection&gt;
</code></pre>



<select id="findByIdWithRoles" parametertype="int" resultmap="userWithRoleMap">
    SELECT * FROM `user` u INNER JOIN user_role ur
    ON u.`id`=ur.`uid` INNER JOIN role r ON ur.`rid`=r.`id`
    WHERE u.id=#{id}
</select>
测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>@Test<br>public void testFindByIdWithRoles() throws Exception{<br>    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</p>
<pre><code>User user = userMapper.findByIdWithRoles(41);
System.out.println(user);
</code></pre>
<p>}<br>4.4 知识小结<br>一对一配置:使用<resultMap>+<association>做配置			<br>association:		<br>property	关联的实体属性名<br>javaType	关联的实体类型(别名)<br>一对多配置:使用<resultMap>+<collection>做配置			<br>collection:		<br>property	关联的集合属性名<br>ofType	关联的集合泛型类型(别名)<br>多对多配置:使用<resultMap>+<collection>做配置			<br>collection:		<br>property	关联的集合属性名<br>ofType	关联的集合泛型类型(别名)<br>多对多的配置跟一对多很相似，难度在于SQL语句的编写。</collection></resultMap></collection></resultMap></association></resultMap></p>
<p>4.5 优化测试<br>BaseMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class BaseMapperTest {<br>    protected SqlSession sqlSession &#x3D; null;</p>
<pre><code>@Before
public void before() &#123;
    sqlSession = MyBatisUtils.openSession();
&#125;

@After
public void after() &#123;
    MyBatisUtils.close(sqlSession);
&#125;
</code></pre>
<p>}<br>OrderMapperTest</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>public class OrderMapperTest extends BaseMapperTest{<br>    &#x2F;&#x2F; 一对一关联测试<br>    @Test<br>    public void testFindByIdWithUser() throws Exception{<br>        OrderMapper orderMapper &#x3D; sqlSession.getMapper(OrderMapper.class);</p>
<pre><code>    Order order = orderMapper.findByIdWithUser(1);
    System.out.println(order);
&#125;
</code></pre>
<p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/09/Mybatis%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/Mybatis%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Mybatis入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-09 01:36:34" itemprop="dateCreated datePublished" datetime="2020-05-09T01:36:34+08:00">2020-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.框架简介<br>之前的MVC三层架构</p>
<p>表现层:Java与浏览器交互</p>
<p>业务层:根据某个功能除了业务逻辑</p>
<p>持久层:Java与数据库交互</p>
<p>优点	缺点<br>高内聚，低耦合	所有基础代码都需要手动编写，繁琐导致效率低<br>框架</p>
<p>半成品软件</p>
<p>框架阶段三层代码</p>
<p>框架阶段实现了绝大部分基础代码，只需要开发一些特有代码即可，提高开发效率</p>
<p>Broswer		Server		Server		Server		数据库<br>web层		service层		dao层		<br>Servlet控制器		将多个dao排序组合实现某个功能		提高jdbc操作数据库，实现最基本CURD	➡<br>⬅	SQL<br>user&#x2F;passwd	➡	⬇	↘<br>↖	功能A<br>find()<br>save()	➡<br>⬅	find()<br>save()<br>update()<br>delete()		<br>Login.jsp	⬅	jsp视图	↘		↙			<br>实体类domain,pojo				<br>常用框架:SpringMVC，Struts2		常用框架：Spring		常用框架：Mybatis,hibernate，jpa		<br>目前国内主流框架</p>
<p>SSM(springMVC+Spring+mybatis)</p>
<p>二.Mybatis简介<br>2.1 ORM概述<br>ORM(object Relational Mapping)对象关系映射</p>
<p>常用ORM框架有:hibernate(全自动ORM映射)、mybatis(半自动ORM映射)、jpa</p>
<p>例</p>
<p>Object:User类</p>
<p>Relational:user表</p>
<p>Mapping:将User类中成员变量与user表中的字段产生映射关系</p>
<p>需求:操作user对象的CURD，就能实现对user表的字段修改，一个实体类对应一张表，一个对象对应一条记录</p>
<p>总结：以面向对象方式，实现对数据库的操作</p>
<p>2.2 Mybatis介绍<br>简介</p>
<p>MyBatis官网地址:<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p>
<p>mybatis是一款优秀的持久层框架，他不需要项JDBC繁琐编写代码，只需要开发人员关注(接口+sql)<br>它采用了简单的xml配置+接口方式实现增删改查，开发时我们只需要关注SQL本身<br>三.Mybatis快速入门*<br>3.1 步骤分析<br>创建mybatis_db数据库和user表<br>创建java项目，导入jar包 (mysql驱动、mybatis、log4j日志)<br>创建User实体类<br>编写映射文件UserMapper.xml<br>编写核心文件SqlMapConfig.xml<br>编写测试代码<br>3.2 代码实现<br>创建mybatis_db数据库和user表<br>详细信息<br>创建Java项目，导入jar包</p>
<p>log4j-1.2.17.jar<br>mybatis-3.5.1.jar<br>mysql-connector-java-5.1.37-bin.jar</p>
<p>log4j.properties</p>
<p>创建User实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>public class User {<br>    private Integer id;<br>    private String username;<br>    private Date birthday;<br>    private String sex;<br>    private String address;<br>&#x2F;&#x2F;此处省略getter&#x2F;setter,toString<br>编写映射文件UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="UserMapper">
    <!--查询所有-->
    <select id="findAll" resulttype="com.test.domain.User">
        SELECT * FROM user
    </select>
</mapper>
编写核心文件SqlMapConfig.xml

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"><br><configuration><br>    <!--数据库环境配置--><br>    <environments default="mysql"><br>        <!--使用MySQL环境--><br>        <environment id="mysql"><br>            <!--事务管理器,底层JDBC--><br>            <transactionManager type="JDBC"></transactionManager><br>            <!--连接池,内置POOLED--><br>            <dataSource type="POOLED"><br>                <property name="driver" value="com.mysql.jdbc.Driver"><br>                <property name="url" value="jdbc:mysql://localhost:3306/mybatis_db"><br>                <property name="username" value="root"><br>                <property name="password" value="root"><br>            </property></property></property></property></dataSource><br>        </environment><br>    </environments><br>    <mappers><br>        <mapper resource="com/test/dao/UserMapper.xml"></mapper><br>    </mappers><br></configuration><br>编写测试代码</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>public class UserMapperTest {<br>    &#x2F;&#x2F;查询所有值快速入门<br>    @Test<br>    public void testFindAll() throws Exception {<br>        &#x2F;&#x2F;加载核心配置文件SqlMapConfig.xml<br>        InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>        &#x2F;&#x2F;构建SqlSessionFactory工厂对象<br>        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(in);<br>        &#x2F;&#x2F;通过工厂构建SqlSession会话对象<br>        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();<br>        &#x2F;&#x2F;执行SQL语句<br>        &#x2F;*<br>        参数一：命名空间+具体ID<br>        参数二：返回的Java类接收<br>        *&#x2F;<br>        List<User> list &#x3D; sqlSession.selectList(“UserMapper.findAll”);<br>        for (User user : list) {<br>            System.out.println(user);<br>        }</User></p>
<pre><code>    //释放资源
    sqlSession.close();
&#125;
</code></pre>
<p>四.Mybatis映射文件概述<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="UserMapper">
    <select id="findAll" resulttype="com.test.domain.User">
        SELECT * FROM user
    </select>
</mapper>

<!--
映射文件DTD约束头
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
-->
<p>语句	作用<br><!DOCTYPE mapper PUBLIC … s-3-mapper.dtd”>	映射文件DTD约束头<br>mapper	根标签<br>namespace	命名空间，与下面语句的id一起组成查询的标识<br>select	查询操作，可选的还有insert,update,delete<br>id	语句的id标识，与上面的命名空间一起组成查询的标识<br>resultType	查询结果对应的实体类型<br>SELECT * FROM user	要执行的SQL语<br>五.Mybatis增删改查*<br>编写映射文件UserMapper.xml</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="UserMapper">
    <!--查询所有-->
    <select id="findAll" resulttype="com.test.domain.User">
        SELECT * FROM user
    </select>
    <!--新增-->
    <insert id="sava" parametertype="com.test.domain.User">
        INSERT INTO
        user(username,birthday,sex,address)
        VALUES (#{username},#{birthday},#{sex},#{address})
    </insert>
    <!--修改-->
    <update id="update" parametertype="com.test.domain.User">
        UPDATE user set username=${},birthday=#{birthday},sex=#{sex},addrress=#{address} WHERE id =#{id}
    </update>
    <!--删除-->
    <delete id="delete" parametertype="java.lang.Integer">
        DELETE FROM user WHERE id = #{id}
    </delete>
</mapper>
编写测试代码

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>public class UserMapperTest {<br>    &#x2F;&#x2F;查询所有值快速入门<br>    @Test<br>    public void testFindAll() throws Exception {<br>        &#x2F;&#x2F;加载核心配置文件SqlMapConfig.xml<br>        InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>        &#x2F;&#x2F;构建SqlSessionFactory工厂对象<br>        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(in);<br>        &#x2F;&#x2F;通过工厂构建SqlSession会话对象<br>        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();<br>        &#x2F;&#x2F;执行SQL语句<br>        &#x2F;*<br>        参数一：命名空间+具体ID<br>        参数二：返回的Java类接收<br>        *&#x2F;<br>        List<User> list &#x3D; sqlSession.selectList(“UserMapper.findAll”);<br>        for (User user : list) {<br>            System.out.println(user);<br>        }</User></p>
<pre><code>    //释放资源
    sqlSession.close();
&#125;

@Test
public void testSave() throws Exception &#123;
    //加载核心配置文件SqlMapConfig.xml
    InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    //构建SqlSessionFactory工厂对象
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
    //通过工厂构建SqlSession会话对象
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //执行SQL语句
    User user = new User();
    user.setUsername(&quot;Jack&quot;);
    user.setBirthday(new Date());
    user.setSex(&quot;Male&quot;);
    user.setAddress(&quot;GZ&quot;);
    int i = sqlSession.insert(&quot;UserMapper.save&quot;, user);
    if (i &gt; 0) &#123;
        System.out.println(&quot;Ass Successful&quot;);
    &#125;
    //注意:Mybatis默认不提交，需要手动提交事务(DML)
    sqlSession.commit();
    //释放资源
    sqlSession.close();
&#125;

@Test
public void tetUpdate() throws Exception &#123;
    //加载核心配置文件SqlMapConfig.xml
    InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    //构建SqlSessionFactory工厂对象
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
    //通过工厂构建SqlSession会话对象
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //执行SQL语句
    User user = new User();
    user.setId(50);
    user.setUsername(&quot;lucy&quot;);
    user.setBirthday(new Date());
    user.setSex(&quot;Female&quot;);
    user.setAddress(&quot;PK&quot;);
    sqlSession.update(&quot;UserMapper.update&quot;,user);
    //注意:Mybatis默认不提交，需要手动提交事务(DML)
    sqlSession.commit();
    //释放资源
    sqlSession.close();
&#125;

//删除
@Test
public void testDelete() throws Exception &#123;
    //加载核心配置文件SqlMapConfig.xml
    InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    //构建SqlSessionFactory工厂对象
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
    //通过工厂构建SqlSession会话对象
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //执行SQL语句
    sqlSession.delete(&quot;UserMapper.delete&quot;, 50);
    //注意:Mybatis默认不提交，需要手动提交事务(DML)
    sqlSession.commit();
    //释放资源
    sqlSession.close();
&#125;
</code></pre>
<p>}<br>5.4 知识小结<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<ul>
<li><p>插入语句insert标签</p>
</li>
<li><p>在映射文件中使用parameterType属性指定插入数据类型</p>
</li>
<li><p>sql语句#{实体属性名} 表示?占位符</p>
</li>
<li><p>我们插入操作API是 sqlSession.insert(“命名空间.id”, 实体对象); </p>
</li>
<li><p>DML类型语句mybatis需要手动提交事务 sqlSession.commit();</p>
</li>
<li><p>修改操作使用update标签</p>
</li>
<li><p>修改操作的API使用的 sqlSession.update(“命名空间.id”, 实体对象);</p>
</li>
<li><p>删除语句使用delete标签</p>
</li>
<li><p>如果parameterType是引用数据类型 #{实体属性名}</p>
</li>
<li><p>如果parameterType是简单数据类型 #{键名知意}</p>
</li>
<li><p>删除操作API sqlSession.delete(“命名空间.id”, Object);<br>六.抽取工具类<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>public class MyBatisUtils {</p>
<p>  private static SqlSessionFactory sqlSessionFactory &#x3D; null;</p>
<p>  &#x2F;&#x2F;在静态代码块中(加载核心配置文件，构建工程对象)<br>  static {<br>  &#x2F;&#x2F;加载核心配置文件<br>  try {<br>      InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>      sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(in);<br>  } catch (IOException e) {<br>      e.printStackTrace();<br>  }<br>  }</p>
<p>  &#x2F;&#x2F;提供获取sqlSession的静态方法<br>  public static SqlSession openSession() {<br>  return sqlSessionFactory.openSession();<br>  }</p>
<p>  &#x2F;&#x2F;提供提交事务和释放资源方法<br>  public static void close(SqlSession sqlSession){<br>  &#x2F;&#x2F;提交事务<br>  sqlSession.commit();<br>  &#x2F;&#x2F;释放资源<br>  sqlSession.close();<br>  }</p>
</li>
</ul>
<p>}<br>需求</p>
<p>根据指定id，查询User对象</p>
<p>编写映射文件UserMapper.xml</p>
<p>1<br>2<br>3<br>4</p>
<!--查询一个-->
<select id="findById" parametertype="java.lang.Integer" resulttype="com.test.domain.User">
    SELECT * FROM user WHERE id=#{id}
</select>
编写测试代码

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>&#x2F;&#x2F;查询一个<br>@Test<br>public void testFindById() throws Exception {<br>    &#x2F;&#x2F; 1.获取sqlSession(根据工具类)<br>    SqlSession sqlSession &#x3D; MyBatisUtils.openSession();<br>    &#x2F;&#x2F; 2.执行sql<br>    User user &#x3D; sqlSession.selectOne(“UserMapper.findById”, 50);<br>    System.out.println(user);<br>    &#x2F;&#x2F; 3.关闭sqlSession<br>    MyBatisUtils.close(sqlSession);<br>}<br>七.Mybatis核心文件概述<br>7.1 核心配置文件层级关系<br>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</p>
<p>configuration（配置）<br>properties（属性）<br>settings（设置）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境配置）<br>environment（环境变量）<br>transactionManager（事务管理器）<br>dataSource（数据源）<br>databaseIdProvider（数据库厂商标识）<br>mappers（映射器）<br>7.2 常用配置标签解析<br>environments标签</p>
<p>数据库环境的配置，支持多环境配置</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<!--数据库环境配置-->
<environments default="mysql">
    <!--使用MySQL环境-->
    <environment id="mysql">
        <!--事务管理器,底层JDBC-->
        <transactionManager type="JDBC"></transactionManager>
        <!--连接池,内置POOLED-->
        <dataSource type="POOLED">
            <property name="driver" value="com.mysql.jdbc.Driver">
            <property name="url" value="jdbc:mysql://localhost:3306/mybatis_db">
            <property name="username" value="root">
            <property name="password" value="root">
        </property></property></property></property></dataSource>
    </environment>
</environments>
语句	作用
<environments default="”mysql”">	使用默认数据库环境
<environment>	连接某个数据库的具体环境配置
id=”mysql”	当前环境名称
transactionManager type=”JDBC”	事务管理类型JDBC
dataSource type=”POOLED”	使用数据库连接池:mybatis内置
property	数据库连接基本配置
其中，事务管理器(transactionManager)类型有两种:

<p>transactionManager	作用<br>JDBC	这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。<br>MANAGED	这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。<br>其中，数据源(dataSource)常用类型有二种</p>
<p>dataSource	作用<br>UNPOOLED	这个数据源的实现只是每次被请求时打开和关闭连接。<br>POOLED	这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。<br>properties标签</p>
<p>加载外置的properties配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>#jdbc.properties</p>
<p>jdbc.driver&#x3D;com.mysql.jdbc.Driver<br>jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;Day48<br>jdbc.user&#x3D;root<br>jdbc.password&#x3D;root<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>    <!--加载外部properties文件--><br>    <properties resource="jdbc.properties"></properties></p>
<!--                <property name="driver" value="com.mysql.jdbc.Driver"/>-->
<!--                <property name="url" value="jdbc:mysql://localhost:3306/mybatis_db"/>-->
<!--                <property name="username" value="root"/>-->
<!--                <property name="password" value="root"/>-->


<!--改为EL表达式 -->
<pre><code>            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;
</code></pre>
<p>typeAliases标签</p>
<p>为 Java 类型设置一个短的名字(类型别名)</p>
<p>mybatis框架内置了一些java类型的别名</p>
<p>别名Alias	映射的类型Mapped Type<br>_byte	byte<br>_long	long<br>_short	short<br>_int	int<br>_integer	int<br>_double	double<br>_float	float<br>_boolean	boolean<br>string	String<br>byte	Byte<br>long	Long<br>short	Short<br>int	Integer<br>integer	Integer<br>double	Double<br>float	Float<br>boolean	Boolean<br>date	Date<br>decimal	BigDecimal<br>bigdecimal	BigDecimal<br>object	Object<br>map	Map<br>hashmap	HashMap<br>list	List<br>arraylist	ArrayList<br>collection	Collection<br>iterator	Iterator<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>  <!--mybatis核心配置文件--></p>
<!--设置java类型别名-->
  <typeAliases>
      <!--设置一个java类型的别名
      <typeAlias type="com.test.domain.User" alias="User"></typeAlias>
      -->
      <!--将整个包下所有的类名设置了别名，别名（小名）：类名-->
      <package name="com.test.domain"></package>
  </typeAliases>
1
2
3
4
<!--查询一个-->
<select id="findById" parametertype="int" resulttype="User">
    SELECT * FROM user WHERE id = #{id}
</select>
mappers标签

<p>用于加载映射文件，加载方式有如下几种</p>
<p>作用	语句<br>加载指定的src目录下的映射文件	<mapper resource="”com/test/dao/UserMapper.xml”/"><br>加载指定接口的全限定名(注解开发时使用)	<mapper class="”com.test.mapper.UserMapper”/"><br>加载并扫描指定包下所有的接口(基于接口扫描方式加载)	<package name="”com.test.mapper”/"><br>mybatis文件的关系介绍</package></mapper></mapper></p>
<p>User实体类	⬅	UserMapper.xml	➡	User表<br>建立orm关系		<br>7.3 核心配置文件标签顺序<br>1<br><!ELEMENT configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)><br>7.4 知识小结<br>properties标签:该标签可以加载外部的properties文件</p>
<p>1<br><properties resource="jdbc.properties"></properties><br>typeAliases标签:设置类型别名</p>
<p>1<br><typeAlias type="com.test.domain.User" alias="user"></typeAlias><br>environments标签:数据源环境配置</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<!--数据库环境配置-->    
<environments default="mysql">
        <!--使用MySQL环境-->
        <environment id="mysql">
            <!--事务管理器,底层JDBC-->
            <transactionManager type="JDBC"></transactionManager>
            <!--连接池,内置POOLED-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.user}"></property>
                <property name="password" value="${jdbc.password}"></property>

<pre><code>        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<p>mappers标签:加载映射配置</p>
<p>1<br><mapper resource="com/test/dao/UserMapper.xml"></mapper><br>八.Mybatis的API概述<br>8.1 API介绍<br>Resources</p>
<p>加载mybatis的核心配置文件</p>
<p>1<br>2<br>&#x2F;&#x2F; 加载mybatis的核心配置文件，获取io流<br>InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>SqlSessionFactoryBuilder</p>
<p>根据mybatis的核心配置文件构建出SqlSessionFactory工厂对象</p>
<p>1<br>SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(in);<br>SqlSessionFactory</p>
<p>用于创建SqlSession会话对象(相当于Connection对象)</p>
<p>这是一个工厂对象，对于这种创建和销毁都非常耗费资源，一个项目中只需要存在一个即可</p>
<p>1<br>2<br>3<br>4<br>&#x2F;&#x2F; DML类型语句，需要手动提交事务<br>SqlSession openSession();<br>&#x2F;&#x2F; 设置是否开启自动提交事务的会话对象，如果设置true，自动提交<br>SqlSession openSession(boolean autoCommit);<br>SqlSession</p>
<p>这是Mybatis的一个核心对象。我们基于这个对象可以实现对数据的CRUD操作<br>对于这个对象应做到每个线程独有，每次用时打开，用完关闭<br>执行语句的方法主要有</p>
<p>1<br>2<br>3<br>4<br>5<br><T> T selectOne(String statement, Object parameter);<br><E> List<E> selectList(String statement, Object parameter);<br>int insert(String statement, Object parameter);<br>int update(String statement, Object parameter);<br>int delete(String statement, Object parameter);<br>操作事务的方法主要有</E></E></T></p>
<p>1<br>2<br>void commit();<br>void roolback();<br>8.2 工作原理</p>
<p>九.Mybatis实现Dao层<br>9.1 传统开发方式<br>编写UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>public interface UserMapper {<br>    &#x2F;&#x2F;查询所有<br>    public List<User> findAll();</User></p>
<pre><code>public Integer save();

public Integer update();

public int delete();

public User findByID();
</code></pre>
<p>}<br>编写UserMapper实现类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>public class UserMapperImpl implements UserMapper {<br>    @Override<br>    public List<User> findAll() {<br>        try {<br>            &#x2F;&#x2F; 1.加载核心配置文件<br>            InputStream in &#x3D; Resources.getResourceAsStream(“SqlMapConfig.xml”);<br>            &#x2F;&#x2F; 2.构建工厂<br>            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(in); &#x2F;&#x2F; 3.创建会话<br>            SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();<br>            &#x2F;&#x2F; 4.执行sql<br>            List<User> list &#x3D; sqlSession.selectList(“UserMapper.findAll”);</User></User></p>
<pre><code>        // 5.释放资源
        sqlSession.close();
        return list;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;

@Override
public Integer save( ) &#123;
    try &#123;
        // 1.加载核心配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 2.构建工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); // 3.创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 4.执行sql
        User user = new User();
        user.setUsername(&quot;SAVE&quot;);
        user.setSex(&quot;Male&quot;);
        user.setBirthday(new Date());
        user.setAddress(&quot;HK&quot;);
        int insert = sqlSession.insert(&quot;UserMapper.save&quot;, user);

        sqlSession.commit();
        // 5.释放资源
        sqlSession.close();
        return insert;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;

@Override
public Integer update( ) &#123;
    try &#123;
        // 1.加载核心配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 2.构建工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); // 3.创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 4.执行sql
        User user = new User();
        user.setId(53);
        user.setUsername(&quot;UPDATE&quot;);
        user.setSex(&quot;Female&quot;);
        user.setBirthday(new Date());
        user.setAddress(&quot;HK&quot;);
        int update = sqlSession.update(&quot;UserMapper.update&quot;, user);
        sqlSession.commit();

        // 5.释放资源
        sqlSession.close();
        return update;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;


@Override
public int delete( ) &#123;
    try &#123;
        // 1.加载核心配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 2.构建工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); // 3.创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 4.执行sql
        int delete = sqlSession.delete(&quot;UserMapper.delete&quot;, 50);
        sqlSession.commit();
        // 5.释放资源
        sqlSession.close();
        return delete;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    return 0;
&#125;

@Override
public User findByID( ) &#123;

    try &#123;
        // 1.加载核心配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 2.构建工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); // 3.创建会话
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 4.执行sql
        User user = sqlSession.selectOne(&quot;UserMapper.findById&quot;, 53);
        // 5.释放资源
        sqlSession.close();
        return user;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;
</code></pre>
<p>}<br>编写UserMapper.xml映射文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="UserMapper">
    <!--查询所有-->
    <select id="findAll" resulttype="User">
        SELECT * FROM user
    </select>
    <!--新增-->
    <insert id="save" parametertype="User">
        INSERT INTO
        user(username,birthday,sex,address)
        VALUES (#{username},#{birthday},#{sex},#{address})
    </insert>
    <!--修改-->
    <update id="update" parametertype="User">
        UPDATE user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} WHERE id =#{id}
    </update>
    <!--删除-->
    <delete id="delete" parametertype="int">
        DELETE FROM user WHERE id = #{id}
    </delete>

<pre><code>&lt;!--查询一个--&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM user WHERE id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
</mapper>
模拟service测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40</p>
<p>public class UserMapperTest {</p>
<pre><code>@Test
public void findall() throws Exception&#123;
    UserMapperImpl userMapper = new UserMapperImpl();
    List&lt;User&gt; list = userMapper.findAll();
    System.out.println(list);
&#125;

@Test
public void save() throws Exception&#123;
    UserMapperImpl userMapper = new UserMapperImpl();
    Integer save = userMapper.save();
    System.out.println(save);
&#125;


@Test
public void update() throws Exception&#123;
    UserMapperImpl userMapper = new UserMapperImpl();
    Integer update = userMapper.update();
    System.out.println(update);
&#125;

@Test
public void delete() throws Exception&#123;
    UserMapperImpl userMapper = new UserMapperImpl();
    int delete = userMapper.delete();
    System.out.println(delete);
&#125;


@Test
public void findOne() throws Exception&#123;
    UserMapperImpl userMapper = new UserMapperImpl();
    User byID = userMapper.findByID();
    System.out.println(byID);
&#125;
</code></pre>
<p>}<br>知识小结</p>
<p>编写UserMapper接口<br>编写UserMapperImpl实现类<br>编写UserMapper.xml映射<br>9.2 接口代理开发方式<br>基于接口代理方式的开发只需要:编写接口和映射文件，Mybatis 框架会为我们动态生成实现类的对象。</p>
<p>接口开发规范</p>
<p>Mapper映射文件的namespace与Mapper接口全限定名一致</p>
<p>Mapper接口的方法名与id的属性名一致</p>
<p>方法的参数类型与parameterType属性类型一致</p>
<p>方法的返回值类型与resultType属性类型一致</p>
<p>映射文件需要与接口在同一个包下，文件名和接口名相同:扫描包，加载所有的映射文件</p>
<package name="”cn.itcast.dao”">

<p>编写UserMapper接口</p>
<p>1<br>2<br>3<br>4<br>public interface UserMapper {<br>&#x2F;&#x2F; 查询所有<br>    public List<User> findAll();<br>}<br>编写UserMapper.xml映射文件</User></p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><br><mapper namespace="cn.itcast.dao.UserMapper"></mapper></p>
<!--查询所有-->
<select id="findAll" resulttype="User">
        select * from user
    </select>

模拟service测试

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>public class UserMapperTest {<br>    @Test<br>    public void testFindAll() throws Exception {<br>        &#x2F;&#x2F; 需要通过mybatis帮你根据接口规范创建实现类<br>        SqlSession sqlSession &#x3D; MyBatisUtils.openSession();<br>        &#x2F;&#x2F; 创建代理对象(实现类)<br>        UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);<br>        &#x2F;&#x2F; 执行sql<br>        List<User> list &#x3D; userMapper.findAll();<br>        System.out.println(list);<br>        &#x2F;&#x2F; 关闭会话<br>        MyBatisUtils.close(sqlSession);<br>    }<br>基于接口代理方式的内部执行原理</User></p>
<p>使用了JDK动态代理技术，帮我们创建了接口的实现类，底层还是执行SqlSession.insert() | update()</p>
<p>十.接口代理的增删改查<br>10.1 UserMapper接口<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public interface UserMapper {<br>    public List<User> findAll();</User></p>
<pre><code>public void save(User user);
public void update(User user);
public void delete(Integer id);
public User findById(Integer id);
</code></pre>
<p>}<br>10.2 UserMapper.xml 映射文件<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br><?xml version="1.0" encoding="UTF-8" ?><br><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></p>
<mapper namespace="com.test.dao.UserMapper">
    <!--查询所有-->
    <select id="findAll" resulttype="User">
        SELECT * FROM user
    </select>
    <!--新增-->
    <insert id="save" parametertype="User">
        INSERT INTO
        user(username,birthday,sex,address)
        VALUES (#{username},#{birthday},#{sex},#{address})
    </insert>
    <!--修改-->
    <update id="update" parametertype="User">
        UPDATE user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} WHERE id =#{id}
    </update>
    <!--删除-->
    <delete id="delete" parametertype="int">
        DELETE FROM user WHERE id = #{id}
    </delete>

<pre><code>&lt;!--查询一个--&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM user WHERE id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
</mapper>
10.3 测试代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
public class UserMapperTest {
    @Test
    public void testFindAll() throws Exception {
        // 需要通过mybatis帮你根据接口规范创建实现类
        SqlSession sqlSession = MyBatisUtils.openSession();
        // 创建代理对象(实现类)
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        // 执行sql
        List<User> list = userMapper.findAll();
        System.out.println(list);
        // 关闭会话
        MyBatisUtils.close(sqlSession);
    }

<pre><code>@Test
public void testSave() throws Exception&#123;
    SqlSession sqlSession = MyBatisUtils.openSession();
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = new User();
    user.setUsername(&quot;testSAVE_Interface&quot;);
    user.setSex(&quot;Male&quot;);
    user.setAddress(&quot;HK&quot;);
    user.setBirthday(new Date());
    userMapper.save(user);

    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testUpdate() throws Exception&#123;
    SqlSession sqlSession = MyBatisUtils.openSession();
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = new User();
    user.setId(54);
    user.setUsername(&quot;testUpdate_Interface&quot;);
    user.setSex(&quot;Female&quot;);
    user.setAddress(&quot;HK&quot;);
    user.setBirthday(new Date());
    userMapper.update(user);

    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testDelete() throws Exception&#123;
    SqlSession sqlSession = MyBatisUtils.openSession();
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    userMapper.delete(53);
    MyBatisUtils.close(sqlSession);
&#125;

@Test
public void testFindById() throws Exception&#123;
    SqlSession sqlSession = MyBatisUtils.openSession();
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    User user = userMapper.findById(52);
    System.out.println(user);

    MyBatisUtils.close(sqlSession);
&#125;
</code></pre>
<p>}<br>总结</p>
<h2 id="一-框架简介"><a href="#一-框架简介" class="headerlink" title="一 框架简介"></a>一 框架简介</h2><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><ul>
<li><p>model模型</p>
</li>
<li><p>view视图</p>
</li>
<li><p>controller控制器</p>
</li>
</ul>
<h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul>
<li><p>web层</p>
</li>
<li><p>service层</p>
</li>
<li><p>dao层</p>
</li>
</ul>
<h3 id="什么是框架？"><a href="#什么是框架？" class="headerlink" title="什么是框架？"></a>什么是框架？</h3><ul>
<li>半成品软件</li>
</ul>
<h3 id="常见框架"><a href="#常见框架" class="headerlink" title="常见框架"></a>常见框架</h3><ul>
<li>持久层</li>
</ul>
<p>​ - mybatis</p>
<p>​ - hibernate</p>
<p>​ - spring jdbc</p>
<ul>
<li>表现层</li>
</ul>
<p>​ - struts2</p>
<p>​ - spring mvc</p>
<ul>
<li>全栈（业务层）</li>
</ul>
<p>​ - spring</p>
<h2 id="二-Mybatis简介"><a href="#二-Mybatis简介" class="headerlink" title="二 Mybatis简介"></a>二 Mybatis简介</h2><h3 id="mybatis是一款优秀的持久层框架，封装了jdbc实现细节，让开发者只关注-sql本身。"><a href="#mybatis是一款优秀的持久层框架，封装了jdbc实现细节，让开发者只关注-sql本身。" class="headerlink" title="mybatis是一款优秀的持久层框架，封装了jdbc实现细节，让开发者只关注 sql本身。"></a>mybatis是一款优秀的持久层框架，封装了jdbc实现细节，让开发者只关注 sql本身。</h3><h3 id="mybatis是ORM映射框架"><a href="#mybatis是ORM映射框架" class="headerlink" title="mybatis是ORM映射框架"></a>mybatis是ORM映射框架</h3><h2 id="三-Mybatis快速入门"><a href="#三-Mybatis快速入门" class="headerlink" title="三 Mybatis快速入门"></a>三 Mybatis快速入门</h2><h3 id="1-创建mybatis-db数据库和user表"><a href="#1-创建mybatis-db数据库和user表" class="headerlink" title="1. 创建mybatis_db数据库和user表"></a>1. 创建mybatis_db数据库和user表</h3><h3 id="2-创建java项目，引入MyBatis相关jar包"><a href="#2-创建java项目，引入MyBatis相关jar包" class="headerlink" title="2. 创建java项目，引入MyBatis相关jar包"></a>2. 创建java项目，引入MyBatis相关jar包</h3><h3 id="3-创建User实体类"><a href="#3-创建User实体类" class="headerlink" title="3. 创建User实体类"></a>3. 创建User实体类</h3><h3 id="4-编写映射文件UserMapper-xml"><a href="#4-编写映射文件UserMapper-xml" class="headerlink" title="4. 编写映射文件UserMapper.xml"></a>4. 编写映射文件UserMapper.xml</h3><h3 id="5-编写核心文件SqlMapConfig-xml"><a href="#5-编写核心文件SqlMapConfig-xml" class="headerlink" title="5. 编写核心文件SqlMapConfig.xml"></a>5. 编写核心文件SqlMapConfig.xml</h3><h3 id="6-编写测试类"><a href="#6-编写测试类" class="headerlink" title="6. 编写测试类"></a>6. 编写测试类</h3><h2 id="四-Mybatis映射文件概述"><a href="#四-Mybatis映射文件概述" class="headerlink" title="四 Mybatis映射文件概述"></a>四 Mybatis映射文件概述</h2><h2 id="五-Mybatis增删改查"><a href="#五-Mybatis增删改查" class="headerlink" title="五 Mybatis增删改查"></a>五 Mybatis增删改查</h2><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><h2 id="六-抽取工具类"><a href="#六-抽取工具类" class="headerlink" title="六 抽取工具类"></a>六 抽取工具类</h2><h2 id="七-Mybatis核心文件概述"><a href="#七-Mybatis核心文件概述" class="headerlink" title="七 Mybatis核心文件概述"></a>七 Mybatis核心文件概述</h2><h3 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h3><ul>
<li>数据库环境配置</li>
</ul>
<h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><ul>
<li>引入第三方配置</li>
</ul>
<h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><ul>
<li>实体别名配置</li>
</ul>
<h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><ul>
<li>加载映射配置</li>
</ul>
<h2 id="八-Mybatis的API概述"><a href="#八-Mybatis的API概述" class="headerlink" title="八 Mybatis的API概述"></a>八 Mybatis的API概述</h2><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><ul>
<li>加载核心配置文件</li>
</ul>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><ul>
<li>构建工厂</li>
</ul>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><ul>
<li>生产会话对象</li>
</ul>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><ul>
<li>实现与数据库CRUD操作</li>
</ul>
<h2 id="九-Mybatis实现Dao层的二种方式"><a href="#九-Mybatis实现Dao层的二种方式" class="headerlink" title="九 Mybatis实现Dao层的二种方式"></a>九 Mybatis实现Dao层的二种方式</h2><h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h3><h3 id="接口代理方式"><a href="#接口代理方式" class="headerlink" title="接口代理方式"></a>接口代理方式</h3><ul>
<li><p>1。映射文件的命名空间必须是接口的全限定类名</p>
</li>
<li><p>2。接口方法的名称必须与statement标签id一致</p>
</li>
<li><p>3。接口方法参数类型必须与statement标签的parameterType类型一致</p>
</li>
<li><p>4。接口方法返回值类型必须与statement标签的ResultType类型一致</p>
</li>
<li><p>5。接口和映射文件同名，同包</p>
</li>
</ul>
<h2 id="十-接口代理的增删改查"><a href="#十-接口代理的增删改查" class="headerlink" title="十 接口代理的增删改查"></a>十 接口代理的增删改查</h2></User></package></dataSource></environment></environments></environment></environments>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/08/PreparedStatement-%E8%BF%9E%E6%8E%A5%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/PreparedStatement-%E8%BF%9E%E6%8E%A5%E6%B1%A0/" class="post-title-link" itemprop="url">PreparedStatement & 连接池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-08 01:35:47" itemprop="dateCreated datePublished" datetime="2020-05-08T01:35:47+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.PreparedStatement<br>1.1 概述<br>SQL注入问题</p>
<p>我们让用户输入的信息和SQL语句进行字符串拼接。用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL</p>
<p>真正的意义，以上问题称为SQL注入。</p>
<p>1<br>2<br>3<br>– 这条sql语句原有的含义是根据用户名和密码查询<br>– 现在用户输入了一些特殊字符，改变了sql原有的含义，这种行为成为sql注入<br>SELECT * FROM USER WHERE username &#x3D;’admin’# ‘ and password &#x3D;’’<br>解决SQL注入问题</p>
<p>我们就不能让用户输入的信息和SQL语句进行字符串拼接。需要使用PreparedSatement对象解决SQL注入。</p>
<p>1<br>2<br>3<br>4<br>– 在java语言中修复sql注入问题，通过占位符代替实际参数<br>SELECT * FROM USER WHERE username &#x3D; ? AND password &#x3D; ?<br>– 仅仅模拟sql解决思想，非真实解决方案<br>SELECT * FROM USER WHERE username &#x3D; “admin’#” AND PASSWORD &#x3D; “”<br>PreparedSatement基础语法</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>&#x2F;&#x2F; 1.获取连接<br>&#x2F;&#x2F; 2.编写sql【占位符代替实际参数】<br>String sql &#x3D; “SELECT * FROM USER WHERE username &#x3D; ? AND password &#x3D; ?”;<br>&#x2F;&#x2F; 3.获取sql预编译执行对象，先发送给数据库进行预编译<br>PreparedStatement pstmt &#x3D; connection.prepareStatement(sql);<br>&#x2F;&#x2F; 4.设置占位符实际参数<br>pstmt.setString(1,”admin’#”);<br>pstmt.setString(2,””);<br>&#x2F;&#x2F; 5.执行sql语句，并返回结果【注意，不需要传递sql参数】<br>ResultSet resultSet &#x3D; pstmt.executeQuery();<br>&#x2F;&#x2F; 6.处理结果 &#x2F;&#x2F; 7.释放资源<br>优点</p>
<p>防止sql注入，提高安全性</p>
<p>参数与sql分离，提高代码可读性</p>
<p>减少编译次数，提高性能</p>
<p>1.2 操作<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83</p>
<p>public class CRUD_DEMO {<br>    &#x2F;&#x2F;新增<br>    @Test<br>    public void testInsert() throws Exception {<br>        &#x2F;&#x2F;获取连接<br>        Connection connection &#x3D; JdbcUtils.getConnection();<br>        &#x2F;&#x2F;编写sql<br>        String sql &#x3D; “INSERT INTO user VALUES (NULL ,?,?);”;<br>        &#x2F;&#x2F;获取sql预编译执行对象<br>        PreparedStatement preparedStatement &#x3D; connection.prepareStatement(sql);<br>        &#x2F;&#x2F;设计实际参数<br>        preparedStatement.setString(1, “Jerry”);<br>        preparedStatement.setString(2, “999”);<br>        &#x2F;&#x2F;执行sql并返回结果<br>        int i &#x3D; preparedStatement.executeUpdate();<br>        &#x2F;&#x2F;处理结果<br>        if (i &gt; 0) {<br>            System.out.println(“First Recording Add Successful”);<br>        }<br>        preparedStatement.setString(1, “Ming”);<br>        preparedStatement.setString(2, “999”);<br>        i &#x3D; preparedStatement.executeUpdate();<br>        if (i &gt; 0) {<br>            System.out.println(“Second Recording Add Successful”);<br>        }<br>        &#x2F;&#x2F;释放资源<br>        JdbcUtils.close(preparedStatement, connection);<br>    }</p>
<pre><code>//修改
@Test
public void testUpdate() throws Exception &#123;
    //获取连接
    Connection connection = JdbcUtils.getConnection();
    //编写sql
    String sql = &quot;UPDATE user SET username = ? where id = ?;&quot;;
    //获取预编译sql执行对
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    //设计实际参数
    preparedStatement.setString(1, &quot;RRR&quot;);
    preparedStatement.setInt(2, 3);
    //执行sql,并返回结果
    int i = preparedStatement.executeUpdate();
    //处理结果
    if (i &gt; 0) &#123;
        System.out.println(&quot;Update Successful&quot;);
    &#125;
    //释放资源
    JdbcUtils.close(preparedStatement, connection);
&#125;

//删除
@Test
public void testDelete() throws Exception &#123;
    Connection connection = JdbcUtils.getConnection();
    String sql = &quot;DELETE FROM user WHERE id=?&quot;;
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    preparedStatement.setInt(1, 6);
    int i = preparedStatement.executeUpdate();
    if (i &gt; 0) &#123;
        System.out.println(&quot;Delete Successful&quot;);
    &#125;
    JdbcUtils.close(preparedStatement, connection);
&#125;

//查询
@Test
public void testFindAll() throws Exception &#123;
    Connection connection = JdbcUtils.getConnection();
    String sql = &quot;SELECT * FROM user;&quot;;
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    ResultSet resultSet = preparedStatement.executeQuery();
    while (resultSet.next()) &#123;
        int id = resultSet.getInt(&quot;id&quot;);
        String username = resultSet.getString(&quot;username&quot;);
        String password = resultSet.getString(&quot;password&quot;);
        System.out.println(&quot;\tID:&quot; + id + &quot;\tUSERNAME:&quot; + username + &quot;\tPASSWORD:&quot; + password);

    &#125;
    JdbcUtils.close(preparedStatement, connection);
&#125;
</code></pre>
<p>}<br>二.连接池<br>2.1 概述<br>连接池其实就是一个容器(集合)，存放数据库连接的容器。</p>
<p>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用 户访问完之后，会将连接对象归还给容器。</p>
<p>优点</p>
<p>节约资源，减轻服务器压力</p>
<p>提高连接复用性，用户访问高效</p>
<p>常见连接池</p>
<p>DBCP	Apache提供的数据库连接池技术。<br>C3P0	数据库连接池技术，目前使用它的开源项目有Hibernate、Spring等。<br>HikariCP	日本开发的连接池技术，性能之王,目前使用它的开源项目有SpringBoot等。<br>Druid(德鲁伊)	阿里巴巴提供的数据库连接池技术<br>实现</p>
<p>Java为数据库连接池提供了公共的接口: DataSource ，各个连接池厂商去实现这套接口，提供jar包。</p>
<p>功能	<br>获取连接	Connection getConnection()<br>归还连接	connection.close()<br>若连接对象通过连接池获取，执行 connection.close() 方法时，是归还到连接池，非销毁对象<br>底层通过动态代理技术对close()方法进行了增强<br>2.2 Druid连接池<br>2.2.1 快速入门<br>导入jar包</p>
<p>druid-1.1.10.jar</p>
<p>mysql-connector-java-8.0.16.jar</p>
<p>编写测试代码(耦合版本)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>public class DruidDemo1 {<br>    public static void main(String[] args) throws SQLException {</p>
<pre><code>    // 1.创建druid连接池对象
    DruidDataSource dataSource = new DruidDataSource();

    // 2.与mysql建立连接(初始化一些连接个数)，设置数据库基本四项
    dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/Day48&quot;);
    dataSource.setUsername(&quot;root&quot;);
    dataSource.setPassword(&quot;root&quot;);

    // 3.从连接池中获取连接
    Connection connection = dataSource.getConnection();

    // 4.处理业务
    System.out.println(connection);
    // 5.归还连接,注意，非销毁
    connection.close();

&#125;
</code></pre>
<p>}<br>2.2.2 配置文件<br>参数设置	作用<br>initialSize	初始化建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时<br>maxActivve	最大连接池数量<br>MinIdle	最小连接池数量<br>maxWait	获取连接时最大等待时间，ms<br>定义配置文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>#druid.properties<br>#基本4项，必须有，左边名称限定<br>driverClassName&#x3D;com.mysql.jdbc.Driver<br>url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;Day48<br>username&#x3D;root<br>password&#x3D;root</p>
<h1 id="初始化个数"><a href="#初始化个数" class="headerlink" title="初始化个数"></a>初始化个数</h1><p>initialSize&#x3D;5<br>#最大连接个数<br>maxActivve&#x3D;10<br>#等待时间，ms<br>maxWait&#x3D;3000<br>编写代码(解耦合版)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>public class DruidDemo2 {</p>
<pre><code>public static void main(String[] args) throws Exception &#123;
    // 通过类加载器读取src目录下配置文件，获取io流
    InputStream is = DruidDemo2.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
    // 创建 Properties对象
    Properties properties = new Properties();
    properties.load(is);

    // druid连接池工厂对象，初始化连接池
    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);

    // 获取连接
    for (int i = 0; i &lt;= 11; i++) &#123;
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        if (i == 10) &#123;
            connection.close();
        &#125;
    &#125;
        // 归还连接
        //connection.close();

&#125;
</code></pre>
<p>}<br>2.3 连接工具类<br>我们每次操作数据库都需要创建连接池，获取连接，关闭资源，都是重复的代码。我们可以将创建连接池和获取连接</p>
<p>池的代码放到一个工具类中。</p>
<p>保证连接池对象，只创建一次</p>
<p>目的:简化书写，提高效率</p>
<p>1<br>2<br>3<br>4<br>5<br>public class JdbcUtils{<br>&#x2F;&#x2F; 1.初始化连接池对象(druid)，一个项目只有一个 static{} &#x2F;&#x2F; 2.提供获取连接池对象静态方法<br>&#x2F;&#x2F; 3.提供连接对象的静态方法<br>&#x2F;&#x2F; 4.提供释放资源的静态方法(connection是归还)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>public class JdbcUtils {</p>
<pre><code>private static DataSource dataSource = null;

// 1.初始化连接池对象(druid)，一个项目只有一个 static&#123;&#125;
static &#123;
    try &#123;
        // 通过类加载器读取src目录下配置文件，获取io流
        InputStream is = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
        // 创建 Properties对象
        Properties properties = new Properties();
        properties.load(is);
        // druid连接池工厂对象，初始化连接池
        dataSource = DruidDataSourceFactory.createDataSource(properties);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

// 2.提供获取连接池对象静态方法
public static DataSource getDataSource() &#123;
    return dataSource;
&#125;

// 3.提供连接对象的静态方法
public static Connection getConnection() throws SQLException &#123;
    return dataSource.getConnection();
&#125;

// 4.提供释放资源的静态方法(connection是归还)
public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;
    if (resultSet != null) &#123;
        try &#123;
            resultSet.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    if (statement != null) &#123;
        try &#123;
            statement.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    if (connection != null) &#123;
        try &#123;
            connection.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

// 重载关闭方法
public static void close(Statement statement, Connection connection) &#123;
    close(null, statement, connection);
&#125;
</code></pre>
<p>}<br>三.案例:用户登录<br>需求</p>
<p>使用三层架构+JDBC连接池技术(面向接口编程)，实现用户登录案例</p>
<p>3.1 需求分析<br>Login.jsp			Server			数据库<br>web层	service层	dao层		<br>UserName<br>Password	➡<br>⬅	Servlet接口	UserService接口	UserDao接口	➡<br>⬅	SQL<br>Login		⬆	⬆	⬆		<br>LoginServlet<br>1.接收请求<br>2.调用service<br>3.判断转发&#x2F;重定向	UserServiceImpl实现类	UserDaoImpl实现类		<br>Login.jsp			Server			数据库<br>LoginServlet	UserServiceImpl	UserDaoImpl		<br>UserName<br>Password	➡<br>⬅	实现了Servlet接口	实现了UserService接口	实现了UserDao接口	➡<br>⬅	SQL<br>Login		1.接收请求参数<br>username<br>password<br>2.调用service，返回User对象<br>3.判断User对象<br>转发，提示用户名&#x2F;密码错误<br>重定向list.jsp	public User login(user, pwd) {<br>调用dao，返回user对象<br>}	public User login(user, pwd) {<br>使用JDBC连接池获取连接<br>查询数据库<br>将结果封装到user对象中 }		<br>3.2 环境搭建<br>使用昨天的数据库和user表</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>CREATE TABLE USER<br>(<br>    id       INT PRIMARY KEY AUTO_INCREMENT,<br>    username VARCHAR(50),<br>    password VARCHAR(50)<br>);<br>INSERT INTO USER (username, password)<br>VALUES (‘admin’, ‘123’),<br>       (‘tom’, ‘123’),<br>       (‘jack’, ‘123’);</p>
<p>创建web工程，导入相关jar包</p>
<p>commons-beanutils-1.8.3.jar</p>
<p>commons-logging-1.1.1.jar</p>
<p>druid-1.1.10.jar</p>
<p>javax.servlet.jsp.jstl.jar</p>
<p>jstl-impl.jar</p>
<p>mysql-connector-java-8.0.16.jar</p>
<p>导入页面资源</p>
<p>创建三层包目录结构</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>src<br>├── com<br>│   └── case<br>│       ├── dao<br>│       │   ├── UserDao.java<br>│       │   └── UserDaoImpl.java<br>│       ├── domain<br>│       │   └── User.java<br>│       ├── service<br>│       │   ├── UserService.java<br>│       │   └── UserServiceImpl.java<br>│       ├── util<br>│       │   └── JdbcUtils.java<br>│       └── web<br>│           ├── filter<br>│           │   └── EncodeFilter.java<br>│           └── servlet<br>│               └── LoginServlet.java<br>└── druid.properties</p>
<p>9 directories, 9 files<br>导入JbdcUtils工具类</p>
<p>编写User实体类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>public class User {<br>    private Integer id;<br>    private String username;<br>    private String password;</p>
<pre><code>//省略getter/setter，toString，全参构造
</code></pre>
<p>3.3 代码实现<br>LoginServlet<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>@WebServlet(“&#x2F;LoginServlet”)<br>public class LoginServlet extends HttpServlet {<br>    @Override<br>    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>        this.doPost(req, resp);<br>    }</p>
<pre><code>@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    // 处理编码
</code></pre>
<p>&#x2F;&#x2F;        req.setCharacterEncoding(“utf-8”);<br>&#x2F;&#x2F;        resp.setContentType(“text&#x2F;html;charset&#x3D;utf-8”);</p>
<pre><code>    // 1.接收请求参数
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);

    // 2.调用service
    UserServiceImpl userService = new UserServiceImpl();
    User user = userService.login(username, password);

    // 3.判断
    if(user==null)&#123;
        // 登录失败，友情提示
        req.setAttribute(&quot;error&quot;,&quot;Username/Password Wrong&quot;);
        req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,resp);
    &#125;else &#123;
        // 登录成功
        req.getSession().setAttribute(&quot;user&quot;,user);
        resp.sendRedirect(req.getContextPath()+&quot;/list.jsp&quot;);
    &#125;
&#125;
</code></pre>
<p>}<br>UserService 接口</p>
<p>1<br>2<br>3<br>4<br>5<br>public interface UserService {<br>    &#x2F;&#x2F;根据用户名密码查询User对象<br>    public User login(String username, String password);<br>}</p>
<p>UserServiceImpl 实现类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>public class UserServiceImpl implements UserService {<br>    @Override<br>    public User login(String username, String password) {<br>        UserDaoImpl userDao &#x3D; new UserDaoImpl();<br>        return userDao.login(username,password);<br>    }<br>}<br>UserDao 接口</p>
<p>1<br>2<br>3<br>4<br>public interface UserDao {<br>    &#x2F;&#x2F;根据用户名密码查询User对象<br>    public User login(String username, String password);<br>}<br>UserDaoImpl 实现类</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public User login(String username, String password) {<br>        Connection connection &#x3D; null;<br>        PreparedStatement preparedStatement &#x3D; null;<br>        ResultSet resultSet &#x3D; null;</p>
<pre><code>    try &#123;
        // 1.获取连接【从连接池】
        connection = JdbcUtils.getConnection();
        // 2.编写sql
        String sql = &quot;SELECT * FROM user WHERE username= ? AND password = ?;&quot;;
        // 3.获取sql预编译执行对象
        preparedStatement = connection.prepareStatement(sql);
        // 4.设置实际参数
        preparedStatement.setString(1, username);
        preparedStatement.setString(2, password);
        // 5.执行sql并返回结果
        resultSet = preparedStatement.executeQuery();
        // 6.处理结果
        User user = null;

        if (resultSet.next()) &#123;
            // 获取 id 用户名、密码
            int id = resultSet.getInt(&quot;id&quot;);
            username = resultSet.getString(&quot;username&quot;);
            password = resultSet.getString(&quot;password&quot;);
            user = new User();
            user.setId(id);
            user.setUsername(username);
            user.setPassword(password);
        &#125;
        return user;

    &#125; catch (SQLException throwables) &#123;
        throwables.printStackTrace();
    &#125; finally &#123;
        // 7.释放资源
        JdbcUtils.close(resultSet, preparedStatement, connection);
    &#125;
    return null;
&#125;
</code></pre>
<p>}<br>总结</p>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>预编译sql执行对象</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>1）防止sql注入，提高安全性</p>
</li>
<li><p>2）减少编译次数，提高效率</p>
</li>
<li><p>3）参数与sql语句分离，提高可读性</p>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>1）注册驱动</p>
</li>
<li><p>2）建立连接</p>
</li>
<li><p>3）编写sql ?占位符代替参数</p>
</li>
<li><p>4）获取sql预编译执行对象 先将sql发送到数据库</p>
</li>
<li><p>5）设置实际参数</p>
</li>
<li><p>6）执行sql并返回结果</p>
</li>
<li><p>7）处理结果</p>
</li>
<li><p>8）释放资源</p>
</li>
</ul>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul>
<li><p>重写登录案例</p>
</li>
<li><p>CRUD练习</p>
</li>
</ul>
<h2 id="datasource"><a href="#datasource" class="headerlink" title="datasource"></a>datasource</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><ul>
<li>在系统初始化时，创建一个连接池生成一些连接对象，用户访问数据库时，从连接池获取连接，使用完毕归还到连接池</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>1）减轻服务器压力</p>
</li>
<li><p>2）提高连接复用性</p>
</li>
</ul>
<h3 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a>dataSource</h3><ul>
<li>是sun公司提供连接池规范（接口），连接池厂商根据接口编写实现类</li>
</ul>
<p>​ - c3p0</p>
<p>​ - hikariCP</p>
<p>​ - Druid</p>
<h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><ul>
<li>druid快速入门</li>
</ul>
<p>​ - 1）导入jar包</p>
<p>​ - 2）定义配置文件</p>
<p>​ - 3）编写代码</p>
<ul>
<li>druid连接池工具类</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/06/JDBC%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/JDBC%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">JDBC基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 01:35:06" itemprop="dateCreated datePublished" datetime="2020-05-06T01:35:06+08:00">2020-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.JDBC基础<br>1.1 概述<br>Java 数据库连接(Java DataBase Connectivity)</p>
<p>作用:通过Java语言操作数据库</p>
<p>本质:是官方(sun公司)定义的一套操作所有关系型数据库的规则(接口)。各个数据库厂商去实现这套接口，提 供数据库驱动jar包。我们可以使用这套接口(JDBC)编程，运行时的代码其实是驱动jar包中的实现类。</p>
<p>1.2 快速入门<br>需求</p>
<p>通过java代码向数据库user表插入一条记录</p>
<p>准备数据库和表</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>CREATE DATABASE Day48;<br>USE Day48;<br>CREATE TABLE USER<br>(<br>    id       INT PRIMARY KEY AUTO_INCREMENT,<br>    username VARCHAR(50),<br>    password VARCHAR(50)<br>);<br>INSERT INTO USER (username, password)<br>VALUES (‘admin’, ‘123’),<br>       (‘tom’, ‘123’),<br>       (‘jack’, ‘123’);</p>
<p>SELECT * FROM USER;<br>创建java工程，导入MySQL驱动jar包</p>
<p>mysql-connector-java-5.1.45-bin.jar</p>
<p>编写插入代码</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>public class JDBCDEMO {<br>    public static void main(String[] args) throws Exception {<br>        &#x2F;&#x2F;1.注册驱动<br>&#x2F;&#x2F;        DriverManager.registerDriver(new Driver());<br>        Class.forName(“com.mysql.jdbc.Driver”);<br>        &#x2F;&#x2F;2.建立连接<br>        Connection connection &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;Day48”, “root”, “root”);<br>        &#x2F;&#x2F;3.编写sql<br>        String sql &#x3D; “insert into user values(4,’lucy’,666)”;<br>        &#x2F;&#x2F;4.获取sql执行对象<br>        Statement statement &#x3D; connection.createStatement();<br>        &#x2F;&#x2F;5.执行sql并返回结果<br>        int i &#x3D; statement.executeUpdate(sql);<br>        &#x2F;&#x2F;6.处理结果<br>        if (i &gt; 0) {<br>            System.out.println(“Success”);<br>        } else {<br>            System.out.println(“Failed”);<br>        }<br>        &#x2F;&#x2F;7.释放资源<br>        statement.close();<br>        connection.close();<br>    }<br>}<br>1.3 API介绍<br>sun公司提供的:java.sql包下</p>
<p>DriverManager:驱动管理对象</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>1.注册驱动<br>        1)static void registerDriver(Driver driver)<br>        我们通过翻看MySQL Driver实现类的源码发现内部的静态代码已经提供了注册驱动功能<br>static {<br>        try{<br>                DriverManager.registerDriver(new Driver());<br>        }catch(SQLException var1){<br>                throw new RuntimeException(“Can’t register driver!”);<br>            }<br>        }<br>        2)反射<br>        Class.forName(“com.mysql.jdbc.Driver”);<br>        3)SPI 服务提供接口 【Service Provider Interface】<br>2.建立连接<br>static Connection getConnection(String url,String user,String password)<br>参数说明:<br>        url:连接指定数据库地址【固定格式】<br>        格式:jdbc:mysql:&#x2F;&#x2F;ip地址+端口&#x2F;数据库名<br>        实例:<br>        jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;day23<br>        jdbc:mysql:&#x2F;&#x2F;&#x2F;day23<br>      user:用户名<br>      password:密码<br>Connection:数据库连接对象</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<ol>
<li>获取sql执行对象【小货车】<br>  Statement createStatement()<br>  PreparedStatement prepareStatement(String sql)  </li>
<li>事务管理<br> 1)关闭自动提交(开启事务)<br>     void setAutoCommit(boolean autoCommit)<br>   参数:<br>   true:自动提交【默认值】<br>   false:手动提交<br> 2)提交事务<br> void commit()<br> 3)回滚事务<br> void rollback()<br>Statement:执行sql的对象</li>
</ol>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<ol>
<li>执行所有类型sql语句【了解】<br> boolean execute(String sql)</li>
<li>仅执行DML类型sql语句<br> int executeUpdate(String sql)<br>   参数:dml类型sql(insert、update、delete)<br>   返回值:影响行数</li>
<li>仅执行DQL类型sql语句<br> ResultSet executeQuery(String sql)<br> 参数:dql类型sql(select)<br> 返回值:结果集<br>ResultSet:结果集对象,封装查询结果</li>
</ol>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<ol>
<li><p>指针下移<br> boolean next()<br>     返回值:<br>   true:表示此行有数据<br>   false:表示此行没有数据<br> while(resultSet.next){<br>     &#x2F;&#x2F;获取一行数据<br> }</p>
</li>
<li><p>获取数据<br>  根据制定列编号和数据类型获取<br> T getXxx(int 列编号)<br>  根据指定列名和数据类型获取<br> T getXxx(String 列名)</p>
<p> 补充:获取所有类型<br> Object getObject(String 列名)<br> String getString(String 列名)</p>
</li>
</ol>
<p>1.4 CRUD操作<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>&#x2F;&#x2F; 1.注册驱动<br>&#x2F;&#x2F; 2.建立连接<br>&#x2F;&#x2F; 3.编写sql<br>&#x2F;&#x2F; 4.获取sql执行对象 &#x2F;&#x2F; 5.执行sql并返回结果 &#x2F;&#x2F; 6.处理结果<br>&#x2F;&#x2F; 7.释放资源</p>
<p>public class CRUDDEMO {<br>    &#x2F;&#x2F;新增<br>    @Test<br>    public void testInsert() throws Exception {<br>        Class.forName(“com.mysql.jdbc.Driver”);<br>        Connection connection &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;Day48”, “root”, “root”);<br>        String sql &#x3D; “insert into user values(NULL,’testInsert’,666)”;<br>        Statement statement &#x3D; connection.createStatement();<br>        int i &#x3D; statement.executeUpdate(sql);<br>        if (i &gt; 0) {<br>            System.out.println(“Successful”);<br>        } else {<br>            System.out.println(“Failed”);<br>        }<br>        statement.close();<br>        connection.close();<br>    }</p>
<pre><code>//修改
@Test
public void testUpdate() throws Exception &#123;
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/Day48&quot;, &quot;root&quot;, &quot;root&quot;);
    String sql = &quot;UPDATE user SET username=&#39;testUpdate&#39; WHERE id = 4&quot;;
    Statement statement = connection.createStatement();
    int i = statement.executeUpdate(sql);
    if (i &gt; 0) &#123;
        System.out.println(&quot;Successful&quot;);
    &#125; else &#123;
        System.out.println(&quot;Failed&quot;);
    &#125;
    statement.close();
    connection.close();
&#125;

//删除
@Test
public void testAlter() throws Exception &#123;
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/Day48&quot;, &quot;root&quot;, &quot;root&quot;);
    String sql = &quot;delete from user WHERE id = 2&quot;;
    Statement statement = connection.createStatement();
    int i = statement.executeUpdate(sql);
    if (i &gt; 0) &#123;
        System.out.println(&quot;Successful&quot;);
    &#125; else &#123;
        System.out.println(&quot;Failed&quot;);
    &#125;
    statement.close();
    connection.close();
&#125;

//查询
@Test
public void testFindAll() throws Exception &#123;
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/Day48&quot;, &quot;root&quot;, &quot;root&quot;);
    String sql = &quot;SELECT * FROM user&quot;;
    Statement statement = connection.createStatement();
    ResultSet resultSet = statement.executeQuery(sql);

    while (resultSet.next()) &#123;
        int id = resultSet.getInt(&quot;id&quot;);
        String username = resultSet.getString(&quot;username&quot;);
        String password = resultSet.getString(&quot;password&quot;);
        System.out.println(&quot;\tID:&quot; + id + &quot;\tUSERNAME:&quot; + username + &quot;\tPASSWORD:&quot; + password);
    &#125;
    resultSet.close();
    statement.close();
    connection.close();
&#125;
</code></pre>
<p>}<br>1.5 工具类<br>通过上面案例需求我们会发现每次去执行SQL语句都需要注册驱动，获取连接，得到Statement，以及释放资源。发</p>
<p>现很多重复的劳动，我们可以将重复的代码定义到一个工具类中。</p>
<p>目的:简化书写，一劳永逸</p>
<p>步骤分析</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>public class JdbcUtils{<br>&#x2F;&#x2F; 1.注册驱动【保证一次】<br>static{ }<br>&#x2F;&#x2F; 2.提供获取连接的静态方法<br>public static Connection getConnection(){<br>        return null;<br>    }<br>&#x2F;&#x2F; 3.提供释放资源的方法<br>  public void close(){<br>        }<br>}<br>1.5.1 版本一<br>该版本具有耦合性<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>public class JdbcUtils1 {<br>    &#x2F;&#x2F; 1.注册驱动【保证一次】<br>    static {<br>        try {<br>            Class.forName(“com.mysql.jdbc.Driver”);<br>        } catch (ClassNotFoundException e) {<br>            throw new RuntimeException(“Load JDBC Driver Failed”);<br>        }<br>    }</p>
<pre><code>// 2.提供获取连接的静态方法
public static Connection getConnection() throws SQLException &#123;
    return DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/Day48&quot;, &quot;root&quot;, &quot;root&quot;);
&#125;

// 3.提供释放资源的方法
public void close(ResultSet resultSet, Statement statement, Connection connection) &#123;
    if (resultSet != null) &#123;
        try &#123;
            resultSet.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    if (statement != null) &#123;
        try &#123;
            statement.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    if (connection != null) &#123;
        try &#123;
            connection.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

// 重载关闭方法
public static void close(Statement statement, Connection connection) &#123;
    close(statement, connection);
&#125;
</code></pre>
<p>}</p>
<p>1.5.2 版本二<br>解耦合版本</p>
<p>1<br>2<br>3<br>4<br>5<br>#K-V<br>jdbc.driver&#x3D;com.mysql.jdbc.Driver<br>jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;Day48<br>jdbc.user&#x3D;root<br>jdbc.password&#x3D;root<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>public class JdbcUitls {</p>
<pre><code>// 声明变量
private static String driver = null;
private static String url = null;
private static String user = null;
private static String password = null;

// 加载jdbc.properties配置文件，初始化变量
static &#123;
    ResourceBundle jdbc = ResourceBundle.getBundle(&quot;jdbc&quot;);
    driver = jdbc.getString(&quot;jdbc.driver&quot;);
    url = jdbc.getString(&quot;jdbc.url&quot;);
    user = jdbc.getString(&quot;jdbc.user&quot;);
    password = jdbc.getString(&quot;jdbc.password&quot;);
&#125;

// 1.注册驱动【保证一次】
static &#123;
    try &#123;
        Class.forName(driver);
    &#125; catch (ClassNotFoundException e) &#123;
        throw new RuntimeException(&quot;Load Driver Failed&quot;);
    &#125;
&#125;

// 2.提供获取连接的静态方法
public static Connection getConnection() throws Exception &#123;
    return DriverManager.getConnection(url, user, password);
&#125;

// 3.提供释放资源的方法
public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;
    if (resultSet != null) &#123;
        try &#123;
            resultSet.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    if (statement != null) &#123;
        try &#123;
            statement.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    if (connection != null) &#123;
        try &#123;
            connection.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

// 重载关闭方法
public static void close(Statement statement, Connection connection) &#123;
    close(null, statement, connection);
&#125;
</code></pre>
<p>}</p>
<p>1.6 事务操作<br>事务</p>
<p>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败</p>
<p>MySQL事务操作</p>
<p>事务	<br>开启事务	begin | start transaction;<br>提交事务	commit;<br>回顾事务	rollback;<br>Java操作(使用Connection对象)</p>
<p>事务	<br>关闭自动提交(开启事务)	void setAutoCommit(false);<br>提交事务	void commit();<br>回顾事务	void rollback();<br>需求:</p>
<p>通过Java代码实现转账案例</p>
<p>导入账户表</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>CREATE TABLE account(<br>  id INT PRIMARY KEY AUTO_INCREMENT,<br>  <code>name</code> VARCHAR(10),<br>  money DOUBLE<br>);<br>INSERT INTO account(<code>name</code>,money) VALUES (‘UserA’,1000),(‘UserB’,1000);</p>
<p>编写转账代码</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>public class TXDemo{<br>@Test<br>    public void testTX(){<br>        try{<br>          &#x2F;&#x2F; 1.获取连接【JdbcUtils工具类】<br>          &#x2F;&#x2F; 2.开启事务<br>                    &#x2F;&#x2F; 3.UserA扣钱<br>                    &#x2F;&#x2F; 机器故障<br>                    &#x2F;&#x2F; 4.UserB加钱<br>                    &#x2F;&#x2F; 5.提交事务<br>        }catch(Exception e){<br>          &#x2F;&#x2F; 6.回滚事务<br>                }finally{<br>                    &#x2F;&#x2F; 7.释放资源<br>            }<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>public class TXDemo {<br>@Test<br>    public void testTX() {<br>        Connection connection &#x3D; null;<br>        Statement statement &#x3D; null;<br>        try {<br>          &#x2F;&#x2F; 1.获取连接【JdbcUtils工具类】<br>                    connection &#x3D; JdbcUitls.getConnection();<br>          &#x2F;&#x2F; 2.开启事务<br>          connection.setAutoCommit(false);<br>          tatement &#x3D; connection.createStatement();<br>          &#x2F;&#x2F; 3.UserA扣钱<br>          &#x2F;&#x2F; 机器故障<br>          &#x2F;&#x2F; 4.UserB加钱<br>          &#x2F;&#x2F; 5.提交事务<br>          connection.commit();<br>          } catch (Exception e) {<br>    try {<br>                    &#x2F;&#x2F; 6.回滚事务<br>                    connection.rollback();<br>    } catch (SQLException e1) {<br>                    e1.printStackTrace();<br>    }<br>} finally {<br>                    &#x2F;&#x2F; 7.释放资源<br>                    JdbcUitls.close(statement, connection);<br>        }<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>public class TXDemo {<br>    @Test<br>    public void testTX() {<br>        Connection connection &#x3D; null;<br>        Statement statement &#x3D; null;<br>        try {<br>            &#x2F;&#x2F; 1.获取连接【JdbcUtils工具类】<br>            connection &#x3D; JdbcUitls.getConnection();<br>            &#x2F;&#x2F; 2.开启事务<br>            connection.setAutoCommit(false);<br>            statement &#x3D; connection.createStatement();</p>
<pre><code>        // 3.UserA扣钱
        String ASql = &quot;update account set money = money-100 where id=2;&quot;;
        int AResult = statement.executeUpdate(ASql);
        if (AResult &gt; 0) &#123;
            System.out.println(&quot;User A Payment Successful&quot;);
        &#125;
        // 机器故障
        int a = 1 / 0;
        String BSql = &quot;update account set money = money +100 where id =1;&quot;;
        // 4.UserB收到钱
        int BResult = statement.executeUpdate(BSql);
        if (BResult &gt; 0) &#123;
            System.out.println(&quot;User B Get the Payment&quot;);
        &#125;
        // 5.提交事务
        connection.commit();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
        try &#123;
            // 6.回滚事务
            connection.rollback();
        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;
    &#125; finally &#123;
        // 7.释放资源
        JdbcUitls.close(statement, connection);
    &#125;
&#125;
</code></pre>
<p>}<br>二.案例:用户登陆<br>2.1 需求分析<br>浏览器登录		<br>⬇		<br>服务器LoginServlet		<br>接收用户请求<br>用户名，密码		<br>⬇		<br>操作JDBC<br>根据用户名和密码查询数据库	➡<br>⬅	Server<br>⬇		<br>判断用户是否登录成功		<br>⬇正确	➡错误	转发登录页面提示<br>重定向至list.jsp		<br>2.2 代码实现<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>package com.test.web;</p>
<p>import com.test.util.JdbcUitls;</p>
<p>import javax.servlet.ServletException;<br>import javax.servlet.annotation.WebServlet;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;<br>import java.sql.Connection;<br>import java.sql.ResultSet;<br>import java.sql.Statement;</p>
<p>@WebServlet(“&#x2F;LoginServlet”)<br>public class LoginServlet extends HttpServlet {<br>    @Override<br>    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>        this.doPost(req, resp);<br>    }</p>
<pre><code>@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    //统一编码
    req.setCharacterEncoding(&quot;utf-8&quot;);
    resp.setContentType(&quot;text/html;charset=utf-8&quot;);
    //接收请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);

    try &#123;
        // 2.操作JDBC
        // 2.1 获取连接
        Connection connection = JdbcUitls.getConnection();

        // 2.2 编写sql
        // String sql = &quot;select * from user where username =&#39;admin&#39; and password=&#39;123&#39;&quot;;
        String sql = &quot;SELECT * FROM user WHERE username=&#39;&quot; + username + &quot;&#39;AND password =&#39;&quot; + password + &quot;&#39;&quot;;
        System.out.println(sql);

        // 2.3 获取sql执行对象
        Statement statement = connection.createStatement();

        // 2.4 执行sql并返回结果
        ResultSet resultSet = statement.executeQuery(sql);

        // 3.判断是否登录成功
        if (resultSet.next()) &#123;// 成功
            String loginUsername = resultSet.getString(&quot;username&quot;);
            req.getSession().setAttribute(&quot;loginUsername&quot;, loginUsername);
            resp.sendRedirect(req.getContextPath() + &quot;/list.jsp&quot;);
        &#125; else &#123;// 失败
            req.setAttribute(&quot;error&quot;, &quot;Username/Password Wrong&quot;);
            req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);
        &#125;
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;

&#125;
</code></pre>
<p>}</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>通过java语言操作数据库</li>
</ul>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul>
<li><p>面向接口编程思想</p>
</li>
<li><p>sun公司通过操作关系型数据库的一套规范（接口），所有的数据库厂商都需要实现这套接口，对于开发者只需要学习这套接口的API就可以操作所有类型的关系型数据库，真正的执行者是实现类（jar包驱动）</p>
</li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul>
<li><p>1.注册驱动</p>
</li>
<li><p>2.建立连接</p>
</li>
<li><p>3.编写sql</p>
</li>
<li><p>4.获取sql执行对象</p>
</li>
<li><p>5.执行sql并返回结果</p>
</li>
<li><p>6.处理结果</p>
</li>
<li><p>7.释放资源</p>
</li>
</ul>
<h3 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h3><ul>
<li>DriverManager</li>
</ul>
<p>​ - 1.注册驱动</p>
<p>​ - Class.forName()</p>
<p>​ - 2.建立连接</p>
<ul>
<li>Connection</li>
</ul>
<p>​ - 1.获取sql执行对象</p>
<p>​ - Statement</p>
<p>​ - PreparedStatement</p>
<p>​ - 2.事务安全</p>
<ul>
<li>Statement</li>
</ul>
<p>​ - 1.仅执行DML类型sql语句</p>
<p>​ - int executeUpdate(String sql)</p>
<p>​ - 2.仅执行DQL类型sql语句</p>
<p>​ - ResultSet executeQuery(String sql)</p>
<ul>
<li>ResultSet</li>
</ul>
<p>​ - 1.指针下移</p>
<p>​ - boolean next()</p>
<p>​ - 2.获取数据</p>
<p>​ - T getXxx(String 列名)</p>
<h3 id="crud练习"><a href="#crud练习" class="headerlink" title="crud练习"></a>crud练习</h3><ul>
<li><p>新增</p>
</li>
<li><p>修改</p>
</li>
<li><p>删除</p>
</li>
<li><p>查询所有</p>
</li>
</ul>
<h3 id="JdbcUtils"><a href="#JdbcUtils" class="headerlink" title="JdbcUtils"></a>JdbcUtils</h3><ul>
<li><p>版本一</p>
</li>
<li><p>版本二</p>
</li>
</ul>
<h3 id="事务安全"><a href="#事务安全" class="headerlink" title="事务安全"></a>事务安全</h3><ul>
<li>模拟转账</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/05/04/MySQL%E5%87%BD%E6%95%B0-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/MySQL%E5%87%BD%E6%95%B0-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL函数 & 事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-04 01:34:03" itemprop="dateCreated datePublished" datetime="2020-05-04T01:34:03+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.MySQL函数<br>1.1 字符串函数<br>函数	描述	实例<br>CONCAT(s1,s2…sn)	字符串 s1,s2 等多个字符串合并为一个字符串	select concat(‘A’,’-‘,’B’);<br>CHAR_LENGTH(str)	返回字符串 str 的字符数	select char_length(‘Hello，World’);<br>LENGTH(str)	返回字符串 s 的字节数	select length(‘你好,World’);<br>UCASE(s) | UPPER(s)	将字符串转换为大写	select ucase(‘oracle’);<br>LCASE(s) | LOWER(s)	将字符串转换为小写	select lcase(‘MySQL’);<br>LOCATE(s1,s)	从字符串 s 中获取 s1 的开始位置	select locate(‘wo’,’world’);<br>TRIM(str) | LTRIM(str) | RTRIM(str)	字符串去空格	select trim(‘ 莘莘学子 ‘);<br>REPLACE(s,s1,s2)	将字符串 s2 替代字符串 s 中的字符串 s1	select replace(‘abc’,’b’,’x’);<br>SUBSTR(s, start, length)	从字符串 s 的 start 位置截取长度为 length 的子字符串	select substr(‘itcast’,’2’,’3’);<br>STRCMP(str1,str2)	比较字符串大小,左大于右时返回1，左等于右时返回0，，左小于于右时返回-1，	select strcmp(‘a’,’b’);<br>练习<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>– 1.将所有员工的昵称改为大写<br>SELECT UCASE(nickname) FROM emp;<br>– 2.显示所有员工的姓氏，截取<br>SELECT ename,SUBSTR(ename,1,1) FROM emp;<br>– 3.显示所有员工姓名字符长度<br>SELECT CHAR_LENGTH(ename) FROM emp;<br>– 4.显示所有员工姓名字节长度 SELECT LENGTH(ename) FROM emp;<br>– 5.将所有姓李的员工，姓氏替换为li<br>SELECT REPLACE(ename,’李’,’li’) FROM emp;<br>– 6.将所有员工的姓名和昵称拼接在一起<br>SELECT CONCAT(ename,nickname) FROM emp;<br>1.2 日期函数<br>函数	描述	实例<br>NOW() | CURDATE() | CURTIME()	获取系统当前日期时间、日期、时间	select now();<br>YEAR(DATE) | MONTH(DATE) | DAY(DATE)	从日期中选择出年、月、日	select year(now());<br>LAST_DAY(DATE)	返回月份的最后一天	select last_day(now());<br>ADDDATE(DATE,n) | SUBDATE(DATE,n)	计算起始日期 DATE 加(减) n 天的日期	select subdate(now(),10);<br>QUARTER(DATE)	返回日期 DATE 是第几季节，返回 1 到 4	select quarter(now());<br>DATEDIFF(d1,d2)	计算日期 d1-&gt;d2 之间相隔的天数	select datediff(now(),’1999-1-1’);<br>DATE_FORMAT(d,f)	按表达式 f的要求显示日期 d	select date_format(now(),’%Y-%m-%d’);<br>练习<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>– 1.统计每个员工入职的天数<br>SELECT ename,DATEDIFF(NOW(),joindate) FROM emp;<br>– 2.统计每个员工的工龄<br>SELECT ename,DATEDIFF(NOW(),joindate)&#x2F;365 FROM emp;<br>– 3.查询2011年入职的员工<br>SELECT * FROM emp WHERE YEAR(joindate) &#x3D; ‘2011’;<br>– 4.统计入职10年以上的员工信息<br>SELECT * FROM emp WHERE DATEDIFF(NOW(),joindate)&#x2F;365 &gt;10;<br>1.3 数字函数<br>函数	描述	实例<br>ABS(x)	返回 x 的绝对值	select abs(-10);<br>CEIL(x)|FLOOR(x)	向上(下)取整	select ceil(1.5);<br>MOD(x,y)	返回x mod y的结果，取余	select mod(5,4);<br>RAND()	返回 0 到 1 的随机数	select rand();<br>ROUND(x)	四舍五入	select round(1.2345);<br>TRUNCATE(x,y)	返回数值 x 保留到小数点后 y 位的值	select truncate(5633.123324,2);<br>练习<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>– 1.统计每个员工的工龄，超过半年的算一年<br>SELECT ename,ROUND( DATEDIFF(NOW(),joindate)&#x2F;365) FROM emp;<br>– 2.统计每个部门的平均薪资,保留2位小数<br>SELECT dept_id,TRUNCATE( AVG(salary),2 )FROM emp GROUP BY dept_id;<br>– 3.统计每个部门的平均薪资,小数向上取整<br>SELECT dept_id,CEIL( AVG(salary) )FROM emp GROUP BY dept_id;<br>– 4.统计每个部门的平均薪资,小数向下取整<br>SELECT dept_id,FLOOR( AVG(salary) )FROM emp GROUP BY dept_id;<br>1.4 高级函数<br>1.4.1 CASE表达式<br>相当于java中swtich语句</p>
<p>语法</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>SELECT<br>CASE [字段,值] WHEN 判断条件1<br>THEN 希望的到的值1 WHEN 判断条件2<br>THEN 希望的到的值2<br>ELSE 前面条件都没有满足情况下得到的值<br>END<br>FROM<br>table_name;<br>练习</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>– 查询每个员工的工资等级并排序<br>– 工资等级在1显示为 ‘努力赚钱’<br>– 工资等级在2显示为 ‘小康生活’<br>– 工资等级在3显示为 ‘可以娶媳妇’<br>– 工资等级在4显示为 ‘可以买车’<br>– 工资等级在5显示为 ‘可以买房’<br>– 工资等级不在以上列表中显示为 ‘土豪’<br>– 1.确定几张表<br>SELECT * FROM emp e INNER JOIN salarygrade sg;<br>– 2.确定连接条件<br>SELECT * FROM emp e INNER JOIN salarygrade sg ON e.<code>salary</code> BETWEEN sg.<code>losalary</code> AND sg.<code>hisalary</code>;<br>– 3.确定显示字段<br>SELECT e.ename,e.<code>salary</code>,sg.<code>grade</code> FROM emp e INNER JOIN salarygrade sg ON e.<code>salary</code> BETWEEN sg.<code>losalary</code> AND sg.<code>hisalary</code>;<br>– 4.确定业务条件<br>SELECT e.ename,e.<code>salary</code>,<br>CASE sg.<code>grade</code> WHEN 1 THEN WHEN 2 THEN WHEN 3 THEN WHEN 4 THEN WHEN 5 THEN<br>ELSE ‘土豪’ END AS ‘生活状态’<br>‘努力赚钱’ ‘小康生活’ ‘可以娶媳妇’ ‘可以买车’ ‘可以买房’<br>FROM emp e INNER JOIN salarygrade sg ON e.<code>salary</code> BETWEEN sg.<code>losalary</code> AND sg.<code>hisalary</code> ORDER BY sg.<code>grade</code> ASC;<br>1.4.2 IF表达式<br>相当于java中三元运算符</p>
<p>语法</p>
<p>1<br>SELECT IF(1 &gt; 0,’真’,’假’) from 表名;<br>练习</p>
<p>1<br>2<br>– 工资+奖金大于20000的员工 显示家有娇妻，否则显示单身狗<br>SELECT ename,IF(salary+IFNULL(bonus,0) &gt; 20000,’家有娇妻’,’单身狗’) AS 家里有啥 FROM emp;<br>二.MySQL综合练习<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>– 1.计算员工的日薪(按30天)，保留二位小数<br>SELECT ename,TRUNCATE(salary&#x2F;30,2) FROM emp;<br>– 2.计算出员工的年薪(12月)，并且以年薪排序 降序<br>SELECT ename,(salary + IFNULL(bonus,0)) * 12 AS 年薪 FROM emp ORDER BY 年薪 DESC;<br>– 3.找出奖金少于5000或者没有获得奖金的员工的信息<br>SELECT * FROM emp WHERE IFNULL(bonus,0) &lt; 5000;</p>
<p>– 4.返回员工职务名称及其从事此职务的最低工资<br>– 4.1 确定几张表<br>SELECT * FROM emp e INNER JOIN job j;<br>– 4.2 确定连接条件<br>SELECT * FROM emp e INNER JOIN job j ON e.<code>job_id</code> &#x3D; j.<code>id</code>;<br>– 4.3 确定显示字段<br>SELECT j.<code>jname</code> FROM emp e INNER JOIN job j ON e.<code>job_id</code> &#x3D; j.<code>id</code>;<br>– 4.4 确定业务条件(分组+最低工资)<br>SELECT j.<code>jname</code>,MIN(e.<code>salary</code>) FROM emp e INNER JOIN job j ON e.<code>job_id</code> &#x3D; j.<code>id</code> GROUP BY j.<code>jname</code>;</p>
<p>– 5.返回工龄超过10年，且2月份入职的员工信息<br>SELECT * FROM emp WHERE DATEDIFF(NOW(),joindate)&#x2F;365 &gt; 10 AND MONTH(joindate) &#x3D; 2;<br>– 6.返回与 林冲 同一年入职的员工<br>SELECT YEAR(joindate) FROM emp WHERE ename &#x3D; ‘林冲’;<br>SELECT * FROM emp WHERE YEAR(joindate) &#x3D; (SELECT YEAR(joindate) FROM emp WHERE ename &#x3D; ‘林 冲’);<br>– 7.返回每个员工的名称及其上级领导的名称(自关联)<br>SELECT a.<code>ename</code>,b.<code>ename</code> FROM emp a LEFT OUTER JOIN emp b ON a.<code>mgr</code> &#x3D; b.<code>id</code>;</p>
<p>– 8.返回工资为二等级(工资等级表)的职员名字(员工表)、部门名称(部门表)<br>– 8.1 确定几张表<br>SELECT * FROM emp e<br>    INNER JOIN dept d<br>INNER JOIN salarygrade sg;<br>– 8.2 确定连接条件<br>SELECT * FROM emp e<br>INNER JOIN dept d ON e.<code>dept_id</code> &#x3D; d.<code>id</code><br>INNER JOIN salarygrade sg ON e.<code>salary</code> BETWEEN sg.<code>losalary</code> AND sg.<code>hisalary</code>;<br>– 8.3 确定显示字段<br>SELECT sg.<code>grade</code>,e.<code>ename</code>,d.<code>dname</code> FROM emp e<br>INNER JOIN dept d ON e.<code>dept_id</code> &#x3D; d.<code>id</code><br>INNER JOIN salarygrade sg ON e.<code>salary</code> BETWEEN sg.<code>losalary</code> AND sg.<code>hisalary</code>;<br>– 8.4 确定业务条件<br>SELECT sg.<code>grade</code>,e.<code>ename</code>,d.<code>dname</code> FROM emp e<br>INNER JOIN dept d ON e.<code>dept_id</code> &#x3D; d.<code>id</code><br>INNER JOIN salarygrade sg ON e.<code>salary</code> BETWEEN sg.<code>losalary</code> AND sg.<code>hisalary</code> WHERE sg.<code>grade</code> &#x3D; 2;</p>
<p>– 9.涨工资:董事长2000 经理1500 其他800<br>– 9.1<br>SELECT<br>– 9.2<br>SELECT<br>确定几张表和连接条件</p>
<ul>
<li>FROM emp e INNER JOIN job j ON e.<code>job_id</code> &#x3D; j.<code>id</code>; 显示字段(case表达式)<br>e.<code>ename</code>,j.<code>jname</code>,e.<code>salary</code> AS 涨前,<br>CASE j.<code>jname</code><br>WHEN ‘董事长’ THEN e.salary + 2000 WHEN ‘经理’ THEN e.salary + 1500 ELSE e.salary + 800<br>END AS 涨后<br>FROM emp e INNER JOIN job j ON e.<code>job_id</code> &#x3D; j.<code>id</code>;</li>
</ul>
<p>三.事务安全 TCL<br>3.1 概述<br>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p>
<p>应用场景:用户转账</p>
<p>准备数据</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>– 创建库<br>create database day46_pro;<br>– 使用库<br>use day46_pro;<br>– 创建数据表<br>CREATE TABLE account ( – 账户表<br>id INT PRIMARY KEY AUTO_INCREMENT, <code>name</code> VARCHAR(32),<br>money DOUBLE<br>);<br>– 添加数据<br>INSERT INTO account (<code>name</code>, money) VALUES (‘蝴蝶姐’, 1000), (‘罗志祥’, 1000);<br>模拟转账<br>1<br>2<br>3<br>4<br>5<br>– 罗志祥扣钱(转出)<br>UPDATE account SET money &#x3D; money -100 WHERE id &#x3D; 2;<br>– 机器故障了<br>– 蝴蝶姐加强(转入)<br>UPDATE account SET money &#x3D; money + 100 WHERE id &#x3D; 1;<br>3.2 操作事务<br>3.2.1 手动提交事务<br>开启事务 begin</p>
<p>提交事务 commit</p>
<p>回滚事务 rollback</p>
<p>转账成功<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>– 1. 开启事务 begin;<br>– 2. 罗志祥扣钱<br>UPDATE account SET money &#x3D; money -100 WHERE id &#x3D; 2;<br>– 3. 蝴蝶姐加钱<br>UPDATE account SET money &#x3D; money + 100 WHERE id &#x3D; 1;<br>– 4. 提交事务<br>commit;<br>转账失败<br>1<br>2<br>3<br>4<br>5<br>6<br>– 1.开启事务 begin;<br>– 2.罗志祥扣钱<br>UPDATE account SET money &#x3D; money -100 WHERE id &#x3D; 2;<br>– 3.机器故障<br>– 4.回滚事务<br>rollback;<br>3.2.2 自动提交事务<br>默认情况下，在MySQL中每一条DML(增删改)语句，就是一个独立的事务</p>
<p>查看MySQL是否开启自动提交</p>
<p>1<br>show variables like ‘autocommit’;<br>临时关闭自动提交(手动)</p>
<p>1<br>set autocommit&#x3D;off;<br>3.3 事务工作原理<br>注意:<br>在同一个事务中，出现bug(异常)，必须执行rollback命令，不然会影响同一个事务中下一次提交</p>
<p>3.4 保存(回滚)点<br>当事务开启后，一部分sql执行成功，添加一个保存点，后续操作报错了，回滚到保存点，保证之前的操作可以成功提交</p>
<p>设置保存点	savepoint 保存点名;<br>回滚到保存点	rollback to 保存点名;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>– 1.开启事务 begin;<br>– 2.罗志祥扣钱一次(凤姐)<br>UPDATE account SET money &#x3D; money -100 WHERE id &#x3D; 2;<br>– 3.罗志祥扣钱二次(芙蓉姐姐)<br>UPDATE account SET money &#x3D; money -100 WHERE id &#x3D; 2;<br>– 4.设置一个保存点 savepoint ol;<br>– 5.罗志祥扣钱三次(石榴姐)<br>UPDATE account SET money &#x3D; money -100 WHERE id &#x3D; 2;<br>– 6.机器故障<br>– 7.回滚点保存点 rollback to ol;<br>– 8.提交事务 commit;<br>3.5 事务特性 ACID<br>原子性 A atomicity</p>
<p>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p>
<p>一致性 C consistency</p>
<p>事务在执行前后，保证数据的一致性</p>
<p>隔离性 I isolation</p>
<p>多个事务之间，相互独立，互不干扰….</p>
<p>持久性 D durability</p>
<p>事务一旦成功提交，保存到磁盘文件，不可逆….</p>
<p>3.6 事务隔离性<br>多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就</p>
<p>可以解决这些问题。</p>
<p>脏读【必须要避免】</p>
<p>一个事务中，读取到另一个事务，未提交的数据</p>
<p>不可重复读</p>
<p>一个事务中，二次读取的内容不一致，另外一个事务做了update操作</p>
<p>幻读<br>一个事务中，二次读取的数量不一致，另外一个事务做了insert、delete操作</p>
<p>3.6.1 MySQL数据库隔离级别<br>级别	名字	隔离级别	脏读	不可重复读	幻读	数据库默认隔离级别<br>1	读未提交	read uncommitted	是	是	是	<br>2	读已提交	read committed	否	是	是	Oracle和SQL Server<br>3	可重复读	repeatable read	否	否	是	MySQL<br>4	串行化	serializable	否	否	否	<br>性能角度:1&gt;2&gt;3&gt;4</p>
<p>安全角度:4&gt;3&gt;2&gt;1</p>
<p>综合考虑:2 or 3</p>
<p>3.6.2 演示隔离级别产生的问题<br>级别	代码<br>查看当前数据库隔离级别	show variables like ‘%isolation%’;<br>临时修改隔离级别	set session transaction isolation level 级别字符串;<br>演示脏读<br>设置数据库隔离级别 read uncommitted;<br>1<br>set session transaction isolation level read uncommitted;<br>解决脏读问题(引出:不可重复读问题) 设置数据库隔离级别 read committed;<br>1<br>set session transaction isolation level read committed;<br>解决不可重复读问题(出现幻读问题) 设置数据库隔离级别 repeatable read;<br>1<br>set session transaction isolation level repeatable read;<br>解决幻读问题<br>设置数据库隔离级别 serializable;<br>1<br>set session transaction isolation level serializable;<br>总结<br>一 MySQL函数<br>字符串<br>concat()</p>
<p>拼接<br>char_length()</p>
<p>字符长度<br>trim()</p>
<p>去掉前后空格<br>replace()</p>
<p>替换<br>substr()</p>
<p>截取<br>日期<br>now()、curdate()、curtime()</p>
<p>year()、month()、day()</p>
<p>adddate()、subdate()</p>
<p>datediff()</p>
<p>日期间之间的计算<br>数学<br>ceil()、floor()</p>
<p>向上向下取整<br>rand()</p>
<p>随机数<br>round()</p>
<p>四舍五入<br>truncate()</p>
<p>保留指定小数位<br>高级函数<br>case表达式</p>
<p>相当于java中swtich<br>if表达式</p>
<p>相当于java中三元运算符<br>二 MySQL综合练习<br>课下必须写二遍<br>三 事务安全 TCL<br>什么是事务：<br>是指的是多个步骤的一组业务操作，要么都成功，要么都失败<br>操作<br>手动提交</p>
<p>begin<br>commit<br>rollback<br>自动提交</p>
<p>默认</p>
<p>我们使用JDBC时，手动关闭自动提交事务<br>事务原理<br>临时日志文件<br>保存点<br>设置保存点</p>
<p>savepoint 保存点名<br>回滚保存点</p>
<p>rollback to 保存点名<br>事务特性<br>A</p>
<p>原子性<br>C</p>
<p>一致性<br>I</p>
<p>隔离性<br>D</p>
<p>持久性<br>隔离性会出现问题<br>脏读<br>不可重复读<br>幻读（虚读）<br>数据库隔离级别<br>读未提交</p>
<p>读已提交</p>
<p>oracle 和 sqlServer 默认<br>可重复读</p>
<p>MySQL 默认<br>串行化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swzxsyh.github.io/2020/04/29/MySQL%E6%9F%A5%E8%AF%A2-%E7%BA%A6%E6%9D%9F-%E5%A4%9A%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="swzxsyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="swzxsyh">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/MySQL%E6%9F%A5%E8%AF%A2-%E7%BA%A6%E6%9D%9F-%E5%A4%9A%E8%A1%A8/" class="post-title-link" itemprop="url">MySQL查询 & 约束 & 多表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-29 01:31:57" itemprop="dateCreated datePublished" datetime="2020-04-29T01:31:57+08:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-15 01:25:49" itemprop="dateModified" datetime="2022-07-15T01:25:49+08:00">2022-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一.DQL高级查询<br>创建表<br>1.1 排序<br>语法:<br>1<br>2<br>select … from 表名 order by 排序列 [asc|desc],排序列 [asc|dex]<br>asc:升序 (默认值) desc:降序<br>注意:<br>多字段排序，后面的排序结果是在前面排序的基础之上<br>1<br>2<br>3<br>4<br>– 查询所有数据,使用年龄降序排序<br>select * from Day44.student order by age desc;<br>– 查询所有数据,在年龄降序排序的基础上，如果年龄相同再以数学成绩降序排序<br>SELECT * FROM student ORDER BY  age DESC,math DESC ;<br>1.2 聚合函数<br>作用:对一列数据进行计算，返回一个结果，忽略null值<br>语法:<br>关键字	说明<br>count(列名)	统计一列个数<br>max(列名)	求出一列的最大值<br>min(列名)	求出一列的最小值<br>sum(列名)	对一列求和<br>avg(列名)	求出一列的平均值<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>– 查询学生总数（null值处理）<br>SELECT COUNT(id) FROM student;<br>SELECT COUNT(isnull(english)) FROM student;<br>SELECT COUNT(<em>) FROM student;<br>– 查询年龄大于40的总数<br>SELECT COUNT(</em>) FROM student WHERE age&gt;40;</p>
<p>– 查询数学成绩总分<br>SELECT SUM(math) FROM student;<br>– 查询数学成绩平均分<br>SELECT AVG(math) FROM student;<br>– 查询数学成绩最高分<br>SELECT MAX(math) FROM student;</p>
<p>– 查询数学成绩最低分<br>SELECT MIN(math) FROM student;<br>1.3 分组<br>作用:对一列数据进行分组，相同的内容分为一组，通常与聚合函数一起使用，完成统计工作<br>语法:<br>1<br>select 分组列 from 表名 group by 分组列 having 分组后的过滤条件;<br>where和having区别<br>where在分组前进行条件过滤，不支持聚合函数 having在分组后今天条件过滤，支持聚合函数<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>– 按性别分组<br>SELECT sex FROM student GROUP BY sex;</p>
<p>– 查询男女各多少人<br>SELECT sex,COUNT(*) FROM student GROUP BY sex;</p>
<p>– 查询年龄大于25岁的人,按性别分组,统计每组的人数<br>SELECT sex,COUNT(*) FROM student WHERE age&gt;25 GROUP BY sex;</p>
<p>– 查询年龄大于25岁的人,按性别分组,统计每组的人数,并只显示性别人数大于2的数据<br>SELECT sex,COUNT(<em>) FROM student WHERE age&gt;25 GROUP BY sex having COUNT(</em>)&gt;2;<br>1.4 分页<br>语法:<br>1<br>select … from 表名 limit 开始索引,每页显示个数;<br>索引特点:<br>索引是从0开始，0也是默认值，可以省略<br>分页索引公式:<br>索引 &#x3D; (当前页-1) × 每页个数<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>– 查询学生表中数据，显示前6条<br>SELECT * FROM student LIMIT 0,6;<br>SELECT * FROM student LIMIT 6;</p>
<p>– 查询学生表中数据，从第三条开始显示，显示6条<br>SELECT * FROM student LIMIT 2,6;</p>
<p>– 模拟百度分页，一页显示5条<br>SELECT * FROM student LIMIT 5;<br>SELECT * FROM student LIMIT 5,5;<br>SELECT * FROM student LIMIT 10,5;<br>1.5 知识小结<br>1<br>select * from 表名 where 条件 group by 分组 having 分组后条件 order by 排序 limit 分页;<br>二.数据库约束<br>2.1 概述<br>作用<br>对表中的数据进行限定，保证数据的正确性、有效性和完整性。<br>关键字	说明<br>primary key	主键约束。要求表中有一个字段 唯一 且 非空，通常我们使用id作为主键<br>unique	唯一约束<br>not null	非空约束<br>default	默认值<br>foreign key	外键约束<br>2.2 实现<br>2.2.1 主键约束<br>作用:限定某一列的值非空且唯一， 主键就是表中记录的唯一标识。<br>设置主键约束<br>1)创建表<br>1<br>2<br>3<br>4<br>create table 表名(<br>id int primary key, …<br>…<br>);<br>2)已有表<br>1<br>alter tabe 表名 add primary key(id);<br>特点: 一张表只能有一个主键约束，但是我们可以设置联合主键(多个字段)<br>自增器<br>1)创建表<br>1<br>2<br>3<br>4<br>create table 表名(<br>id int priamry key auto_increment, …<br>…<br>);<br>2)特点:自增器起始值为1，可以手动指定<br>1<br>alter table 表名 auto_increment&#x3D;起始值;<br>删除主键约束<br>语法:<br>1<br>alter table 表名 drop primary key;<br>1<br>2<br>3<br>4<br>5</p>
<h1 id="1-先移出自增器"><a href="#1-先移出自增器" class="headerlink" title="1)先移出自增器"></a>1)先移出自增器</h1><p>alter table stu3 modify id int;</p>
<h1 id="2-才能删除主键约束"><a href="#2-才能删除主键约束" class="headerlink" title="2)才能删除主键约束"></a>2)才能删除主键约束</h1><p>alter table stu3 drop primary key;</p>
<h1 id="解释-因为只有主键约束才有意义设置自增器…-保证唯一性…"><a href="#解释-因为只有主键约束才有意义设置自增器…-保证唯一性…" class="headerlink" title="解释:因为只有主键约束才有意义设置自增器…(保证唯一性….)"></a>解释:因为只有主键约束才有意义设置自增器…(保证唯一性….)</h1><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>– 主键约束<br>– 给student表添加主键约束<br>ALTER TABLE student ADD PRIMARY KEY(id);<br>– 创建表时指定主键约束<br>CREATE TABLE stu1(<br>id INT PRIMARY KEY,<br><code>name</code> VARCHAR(32)<br>);<br>– 插入数据测试<br>INSERT INTO stu1 VALUES(1,’jack’);<br>– Duplicate entry ‘1’ for key ‘PRIMARY’ 错误:主键不能重复<br>INSERT INTO stu1 VALUES(1,’lucy’);<br>– Column ‘id’ cannot be null 错误:主键不能为空<br>INSERT INTO stu1 VALUES(NULL,’lucy’);<br>– 我想让name字段，也作为主键使用…<br>– Multiple primary key defined – 错误:主键被重复定义了<br>ALTER TABLE stu1 ADD PRIMARY KEY(<code>name</code>);</p>
<p>– 联合主键(主键字段完全相同，在进行约束的限定) CREATE TABLE stu2(<br>id INT ,<br><code>name</code> VARCHAR(32),<br>PRIMARY KEY(id,<code>name</code>)<br>);<br>– 插入数据测试<br>INSERT INTO stu2 VALUES(1,’jack’);<br>INSERT INTO stu2 VALUES(1,’lucy’);<br>– Duplicate entry ‘1-lucy’ for key ‘PRIMARY’ 错误<br>INSERT INTO stu2 VALUES(1,’lucy’);</p>
<p>– 自增器<br>CREATE TABLE stu3(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32)<br>);<br>– 插入数据测试<br>INSERT INTO stu3 VALUES(1,’jack’);<br>INSERT INTO stu3 VALUES(NULL,’jack’);<br>INSERT INTO stu3 VALUES(3,’jack’);<br>INSERT INTO stu3 VALUES(NULL,’jack’);<br>INSERT INTO stu3 VALUES(10,’jack’);<br>INSERT INTO stu3 VALUES(NULL,’jack’);<br>– 设置自增器起始值<br>ALTER TABLE stu3 AUTO_INCREMENT&#x3D;1000;<br>INSERT INTO stu3 VALUES(NULL,’jack’);</p>
<p>– delete(橡皮擦) 和 truncat(撕纸) 区别<br>DELETE FROM stu3;<br>INSERT INTO stu3 VALUES(NULL,’jack’);<br>TRUNCATE TABLE stu3;<br>INSERT INTO stu3 VALUES(NULL,’jack’);</p>
<p>– 1)先移出自增器<br>ALTER TABLE stu3 MODIFY id INT;<br>– 2)才能删除主键约束<br>ALTER TABLE stu3 DROP PRIMARY KEY;<br>2.2.2 唯一约束<br>作用:限定某一列的值不能重复，可以出现多个null<br>创建表时设置唯一约束<br>1<br>2<br>3<br>4<br>create table 表名(<br>列名 数据类型 unique, …<br>…<br>);<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>– 唯一约束<br>CREATE TABLE stu4(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32) UNIQUE<br>);<br>INSERT INTO stu4 VALUES(1,’jack’);<br>– Duplicate entry ‘jack’ for key ‘name’ 错误:名称重复了<br>INSERT INTO stu4 VALUES(2,’jack’);<br>INSERT INTO stu4 VALUES(3,NULL);<br>INSERT INTO stu4 VALUES(4,NULL);</p>
<p>– 删除唯一约束<br>ALTER TABLE stu4 DROP INDEX name;</p>
<p>– 创建表后添加唯一约束<br>ALTER TABLE stu4 MODIFY name VARCHAR(20) UNIQUE ;<br>2.2.3 非空约束<br>作用:限定某一列的值不能为null<br>创建表时设置非空约束<br>1<br>2<br>3<br>4<br>create table 表名(<br>列名 数据类型 not null,– 非空约束<br>列名 数据类型 unique not null,– (唯一+非空)<br>);<br>注意:唯一 + 非空 !&#x3D; 主键，主键约束一张表只能有一个，唯一+非空 设置多个</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>– 唯一+非空<br>CREATE TABLE stu5(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32) UNIQUE NOT NULL<br>);<br>INSERT INTO stu5 VALUES(1,’jack’);<br>– Column ‘name’ cannot be null 错误:名称不能为空<br>INSERT INTO stu5 VALUES(2,NULL);</p>
<p>– 移除非空约束<br>ALTER TABLE stu5 MODIFY name VARCHAR(20);<br>– 恢复<br>ALTER TABLE stu5 MODIFY name VARCHAR(20) NOT NULL;</p>
<p>2.2.4 默认值<br>创建表设置默认值<br>1<br>2<br>3<br>4<br>create table 表名(<br>列名 数据类型 default 默认值, …<br>…<br>);<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>– 默认值<br>CREATE TABLE stu6(<br>id INT PRIMARY KEY AUTO_INCREMENT, <code>name</code> VARCHAR(32),<br>sex VARCHAR(5) DEFAULT ‘男’<br>);<br>INSERT INTO stu6(id,<code>name</code>) VALUES(1,’小张’);<br>INSERT INTO stu6(id,<code>name</code>,sex) VALUES(2,’小刘’,’女’); – 因为我们指定了默认值为男，你再插入null，会把默认值覆盖…<br>INSERT INTO stu6 VALUES(3,’小王’,NULL);<br>三.表关系<br>3.1 概述<br>简称:关系型数据库(Relation DBMS)<br>3.2 实现<br>3.2.1 一对多<br>在多的一方建立外键，指向一的一方的主键<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>– 创建新库<br>CREATE DATABASE day19_pro; USE day19_pro;<br>– 一对多<br>– 班级表(主表)<br>CREATE TABLE class(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32)<br>);<br>INSERT INTO class VALUES(1,’java一班’);<br>INSERT INTO class VALUES(2,’java二班’);<br>– 学生表(从表)<br>CREATE TABLE student(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32),<br>class_id INT – 外键字段<br>);<br>INSERT INTO student VALUES(1,’流川枫’,1);<br>INSERT INTO student VALUES(2,’樱木花道’,1);<br>INSERT INTO student VALUES(3,’大猩猩’,2);<br>INSERT INTO student VALUES(4,’赤木晴子’,2);<br>– 通过班级找学生<br>SELECT * FROM student WHERE class_id &#x3D;1;<br>– 通过学生找班级<br>SELECT * FROM class WHERE id &#x3D; 2;<br>– 给学生表添加外键约束<br>ALTER TABLE student ADD CONSTRAINT class_id_fk FOREIGN KEY(class_id) REFERENCES class(id);<br>– 删除学生表的外键约束<br>ALTER TABLE student DROP FOREIGN KEY class_id_fk;<br>3.2.2 多对多<br>多对多关系实现需要借助第三张表。中间表至少包含2个字段，这两个字段作为第三张表的外键，分别指向两张表的主键<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>– 多对多<br>– 课程表(主表)<br>CREATE TABLE course(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32)<br>);<br>INSERT INTO course VALUES(1,’java’);<br>INSERT INTO course VALUES(2,’ui’);<br>INSERT INTO course VALUES(3,’美容美发’);<br>INSERT INTO course VALUES(4,’挖掘机’);<br>– 中间表(从表)<br>CREATE TABLE sc(<br>  s_id INT,<br>  c_id INT,<br>  PRIMARY KEY(s_id,c_id)<br>);<br>INSERT INTO sc VALUES(1,1);<br>INSERT INTO sc VALUES(1,2);<br>INSERT INTO sc VALUES(2,1);<br>INSERT INTO sc VALUES(2,3);<br>– 联合主键，可以帮我们校验重复选修问题<br>INSERT INTO sc VALUES(1,1);<br>– 给中间表增加外键约束<br>ALTER TABLE sc ADD CONSTRAINT s_id_fk FOREIGN KEY(s_id) REFERENCES student(id);<br>ALTER TABLE sc ADD CONSTRAINT c_id_fk FOREIGN KEY(c_id) REFERENCES course(id);<br>– 流川枫不能选修，不存在的课程<br>INSERT INTO sc VALUES(1,6);<br>3.2.3 一对一<br>一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>– 一对一<br>– 公司表<br>CREATE TABLE company(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br><code>name</code> VARCHAR(32)<br>);<br>INSERT INTO company VALUES(1,’拼多多’);<br>INSERT INTO company VALUES(2,’传智播客’);<br>– 地址表<br>CREATE TABLE address(<br>id INT PRIMARY KEY AUTO_INCREMENT, – 同时也作为外键<br><code>name</code> VARCHAR(32),<br>CONSTRAINT id_fk FOREIGN KEY(id) REFERENCES company(id)<br>);<br>INSERT INTO address VALUES(1,’上海’);<br>INSERT INTO address VALUES(2,’江苏沭阳’);<br>3.3 外键约束<br>作用:限定二张表有关系的数据，保证数据的正确性、有效性和完整性<br>在从表中添加外键约束<br>1)创建表<br>1<br>2<br>create table 表名( 列名 数据类型,<br>[constraint] [约束名] foreign key(外键列) references 主表(主键) );<br>2)已有表<br>1<br>alter table 表名 add [constraint] [约束名] foreign key(外键列) references 主表(主键);<br>外键约束特点<br>1)主表不能删除从表已引用的数据<br>2)从表不能添加主表未拥有的数据<br>3)先添加主表数据再添加从表数据<br>4)先删除从表数据再删除主表数据<br>5)外键约束允许为空但不能是错的<br>删除外键约束<br>1<br>alter table 表名 drop foreign key 约束名;<br>总结<br>dql单表高级查询<br>排序<br>select … from 表名 order by 排序列 [asc | desc]</p>
<p>asc 升序 默认值<br>desc 降序<br>聚合函数<br>count</p>
<p>count(*) ，统计包含null数据<br>max</p>
<p>min</p>
<p>sum</p>
<p>avg</p>
<p>分组<br>select 分组 表名 group by 分组 having 分组后条件</p>
<p>where在分组前条件过滤，不能使用聚合函数<br>having在分组后条件过滤，可以使用聚合函数<br>分页<br>select … from 表名 limit 开始索引,每页显示个数</p>
<p>索引公式：</p>
<p>索引&#x3D; （当前页-1）× 每页显示个数<br>数据库约束<br>对数据进一步限定，保证数据的正确性，有效性和完整性<br>分类<br>1）主键</p>
<p>primary key</p>
<p>给每一条记录增加唯一标识，非空且唯一<br>2）唯一</p>
<p>unique<br>3）非空</p>
<p>not null<br>4）默认值</p>
<p>default<br>5）外键</p>
<p>foreign key<br>创建表时候设置主键约束<br>create table 表名(</p>
<p>id int primary key auto_increment,</p>
<p>…</p>
<p>..</p>
<p>);</p>
<p>表关系<br>一对多<br>应用场景</p>
<p>班级和学生<br>部门和员工<br>实例</p>
<p>一个班级下面有多名学生，多名学生属于同一个班级<br>建表原则</p>
<p>在从表中添加一个字段（列），字段名（主表名_id）类型与主表的主键一致，这个字段称为外键，通过外键指向主表的主键，建立关联关系<br>多对多<br>应用场景</p>
<p>老师和学生<br>学生和课程<br>实例</p>
<p>一个学生可以选修多门课程，一门课程可以被多个学生选修<br>建表原则</p>
<p>多对多其实由二个一对多组成<br>需要借助于第三张表（中间表），需要有二个外键字段分别指向各自的主键，通常还会作为联合主键<br>一对一<br>应用场景</p>
<p>公民和身份证号<br>公司和注册地<br>实例</p>
<p>一个公民只能有一个身份证号，一个身份证号只能属于一个公民<br>建表原则</p>
<p>主键是外键</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">swzxsyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swzxsyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/swzxsyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;swzxsyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swzxsyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
